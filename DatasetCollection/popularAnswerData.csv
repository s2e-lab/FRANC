20159305,"<p><em>Note: Most of the ideas here are pretty generic for Stack Overflow, indeed questions in general. See <a href=""https://stackoverflow.com/help/minimal-reproducible-example"">Minimal, Reproducible Example</a>; see also <a href=""http://sscce.org/"" rel=""nofollow noreferrer"">Short, Self Contained, Correct Example</a>.</em></p>
<p><strong>Disclaimer: Writing a good question is <em>hard</em>.</strong></p>
<h3>The Good:</h3>
<ul>
<li><p>Do include a small example DataFrame, either as runnable code:</p>
<pre><code>In [1]: df = pd.DataFrame([[1, 2], [1, 3], [4, 6]], columns=['A', 'B'])
</code></pre>
<p>or make it &quot;copy and pasteable&quot; using <code>pd.read_clipboard(sep='\s\s+')</code>. You can format the text for Stack Overflow by highlighting and using <kbd>Ctrl</kbd>+<kbd>K</kbd> (or prepend four spaces to each line), or place three backticks (```) above and below your code with your code unindented:</p>
<pre><code>In [2]: df
Out[2]:
   A  B
0  1  2
1  1  3
2  4  6
</code></pre>
<p>Test <code>pd.read_clipboard(sep='\s\s+')</code> yourself.</p>
<ul>
<li><p>I really do mean <strong>small</strong>. The vast majority of example DataFrames could be fewer than 6 rows,<sup>[citation needed]</sup> and <strong>I bet I can do it in 5 rows</strong>. Can you reproduce the error with <code>df = df.head()</code>? If not, fiddle around to see if you can make up a small DataFrame which exhibits the issue you are facing.</p>
<p>But every rule has an exception, the obvious one being for performance issues  (in which case definitely use <a href=""https://ipython.readthedocs.io/en/stable/interactive/magics.html#magic-timeit"" rel=""nofollow noreferrer""><code>%timeit</code></a> and possibly <a href=""https://ipython.readthedocs.io/en/stable/interactive/magics.html#magic-prun"" rel=""nofollow noreferrer""><code>%prun</code></a>), where you should generate:</p>
<pre><code>df = pd.DataFrame(np.random.randn(100000000, 10))
</code></pre>
<p>Consider using <code>np.random.seed</code> so we have the exact same frame. Having said that, &quot;make this code fast for me&quot; is not strictly on topic for the site.</p>
</li>
</ul>
</li>
<li><p>Write out the outcome you desire (similarly to above)</p>
<pre><code>In [3]: iwantthis
Out[3]:
   A  B
0  1  5
1  4  6
</code></pre>
<p>Explain where the numbers come from:</p>
<blockquote>
<p>The 5 is the sum of the B column for the rows where A is 1.</p>
</blockquote>
</li>
<li><p>Do show <em>the code</em> you've tried:</p>
<pre><code>In [4]: df.groupby('A').sum()
Out[4]:
   B
A
1  5
4  6
</code></pre>
<p>But say what's incorrect:</p>
<blockquote>
<p>The A column is in the index rather than a column.</p>
</blockquote>
</li>
<li><p>Do show you've done some research (<a href=""http://pandas.pydata.org/pandas-docs/stable/search.html?q=groupby+sum"" rel=""nofollow noreferrer"">search the documentation</a>, <a href=""https://stackoverflow.com/search?q=%5Bpandas%5D+groupby+sum"">search StackÂ Overflow</a>), and give a summary:</p>
<blockquote>
<p>The docstring for sum simply states &quot;Compute sum of group values&quot;</p>
</blockquote>
<blockquote>
<p>The <a href=""http://pandas.pydata.org/pandas-docs/stable/groupby.html#cython-optimized-aggregation-functions"" rel=""nofollow noreferrer"">groupby documentation</a> doesn't give any examples for this.</p>
</blockquote>
<p><em>Aside: the answer here is to use <code>df.groupby('A', as_index=False).sum()</code>.</em></p>
</li>
<li><p>If it's relevant that you have Timestamp columns, e.g. you're resampling or something, then be explicit and apply <code>pd.to_datetime</code> to them for good measure.</p>
<pre><code>df['date'] = pd.to_datetime(df['date']) # this column ought to be date.
</code></pre>
<p>Sometimes this is the issue itself: they were strings.</p>
</li>
</ul>
<h3>The Bad:</h3>
<ul>
<li><p>Don't include a MultiIndex, which <strong>we can't copy and paste</strong> (see above). This is kind of a grievance with Pandas' default display, but nonetheless annoying:</p>
<pre><code>In [11]: df
Out[11]:
     C
A B
1 2  3
  2  6
</code></pre>
<p>The correct way is to include an ordinary DataFrame with a <a href=""http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.set_index.html"" rel=""nofollow noreferrer""><code>set_index</code></a> call:</p>
<pre><code>In [12]: df = pd.DataFrame([[1, 2, 3], [1, 2, 6]], columns=['A', 'B', 'C'])

In [13]: df = df.set_index(['A', 'B'])

In [14]: df
Out[14]:
     C
A B
1 2  3
  2  6
</code></pre>
</li>
<li><p>Do provide insight to what it is when giving the outcome you want:</p>
<pre><code>   B
A
1  1
5  0
</code></pre>
<p>Be specific about how you got the numbers (what are they)... double check they're correct.</p>
</li>
<li><p>If your code throws an error, do include the entire stack trace. This can be edited out later if it's too noisy. Show the line number and the corresponding line of your code which it's raising against.</p>
</li>
</ul>
<h3>The Ugly:</h3>
<ul>
<li><p>Don't link to a <a href=""https://en.wikipedia.org/wiki/Comma-separated_values"" rel=""nofollow noreferrer"">CSV</a> file we don't have access to (and ideally don't link to an external source at all).</p>
<pre><code>df = pd.read_csv('my_secret_file.csv') # ideally with lots of parsing options
</code></pre>
<p><strong>Most data is proprietary</strong>, we get that. Make up similar data and see if you can reproduce the problem (something small).</p>
</li>
<li><p>Don't explain the situation vaguely in words, like you have a DataFrame which is &quot;large&quot;, mention some of the column names in passing (be sure not to mention their dtypes). Try and go into lots of detail about something which is completely meaningless without seeing the actual context. Presumably no one is even going to read to the end of this paragraph.</p>
<p><em>Essays are bad; it's easier with small examples.</em></p>
</li>
<li><p>Don't include 10+ (100+??) lines of data munging before getting to your actual question.</p>
<p>Please, we see enough of this in our day jobs. We want to help, but <a href=""https://www.youtube.com/watch?v=ECfRp-jwbI4"" rel=""nofollow noreferrer"">not like this...</a>.
Cut the intro, and just show the relevant DataFrames (or small versions of them) in the step which is causing you trouble.</p>
</li>
</ul>
"
15112149,"<p>You misunderstand how boolean expressions work; they don't work like an English sentence and guess that you are talking about the same comparison for all names here. You are looking for:</p>
<pre><code>if x == 1 or y == 1 or z == 1:
</code></pre>
<p><code>x</code> and <code>y</code> are otherwise evaluated on their own (<code>False</code> if <code>0</code>, <code>True</code> otherwise).</p>
<p>You can shorten that using a containment test against <a href=""https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences"" rel=""noreferrer"">a tuple</a>:</p>
<pre><code>if 1 in (x, y, z):
</code></pre>
<p>or better still:</p>
<pre><code>if 1 in {x, y, z}:
</code></pre>
<p>using <a href=""https://docs.python.org/3/tutorial/datastructures.html#sets"" rel=""noreferrer"">a <code>set</code></a> to take advantage of the constant-cost membership test (i.e. <code>in</code> takes a fixed amount of time whatever the left-hand operand is).</p>
<h3>Explanation</h3>
<p>When you use <code>or</code>, python sees each side of the operator as <em>separate</em> expressions. The expression <code>x or y == 1</code> is treated as first a boolean test for <code>x</code>, then if that is False, the expression <code>y == 1</code> is tested.</p>
<p>This is due to <a href=""http://docs.python.org/3/reference/expressions.html#operator-precedence"" rel=""noreferrer"">operator precedence</a>. The <code>or</code> operator has a lower precedence than the <code>==</code> test, so the latter is evaluated <em>first</em>.</p>
<p>However, even if this were <em>not</em> the case, and the expression <code>x or y or z == 1</code> was actually interpreted as <code>(x or y or z) == 1</code> instead, this would still not do what you expect it to do.</p>
<p><code>x or y or z</code> would evaluate to the first argument that is 'truthy', e.g. not <code>False</code>, numeric 0 or empty (see <a href=""http://docs.python.org/3/reference/expressions.html#boolean-operations"" rel=""noreferrer"">boolean expressions</a> for details on what Python considers false in a boolean context).</p>
<p>So for the values <code>x = 2; y = 1; z = 0</code>, <code>x or y or z</code> would resolve to <code>2</code>, because that is the first true-like value in the arguments. Then <code>2 == 1</code> would be <code>False</code>, even though <code>y == 1</code> would be <code>True</code>.</p>
<p>The same would apply to the inverse; testing multiple values against a single variable; <code>x == 1 or 2 or 3</code> would fail for the same reasons. Use <code>x == 1 or x == 2 or x == 3</code> or <code>x in {1, 2, 3}</code>.</p>
"
1373185,"<p>You can use <a href=""https://docs.python.org/tutorial/datastructures.html#dictionaries"" rel=""nofollow noreferrer"">dictionaries</a> to accomplish this. Dictionaries are stores of keys and values.</p>
<pre><code>&gt;&gt;&gt; dct = {'x': 1, 'y': 2, 'z': 3}
&gt;&gt;&gt; dct
{'x': 1, 'y': 2, 'z': 3}
&gt;&gt;&gt; dct[&quot;y&quot;]
2
</code></pre>
<p>You can use variable key names to achieve the effect of variable variables without the security risk.</p>
<pre><code>&gt;&gt;&gt; x = &quot;spam&quot;
&gt;&gt;&gt; z = {x: &quot;eggs&quot;}
&gt;&gt;&gt; z[&quot;spam&quot;]
'eggs'
</code></pre>
<p>For cases where you're thinking of doing something like</p>
<pre><code>var1 = 'foo'
var2 = 'bar'
var3 = 'baz'
...
</code></pre>
<p>a <a href=""https://docs.python.org/tutorial/introduction.html#lists"" rel=""nofollow noreferrer"">list</a> may be more appropriate than a dict. A list represents an ordered sequence of objects, with integer indices:</p>
<pre><code>lst = ['foo', 'bar', 'baz']
print(lst[1])           # prints bar, because indices start at 0
lst.append('potatoes')  # lst is now ['foo', 'bar', 'baz', 'potatoes']
</code></pre>
<p>For ordered sequences, lists are more convenient than dicts with integer keys, because lists support iteration in index order, <a href=""https://stackoverflow.com/questions/509211/understanding-pythons-slice-notation"">slicing</a>, <code>append</code>, and other operations that would require awkward key management with a dict.</p>
"
23294659,"<p>The simplest way to accomplish this is to put the <code>input</code> method in a while loop. Use <a href=""https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops"" rel=""noreferrer""><code>continue</code></a> when you get bad input, and <code>break</code> out of the loop when you're satisfied.</p>

<h2>When Your Input Might Raise an Exception</h2>

<p>Use <a href=""https://docs.python.org/3/tutorial/errors.html#handling-exceptions"" rel=""noreferrer""><code>try</code> and <code>except</code></a> to detect when the user enters data that can't be parsed.</p>

<pre><code>while True:
    try:
        # Note: Python 2.x users should use raw_input, the equivalent of 3.x's input
        age = int(input(""Please enter your age: ""))
    except ValueError:
        print(""Sorry, I didn't understand that."")
        #better try again... Return to the start of the loop
        continue
    else:
        #age was successfully parsed!
        #we're ready to exit the loop.
        break
if age &gt;= 18: 
    print(""You are able to vote in the United States!"")
else:
    print(""You are not able to vote in the United States."")
</code></pre>

<h2>Implementing Your Own Validation Rules</h2>

<p>If you want to reject values that Python can successfully parse, you can add your own validation logic.</p>

<pre><code>while True:
    data = input(""Please enter a loud message (must be all caps): "")
    if not data.isupper():
        print(""Sorry, your response was not loud enough."")
        continue
    else:
        #we're happy with the value given.
        #we're ready to exit the loop.
        break

while True:
    data = input(""Pick an answer from A to D:"")
    if data.lower() not in ('a', 'b', 'c', 'd'):
        print(""Not an appropriate choice."")
    else:
        break
</code></pre>

<h2>Combining Exception Handling and Custom Validation</h2>

<p>Both of the above techniques can be combined into one loop.</p>

<pre><code>while True:
    try:
        age = int(input(""Please enter your age: ""))
    except ValueError:
        print(""Sorry, I didn't understand that."")
        continue

    if age &lt; 0:
        print(""Sorry, your response must not be negative."")
        continue
    else:
        #age was successfully parsed, and we're happy with its value.
        #we're ready to exit the loop.
        break
if age &gt;= 18: 
    print(""You are able to vote in the United States!"")
else:
    print(""You are not able to vote in the United States."")
</code></pre>

<h2>Encapsulating it All in a Function</h2>

<p>If you need to ask your user for a lot of different values, it might be useful to put this code in a function, so you don't have to retype it every time.</p>

<pre><code>def get_non_negative_int(prompt):
    while True:
        try:
            value = int(input(prompt))
        except ValueError:
            print(""Sorry, I didn't understand that."")
            continue

        if value &lt; 0:
            print(""Sorry, your response must not be negative."")
            continue
        else:
            break
    return value

age = get_non_negative_int(""Please enter your age: "")
kids = get_non_negative_int(""Please enter the number of children you have: "")
salary = get_non_negative_int(""Please enter your yearly earnings, in dollars: "")
</code></pre>

<h3>Putting It All Together</h3>

<p>You can extend this idea to make a very generic input function:</p>

<pre><code>def sanitised_input(prompt, type_=None, min_=None, max_=None, range_=None):
    if min_ is not None and max_ is not None and max_ &lt; min_:
        raise ValueError(""min_ must be less than or equal to max_."")
    while True:
        ui = input(prompt)
        if type_ is not None:
            try:
                ui = type_(ui)
            except ValueError:
                print(""Input type must be {0}."".format(type_.__name__))
                continue
        if max_ is not None and ui &gt; max_:
            print(""Input must be less than or equal to {0}."".format(max_))
        elif min_ is not None and ui &lt; min_:
            print(""Input must be greater than or equal to {0}."".format(min_))
        elif range_ is not None and ui not in range_:
            if isinstance(range_, range):
                template = ""Input must be between {0.start} and {0.stop}.""
                print(template.format(range_))
            else:
                template = ""Input must be {0}.""
                if len(range_) == 1:
                    print(template.format(*range_))
                else:
                    expected = "" or "".join((
                        "", "".join(str(x) for x in range_[:-1]),
                        str(range_[-1])
                    ))
                    print(template.format(expected))
        else:
            return ui
</code></pre>

<p>With usage such as:</p>

<pre><code>age = sanitised_input(""Enter your age: "", int, 1, 101)
answer = sanitised_input(""Enter your answer: "", str.lower, range_=('a', 'b', 'c', 'd'))
</code></pre>

<h2>Common Pitfalls, and Why you Should Avoid Them</h2>

<h3>The Redundant Use of Redundant <code>input</code> Statements</h3>

<p>This method works but is generally considered poor style:</p>

<pre><code>data = input(""Please enter a loud message (must be all caps): "")
while not data.isupper():
    print(""Sorry, your response was not loud enough."")
    data = input(""Please enter a loud message (must be all caps): "")
</code></pre>

<p>It might look attractive initially because it's shorter than the <code>while True</code> method, but it violates the <a href=""http://en.wikipedia.org/wiki/Don%27t_repeat_yourself"" rel=""noreferrer"">Don't Repeat Yourself</a> principle of software development. This increases the likelihood of bugs in your system. What if you want to backport to 2.7 by changing <code>input</code> to <code>raw_input</code>, but accidentally change only the first <code>input</code> above? It's a <code>SyntaxError</code> just waiting to happen.</p>

<h3>Recursion Will Blow Your Stack</h3>

<p>If you've just learned about recursion, you might be tempted to use it in <code>get_non_negative_int</code> so you can dispose of the while loop.</p>

<pre><code>def get_non_negative_int(prompt):
    try:
        value = int(input(prompt))
    except ValueError:
        print(""Sorry, I didn't understand that."")
        return get_non_negative_int(prompt)

    if value &lt; 0:
        print(""Sorry, your response must not be negative."")
        return get_non_negative_int(prompt)
    else:
        return value
</code></pre>

<p>This appears to work fine most of the time, but if the user enters invalid data enough times, the script will terminate with a <code>RuntimeError: maximum recursion depth exceeded</code>. You may think ""no fool would make 1000 mistakes in a row"", but you're underestimating the ingenuity of fools!</p>
"
509295,"<p>The syntax is:</p>
<pre><code>a[start:stop]  # items start through stop-1
a[start:]      # items start through the rest of the array
a[:stop]       # items from the beginning through stop-1
a[:]           # a copy of the whole array
</code></pre>
<p>There is also the <code>step</code> value, which can be used with any of the above:</p>
<pre><code>a[start:stop:step] # start through not past stop, by step
</code></pre>
<p>The key point to remember is that the <code>:stop</code> value represents the first value that is <em>not</em> in the selected slice. So, the difference between <code>stop</code> and <code>start</code> is the number of elements selected (if <code>step</code> is 1, the default).</p>
<p>The other feature is that <code>start</code> or <code>stop</code> may be a <em>negative</em> number, which means it counts from the end of the array instead of the beginning. So:</p>
<pre><code>a[-1]    # last item in the array
a[-2:]   # last two items in the array
a[:-2]   # everything except the last two items
</code></pre>
<p>Similarly, <code>step</code> may be a negative number:</p>
<pre><code>a[::-1]    # all items in the array, reversed
a[1::-1]   # the first two items, reversed
a[:-3:-1]  # the last two items, reversed
a[-3::-1]  # everything except the last two items, reversed
</code></pre>
<p>Python is kind to the programmer if there are fewer items than you ask for. For example, if you ask for <code>a[:-2]</code> and <code>a</code> only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen.</p>
<h3>Relationship with the <code>slice</code> object</h3>
<p>A <a href=""https://www.w3schools.com/python/ref_func_slice.asp"" rel=""noreferrer""><code>slice</code> object</a> can represent a slicing operation, i.e.:</p>
<pre><code>a[start:stop:step]
</code></pre>
<p>is equivalent to:</p>
<pre><code>a[slice(start, stop, step)]
</code></pre>
<p>Slice objects also behave slightly differently depending on the number of arguments, similarly to <code>range()</code>, i.e. both <code>slice(stop)</code> and <code>slice(start, stop[, step])</code> are supported.
To skip specifying a given argument, one might use <code>None</code>, so that e.g. <code>a[start:]</code> is equivalent to <code>a[slice(start, None)]</code> or <code>a[::-1]</code> is equivalent to <code>a[slice(None, None, -1)]</code>.</p>
<p>While the <code>:</code>-based notation is very helpful for simple slicing, the explicit use of <code>slice()</code> objects simplifies the programmatic generation of slicing.</p>
"
240205,"<p>When you write <code>[x]*3</code> you get, essentially, the list <code>[x, x, x]</code>. That is, a list with 3 references to the same <code>x</code>. When you then modify this single <code>x</code> it is visible via all three references to it:</p>
<pre><code>x = [1] * 4
xs = [x] * 3
print(f&quot;id(x): {id(x)}&quot;)
# id(x): 140560897920048
print(
    f&quot;id(xs[0]): {id(xs[0])}\n&quot;
    f&quot;id(xs[1]): {id(xs[1])}\n&quot;
    f&quot;id(xs[2]): {id(xs[2])}&quot;
)
# id(xs[0]): 140560897920048
# id(xs[1]): 140560897920048
# id(xs[2]): 140560897920048

x[0] = 42
print(f&quot;x: {x}&quot;)
# x: [42, 1, 1, 1]
print(f&quot;xs: {xs}&quot;)
# xs: [[42, 1, 1, 1], [42, 1, 1, 1], [42, 1, 1, 1]]
</code></pre>
<p>To fix it, you need to make sure that you create a new list at each position. One way to do it is</p>
<pre><code>[[1]*4 for _ in range(3)]
</code></pre>
<p>which will reevaluate <code>[1]*4</code> each time instead of evaluating it once and making 3 references to 1 list.</p>
<hr />
<p>You might wonder why <code>*</code> can't make independent objects the way the list comprehension does. That's because the multiplication operator <code>*</code> operates on objects, without seeing expressions. When you use <code>*</code> to multiply <code>[[1] * 4]</code> by 3, <code>*</code> only sees the 1-element list <code>[[1] * 4]</code> evaluates to, not the <code>[[1] * 4</code> expression text. <code>*</code> has no idea how to make copies of that element, no idea how to reevaluate <code>[[1] * 4]</code>, and no idea you even want copies, and in general, there might not even be a way to copy the element.</p>
<p>The only option <code>*</code> has is to make new references to the existing sublist instead of trying to make new sublists. Anything else would be inconsistent or require major redesigning of fundamental language design decisions.</p>
<p>In contrast, a list comprehension reevaluates the element expression on every iteration. <code>[[1] * 4 for n in range(3)]</code> reevaluates <code>[1] * 4</code> every time for the same reason <code>[x**2 for x in range(3)]</code> reevaluates <code>x**2</code> every time. Every evaluation of <code>[1] * 4</code> generates a new list, so the list comprehension does what you wanted.</p>
<p>Incidentally, <code>[1] * 4</code> also doesn't copy the elements of <code>[1]</code>, but that doesn't matter, since integers are immutable. You can't do something like <code>1.value = 2</code> and turn a 1 into a 2.</p>
"
47152692,"<p>Here is a list of idioms we can use to pivot</p>
<ol>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pivot_table.html"" rel=""noreferrer""><code>pd.DataFrame.pivot_table</code></a></p>
<ul>
<li>A glorified version of <code>groupby</code> with more intuitive API.  For many people, this is the preferred approach.  And it is the intended approach by the developers.</li>
<li>Specify row level, column levels, values to be aggregated, and function(s) to perform aggregations.</li>
</ul>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html"" rel=""noreferrer""><code>pd.DataFrame.groupby</code></a> + <a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.unstack.html"" rel=""noreferrer""><code>pd.DataFrame.unstack</code></a></p>
<ul>
<li>Good general approach for doing just about any type of pivot</li>
<li>You specify all columns that will constitute the pivoted row levels and column levels in one group by.  You follow that by selecting the remaining columns you want to aggregate and the function(s) you want to perform the aggregation.  Finally, you <code>unstack</code> the levels that you want to be in the column index.</li>
</ul>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.set_index.html"" rel=""noreferrer""><code>pd.DataFrame.set_index</code></a> + <a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.unstack.html"" rel=""noreferrer""><code>pd.DataFrame.unstack</code></a></p>
<ul>
<li>Convenient and intuitive for some (myself included).  Cannot handle duplicate grouped keys.</li>
<li>Similar to the <code>groupby</code> paradigm, we specify all columns that will eventually be either row or column levels and set those to be the index.  We then <code>unstack</code> the levels we want in the columns.  If either the remaining index levels or column levels are not unique, this method will fail.</li>
</ul>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pivot.html"" rel=""noreferrer""><code>pd.DataFrame.pivot</code></a></p>
<ul>
<li>Very similar to <code>set_index</code> in that it shares the duplicate key limitation.  The API is very limited as well.  It only takes scalar values for <code>index</code>, <code>columns</code>, <code>values</code>.</li>
<li>Similar to the <code>pivot_table</code> method in that we select rows, columns, and values on which to pivot.  However, we cannot aggregate and if either rows or columns are not unique, this method will fail.</li>
</ul>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.crosstab.html"" rel=""noreferrer""><code>pd.crosstab</code></a></p>
<ul>
<li>This a specialized version of <code>pivot_table</code> and in its purest form is the most intuitive way to perform several tasks.</li>
</ul>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.factorize.html"" rel=""noreferrer""><code>pd.factorize</code></a> + <a href=""https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.bincount.html"" rel=""noreferrer""><code>np.bincount</code></a></p>
<ul>
<li>This is a highly advanced technique that is very obscure but is very fast.  It cannot be used in all circumstances, but when it can be used and you are comfortable using it, you will reap the performance rewards.</li>
</ul>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.get_dummies.html"" rel=""noreferrer""><code>pd.get_dummies</code></a> + <a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.dot.html"" rel=""noreferrer""><code>pd.DataFrame.dot</code></a></p>
<ul>
<li>I use this for cleverly performing cross tabulation.</li>
</ul>
</li>
</ol>
<p>See also:</p>
<ul>
<li><a href=""https://pandas.pydata.org/docs/user_guide/reshaping.html"" rel=""noreferrer"">Reshaping and pivot tables</a> â pandas User Guide</li>
</ul>
<hr />
<h3>Question 1</h3>
<blockquote>
<p>Why do I get <code>ValueError: Index contains duplicate entries, cannot reshape</code></p>
</blockquote>
<p>This occurs because pandas is attempting to reindex either a <code>columns</code> or <code>index</code> object with duplicate entries.  There are varying methods to use that can perform a pivot.  Some of them are not well suited to when there are duplicates of the keys on which it is being asked to pivot.  For example:  Consider <code>pd.DataFrame.pivot</code>.  I know there are duplicate entries that share the <code>row</code> and <code>col</code> values:</p>
<pre><code>df.duplicated(['row', 'col']).any()

True
</code></pre>
<p>So when I <code>pivot</code> using</p>
<pre><code>df.pivot(index='row', columns='col', values='val0')
</code></pre>
<p>I get the error mentioned above.  In fact, I get the same error when I try to perform the same task with:</p>
<pre><code>df.set_index(['row', 'col'])['val0'].unstack()
</code></pre>
<hr />
<h2>Examples</h2>
<p>What I'm going to do for each subsequent question is to answer it using <a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pivot_table.html"" rel=""noreferrer""><code>pd.DataFrame.pivot_table</code></a>.  Then I'll provide alternatives to perform the same task.</p>
<h3>Questions 2 and 3</h3>
<blockquote>
<p>How do I pivot <code>df</code> such that the <code>col</code> values are columns, <code>row</code> values are the index, and mean of <code>val0</code> are the values?</p>
</blockquote>
<ul>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pivot_table.html"" rel=""noreferrer""><code>pd.DataFrame.pivot_table</code></a></p>
<pre><code>df.pivot_table(
    values='val0', index='row', columns='col',
    aggfunc='mean')

col   col0   col1   col2   col3  col4
row                                  
row0  0.77  0.605    NaN  0.860  0.65
row2  0.13    NaN  0.395  0.500  0.25
row3   NaN  0.310    NaN  0.545   NaN
row4   NaN  0.100  0.395  0.760  0.24
</code></pre>
<ul>
<li><code>aggfunc='mean'</code> is the default and I didn't have to set it.  I included it to be explicit.</li>
</ul>
</li>
</ul>
<blockquote>
<p>How do I make it so that missing values are 0?</p>
</blockquote>
<ul>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pivot_table.html"" rel=""noreferrer""><code>pd.DataFrame.pivot_table</code></a></p>
<ul>
<li><code>fill_value</code> is not set by default.  I tend to set it appropriately.  In this case I set it to <code>0</code>.</li>
</ul>
<pre><code>df.pivot_table(
    values='val0', index='row', columns='col',
    fill_value=0, aggfunc='mean')

col   col0   col1   col2   col3  col4
row
row0  0.77  0.605  0.000  0.860  0.65
row2  0.13  0.000  0.395  0.500  0.25
row3  0.00  0.310  0.000  0.545  0.00
row4  0.00  0.100  0.395  0.760  0.24
</code></pre>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html"" rel=""noreferrer""><code>pd.DataFrame.groupby</code></a></p>
<pre><code>df.groupby(['row', 'col'])['val0'].mean().unstack(fill_value=0)
</code></pre>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.crosstab.html"" rel=""noreferrer""><code>pd.crosstab</code></a></p>
<pre><code>pd.crosstab(
    index=df['row'], columns=df['col'],
    values=df['val0'], aggfunc='mean').fillna(0)
</code></pre>
</li>
</ul>
<hr />
<h3>Question 4</h3>
<blockquote>
<p>Can I get something other than <code>mean</code>, like maybe <code>sum</code>?</p>
</blockquote>
<ul>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pivot_table.html"" rel=""noreferrer""><code>pd.DataFrame.pivot_table</code></a></p>
<pre><code>df.pivot_table(
    values='val0', index='row', columns='col',
    fill_value=0, aggfunc='sum')

col   col0  col1  col2  col3  col4
row
row0  0.77  1.21  0.00  0.86  0.65
row2  0.13  0.00  0.79  0.50  0.50
row3  0.00  0.31  0.00  1.09  0.00
row4  0.00  0.10  0.79  1.52  0.24
</code></pre>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html"" rel=""noreferrer""><code>pd.DataFrame.groupby</code></a></p>
<pre><code>df.groupby(['row', 'col'])['val0'].sum().unstack(fill_value=0)
</code></pre>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.crosstab.html"" rel=""noreferrer""><code>pd.crosstab</code></a></p>
<pre><code>pd.crosstab(
    index=df['row'], columns=df['col'],
    values=df['val0'], aggfunc='sum').fillna(0)
</code></pre>
</li>
</ul>
<hr />
<h3>Question 5</h3>
<blockquote>
<p>Can I do more that one aggregation at a time?</p>
</blockquote>
<p>Notice that for <code>pivot_table</code> and <code>crosstab</code> I needed to pass list of callables.  On the other hand, <code>groupby.agg</code> is able to take strings for a limited number of special functions.  <code>groupby.agg</code> would also have taken the same callables we passed to the others, but it is often more efficient to leverage the string function names as there are efficiencies to be gained.</p>
<ul>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pivot_table.html"" rel=""noreferrer""><code>pd.DataFrame.pivot_table</code></a></p>
<pre><code>df.pivot_table(
    values='val0', index='row', columns='col',
    fill_value=0, aggfunc=[np.size, np.mean])

     size                      mean
col  col0 col1 col2 col3 col4  col0   col1   col2   col3  col4
row
row0    1    2    0    1    1  0.77  0.605  0.000  0.860  0.65
row2    1    0    2    1    2  0.13  0.000  0.395  0.500  0.25
row3    0    1    0    2    0  0.00  0.310  0.000  0.545  0.00
row4    0    1    2    2    1  0.00  0.100  0.395  0.760  0.24
</code></pre>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html"" rel=""noreferrer""><code>pd.DataFrame.groupby</code></a></p>
<pre><code>df.groupby(['row', 'col'])['val0'].agg(['size', 'mean']).unstack(fill_value=0)
</code></pre>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.crosstab.html"" rel=""noreferrer""><code>pd.crosstab</code></a></p>
<pre><code>pd.crosstab(
    index=df['row'], columns=df['col'],
    values=df['val0'], aggfunc=[np.size, np.mean]).fillna(0, downcast='infer')
</code></pre>
</li>
</ul>
<hr />
<h3>Question 6</h3>
<blockquote>
<p>Can I aggregate over multiple value columns?</p>
</blockquote>
<ul>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pivot_table.html"" rel=""noreferrer""><code>pd.DataFrame.pivot_table</code></a> we pass <code>values=['val0', 'val1']</code> but we could've left that off completely</p>
<pre><code>df.pivot_table(
    values=['val0', 'val1'], index='row', columns='col',
    fill_value=0, aggfunc='mean')

      val0                             val1
col   col0   col1   col2   col3  col4  col0   col1  col2   col3  col4
row
row0  0.77  0.605  0.000  0.860  0.65  0.01  0.745  0.00  0.010  0.02
row2  0.13  0.000  0.395  0.500  0.25  0.45  0.000  0.34  0.440  0.79
row3  0.00  0.310  0.000  0.545  0.00  0.00  0.230  0.00  0.075  0.00
row4  0.00  0.100  0.395  0.760  0.24  0.00  0.070  0.42  0.300  0.46
</code></pre>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html"" rel=""noreferrer""><code>pd.DataFrame.groupby</code></a></p>
<pre><code>df.groupby(['row', 'col'])['val0', 'val1'].mean().unstack(fill_value=0)
</code></pre>
</li>
</ul>
<hr />
<h3>Question 7</h3>
<blockquote>
<p>Can I subdivide by multiple columns?</p>
</blockquote>
<ul>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pivot_table.html"" rel=""noreferrer""><code>pd.DataFrame.pivot_table</code></a></p>
<pre><code>df.pivot_table(
    values='val0', index='row', columns=['item', 'col'],
    fill_value=0, aggfunc='mean')

item item0             item1                         item2
col   col2  col3  col4  col0  col1  col2  col3  col4  col0   col1  col3  col4
row
row0  0.00  0.00  0.00  0.77  0.00  0.00  0.00  0.00  0.00  0.605  0.86  0.65
row2  0.35  0.00  0.37  0.00  0.00  0.44  0.00  0.00  0.13  0.000  0.50  0.13
row3  0.00  0.00  0.00  0.00  0.31  0.00  0.81  0.00  0.00  0.000  0.28  0.00
row4  0.15  0.64  0.00  0.00  0.10  0.64  0.88  0.24  0.00  0.000  0.00  0.00
</code></pre>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html"" rel=""noreferrer""><code>pd.DataFrame.groupby</code></a></p>
<pre><code>df.groupby(
    ['row', 'item', 'col']
)['val0'].mean().unstack(['item', 'col']).fillna(0).sort_index(1)
</code></pre>
</li>
</ul>
<hr />
<h3>Question 8</h3>
<blockquote>
<p>Can I subdivide by multiple columns?</p>
</blockquote>
<ul>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pivot_table.html"" rel=""noreferrer""><code>pd.DataFrame.pivot_table</code></a></p>
<pre><code>df.pivot_table(
    values='val0', index=['key', 'row'], columns=['item', 'col'],
    fill_value=0, aggfunc='mean')

item      item0             item1                         item2
col        col2  col3  col4  col0  col1  col2  col3  col4  col0  col1  col3  col4
key  row
key0 row0  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.86  0.00
     row2  0.00  0.00  0.37  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.50  0.00
     row3  0.00  0.00  0.00  0.00  0.31  0.00  0.81  0.00  0.00  0.00  0.00  0.00
     row4  0.15  0.64  0.00  0.00  0.00  0.00  0.00  0.24  0.00  0.00  0.00  0.00
key1 row0  0.00  0.00  0.00  0.77  0.00  0.00  0.00  0.00  0.00  0.81  0.00  0.65
     row2  0.35  0.00  0.00  0.00  0.00  0.44  0.00  0.00  0.00  0.00  0.00  0.13
     row3  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.28  0.00
     row4  0.00  0.00  0.00  0.00  0.10  0.00  0.00  0.00  0.00  0.00  0.00  0.00
key2 row0  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.40  0.00  0.00
     row2  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.13  0.00  0.00  0.00
     row4  0.00  0.00  0.00  0.00  0.00  0.64  0.88  0.00  0.00  0.00  0.00  0.00
</code></pre>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html"" rel=""noreferrer""><code>pd.DataFrame.groupby</code></a></p>
<pre><code>df.groupby(
    ['key', 'row', 'item', 'col']
)['val0'].mean().unstack(['item', 'col']).fillna(0).sort_index(1)
</code></pre>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.set_index.html"" rel=""noreferrer""><code>pd.DataFrame.set_index</code></a> because the set of keys are unique for both rows and columns</p>
<pre><code>df.set_index(
    ['key', 'row', 'item', 'col']
)['val0'].unstack(['item', 'col']).fillna(0).sort_index(1)
</code></pre>
</li>
</ul>
<hr />
<h3>Question 9</h3>
<blockquote>
<p>Can I aggregate the frequency in which the column and rows occur together, aka &quot;cross tabulation&quot;?</p>
</blockquote>
<ul>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pivot_table.html"" rel=""noreferrer""><code>pd.DataFrame.pivot_table</code></a></p>
<pre><code>df.pivot_table(index='row', columns='col', fill_value=0, aggfunc='size')

col   col0  col1  col2  col3  col4
row
row0     1     2     0     1     1
row2     1     0     2     1     2
row3     0     1     0     2     0
row4     0     1     2     2     1
</code></pre>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html"" rel=""noreferrer""><code>pd.DataFrame.groupby</code></a></p>
<pre><code>df.groupby(['row', 'col'])['val0'].size().unstack(fill_value=0)
</code></pre>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.crosstab.html"" rel=""noreferrer""><code>pd.crosstab</code></a></p>
<pre><code>pd.crosstab(df['row'], df['col'])
</code></pre>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.factorize.html"" rel=""noreferrer""><code>pd.factorize</code></a> + <a href=""https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.bincount.html"" rel=""noreferrer""><code>np.bincount</code></a></p>
<pre><code># get integer factorization `i` and unique values `r`
# for column `'row'`
i, r = pd.factorize(df['row'].values)
# get integer factorization `j` and unique values `c`
# for column `'col'`
j, c = pd.factorize(df['col'].values)
# `n` will be the number of rows
# `m` will be the number of columns
n, m = r.size, c.size
# `i * m + j` is a clever way of counting the
# factorization bins assuming a flat array of length
# `n * m`.  Which is why we subsequently reshape as `(n, m)`
b = np.bincount(i * m + j, minlength=n * m).reshape(n, m)
# BTW, whenever I read this, I think 'Bean, Rice, and Cheese'
pd.DataFrame(b, r, c)

      col3  col2  col0  col1  col4
row3     2     0     0     1     0
row2     1     2     1     0     2
row0     1     0     1     2     1
row4     2     2     0     1     1
</code></pre>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.get_dummies.html"" rel=""noreferrer""><code>pd.get_dummies</code></a></p>
<pre><code>pd.get_dummies(df['row']).T.dot(pd.get_dummies(df['col']))

      col0  col1  col2  col3  col4
row0     1     2     0     1     1
row2     1     0     2     1     2
row3     0     1     0     2     0
row4     0     1     2     2     1
</code></pre>
</li>
</ul>
<hr />
<h3>Question 10</h3>
<blockquote>
<p>How do I convert a DataFrame from long to wide by pivoting on ONLY two
columns?</p>
</blockquote>
<ul>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pivot.html"" rel=""noreferrer""><code>DataFrame.pivot</code></a></p>
<p>The first step is to assign a number to each row - this number will be the row index of that value in the pivoted result. This is done using <a href=""https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.core.groupby.GroupBy.cumcount.html"" rel=""noreferrer""><code>GroupBy.cumcount</code></a>:</p>
<pre><code>df2.insert(0, 'count', df2.groupby('A').cumcount())
df2

   count  A   B
0      0  a   0
1      1  a  11
2      2  a   2
3      3  a  11
4      0  b  10
5      1  b  10
6      2  b  14
7      0  c   7
</code></pre>
<p>The second step is to use the newly created column as the index to call <a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pivot.html"" rel=""noreferrer""><code>DataFrame.pivot</code></a>.</p>
<pre><code>df2.pivot(*df2)
# df2.pivot(index='count', columns='A', values='B')

A         a     b    c
count
0       0.0  10.0  7.0
1      11.0  10.0  NaN
2       2.0  14.0  NaN
3      11.0   NaN  NaN
</code></pre>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pivot_table.html"" rel=""noreferrer""><code>DataFrame.pivot_table</code></a></p>
<p>Whereas <a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pivot.html"" rel=""noreferrer""><code>DataFrame.pivot</code></a> only accepts columns, <a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pivot_table.html"" rel=""noreferrer""><code>DataFrame.pivot_table</code></a> also accepts arrays, so the <code>GroupBy.cumcount</code> can be passed directly as the <code>index</code> without creating an explicit column.</p>
<pre><code>df2.pivot_table(index=df2.groupby('A').cumcount(), columns='A', values='B')

A         a     b    c
0       0.0  10.0  7.0
1      11.0  10.0  NaN
2       2.0  14.0  NaN
3      11.0   NaN  NaN
</code></pre>
</li>
</ul>
<hr />
<h3>Question 11</h3>
<blockquote>
<p>How do I flatten the multiple index to single index after <code>pivot</code></p>
</blockquote>
<p>If <code>columns</code> type <code>object</code> with string <code>join</code></p>
<pre><code>df.columns = df.columns.map('|'.join)
</code></pre>
<p>else <code>format</code></p>
<pre><code>df.columns = df.columns.map('{0[0]}|{0[1]}'.format)
</code></pre>
"
1145781,"<p>Actually, this is not a design flaw, and it is not because of internals or performance. It comes simply from the fact that functions in Python are first-class objects, and not only a piece of code.</p>
<p>As soon as you think of it this way, then it completely makes sense: a function is an object being evaluated on its definition; default parameters are kind of &quot;member data&quot; and therefore their state may change from one call to the other - exactly as in any other object.</p>
<p>In any case, the effbot (Fredrik Lundh) has a very nice explanation of the reasons for this behavior in <a href=""https://web.archive.org/web/20200221224620id_/http://effbot.org/zone/default-values.htm"" rel=""noreferrer"">Default Parameter Values in Python</a>.
I found it very clear, and I really suggest reading it for a better knowledge of how function objects work.</p>
"
53645883,"<p>This post aims to give readers a primer on SQL-flavored merging with Pandas, how to use it, and when not to use it.</p>
<p>In particular, here's what this post will go through:</p>
<ul>
<li><p>The basics - types of joins (LEFT, RIGHT, OUTER, INNER)</p>
<ul>
<li>merging with different column names</li>
<li>merging with multiple columns</li>
<li>avoiding duplicate merge key column in output</li>
</ul>
</li>
</ul>
<p>What this post (and other posts by me on this thread) will not go through:</p>
<ul>
<li>Performance-related discussions and timings (for now). Mostly notable mentions of better alternatives, wherever appropriate.</li>
<li>Handling suffixes, removing extra columns, renaming outputs, and other specific use cases. There are other (read: better) posts that deal with that, so figure it out!</li>
</ul>
<blockquote>
<p><strong>Note</strong>
Most examples default to INNER JOIN operations while demonstrating various features, unless otherwise specified.</p>
<p>Furthermore, all the DataFrames here can be copied and replicated so
you can play with them. Also, see <a href=""https://stackoverflow.com/questions/31610889/how-to-copy-paste-dataframe-from-stackoverflow-into-python"">this
post</a>
on how to read DataFrames from your clipboard.</p>
<p>Lastly, all visual representation of JOIN operations have been hand-drawn using Google Drawings. Inspiration from <a href=""https://stackoverflow.com/a/55858991/4909087"">here</a>.</p>
</blockquote>
<hr />
<hr />
<h1>Enough talk - just show me how to use <code>merge</code>!</h1>
<h3>Setup &amp; Basics</h3>
<pre><code>np.random.seed(0)
left = pd.DataFrame({'key': ['A', 'B', 'C', 'D'], 'value': np.random.randn(4)})
right = pd.DataFrame({'key': ['B', 'D', 'E', 'F'], 'value': np.random.randn(4)})

left

  key     value
0   A  1.764052
1   B  0.400157
2   C  0.978738
3   D  2.240893

right

  key     value
0   B  1.867558
1   D -0.977278
2   E  0.950088
3   F -0.151357
</code></pre>
<p>For the sake of simplicity, the key column has the same name (for now).</p>
<p>An <strong>INNER JOIN</strong> is represented by</p>
<img src=""https://i.stack.imgur.com/YvuOa.png"" width=""500""/>
<blockquote>
<p><strong>Note</strong>
This, along with the forthcoming figures all follow this convention:</p>
<ul>
<li><strong>blue</strong> indicates rows that are present in the merge result</li>
<li><strong>red</strong> indicates rows that are excluded from the result (i.e., removed)</li>
<li><strong>green</strong> indicates missing values that are replaced with <code>NaN</code>s in the result</li>
</ul>
</blockquote>
<p>To perform an INNER JOIN, call <a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.merge.html"" rel=""noreferrer""><code>merge</code></a> on the left DataFrame, specifying the right DataFrame and the join key (at the very least) as arguments.</p>
<pre><code>left.merge(right, on='key')
# Or, if you want to be explicit
# left.merge(right, on='key', how='inner')

  key   value_x   value_y
0   B  0.400157  1.867558
1   D  2.240893 -0.977278
</code></pre>
<p>This returns only rows from <code>left</code> and <code>right</code> which share a common key (in this example, &quot;B&quot; and &quot;D).</p>
<p>A <strong>LEFT OUTER JOIN</strong>, or LEFT JOIN  is represented by</p>
<img src=""https://i.stack.imgur.com/BECid.png"" width=""500"" />
<p>This can be performed by specifying <code>how='left'</code>.</p>
<pre><code>left.merge(right, on='key', how='left')

  key   value_x   value_y
0   A  1.764052       NaN
1   B  0.400157  1.867558
2   C  0.978738       NaN
3   D  2.240893 -0.977278
</code></pre>
<p>Carefully note the placement of NaNs here. If you specify <code>how='left'</code>, then only keys from <code>left</code> are used, and missing data from <code>right</code> is replaced by NaN.</p>
<p>And similarly, for a <strong>RIGHT OUTER JOIN</strong>, or RIGHT JOIN which is...</p>
<img src=""https://i.stack.imgur.com/8w1US.png"" width=""500"" />
<p>...specify <code>how='right'</code>:</p>
<pre><code>left.merge(right, on='key', how='right')

  key   value_x   value_y
0   B  0.400157  1.867558
1   D  2.240893 -0.977278
2   E       NaN  0.950088
3   F       NaN -0.151357
</code></pre>
<p>Here, keys from <code>right</code> are used, and missing data from <code>left</code> is replaced by NaN.</p>
<p>Finally, for the <strong>FULL OUTER JOIN</strong>, given by</p>
<img src=""https://i.stack.imgur.com/euLoe.png"" width=""500"" />
<p>specify <code>how='outer'</code>.</p>
<pre><code>left.merge(right, on='key', how='outer')

  key   value_x   value_y
0   A  1.764052       NaN
1   B  0.400157  1.867558
2   C  0.978738       NaN
3   D  2.240893 -0.977278
4   E       NaN  0.950088
5   F       NaN -0.151357
</code></pre>
<p>This uses the keys from both frames, and NaNs are inserted for missing rows in both.</p>
<p>The documentation summarizes these various merges nicely:</p>
<p><a href=""https://i.stack.imgur.com/5qDIy.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/5qDIy.png"" alt=""Enter image description here"" /></a></p>
<hr />
<h3><strong>Other JOINs - LEFT-Excluding, RIGHT-Excluding, and FULL-Excluding/ANTI JOINs</strong></h3>
<p>If you need <strong>LEFT-Excluding JOINs</strong> and <strong>RIGHT-Excluding JOINs</strong> in two steps.</p>
<p>For LEFT-Excluding JOIN, represented as</p>
<img src=""https://i.stack.imgur.com/bXWIV.png"" width=""500""/>
<p>Start by performing a LEFT OUTER JOIN and then filtering to rows coming from <code>left</code> only (excluding everything from the right),</p>
<pre><code>(left.merge(right, on='key', how='left', indicator=True)
     .query('_merge == &quot;left_only&quot;')
     .drop('_merge', 1))

  key   value_x  value_y
0   A  1.764052      NaN
2   C  0.978738      NaN
</code></pre>
<p>Where,</p>
<pre><code>left.merge(right, on='key', how='left', <b>indicator=True</b>)

  key   value_x   value_y     _merge
0   A  1.764052       NaN  left_only
1   B  0.400157  1.867558       both
2   C  0.978738       NaN  left_only
3   D  2.240893 -0.977278       both</code></pre>
<p>And similarly, for a RIGHT-Excluding JOIN,</p>
<img src=""https://i.stack.imgur.com/Z0br2.png"" width=""500""/>
<pre><code>(left.merge(right, on='key', how='right', <b>indicator=True</b>)
     .query('_merge == ""right_only""')
     .drop('_merge', 1))

  key  value_x   value_y
2   E      NaN  0.950088
3   F      NaN -0.151357</code></pre>
<p>Lastly, if you are required to do a merge that only retains keys from the left or right, but not both (IOW, performing an <strong>ANTI-JOIN</strong>),</p>
<img src=""https://i.stack.imgur.com/PWMYd.png"" width=""500""/>
<p>You can do this in similar fashionâ</p>
<pre><code>(left.merge(right, on='key', how='outer', indicator=True)
     .query('_merge != &quot;both&quot;')
     .drop('_merge', 1))

  key   value_x   value_y
0   A  1.764052       NaN
2   C  0.978738       NaN
4   E       NaN  0.950088
5   F       NaN -0.151357
</code></pre>
<hr />
<h3><strong>Different names for key columns</strong></h3>
<p>If the key columns are named differentlyâfor example, <code>left</code> has <code>keyLeft</code>, and <code>right</code> has <code>keyRight</code> instead of <code>key</code>âthen you will have to specify <code>left_on</code> and <code>right_on</code> as arguments instead of <code>on</code>:</p>
<pre><code>left2 = left.rename({'key':'keyLeft'}, axis=1)
right2 = right.rename({'key':'keyRight'}, axis=1)

left2

  keyLeft     value
0       A  1.764052
1       B  0.400157
2       C  0.978738
3       D  2.240893

right2

  keyRight     value
0        B  1.867558
1        D -0.977278
2        E  0.950088
3        F -0.151357
</code></pre>

<pre><code>left2.merge(right2, left_on='keyLeft', right_on='keyRight', how='inner')

  keyLeft   value_x keyRight   value_y
0       B  0.400157        B  1.867558
1       D  2.240893        D -0.977278
</code></pre>
<hr />
<h3><strong>Avoiding duplicate key column in output</strong></h3>
<p>When merging on <code>keyLeft</code> from <code>left</code> and <code>keyRight</code> from <code>right</code>, if you only want either of the <code>keyLeft</code> or <code>keyRight</code> (but not both) in the output, you can start by setting the index as a preliminary step.</p>
<pre><code>left3 = left2.set_index('keyLeft')
left3.merge(right2, left_index=True, right_on='keyRight')

    value_x keyRight   value_y
0  0.400157        B  1.867558
1  2.240893        D -0.977278
</code></pre>
<p>Contrast this with the output of the command just before (that is, the output of <code>left2.merge(right2, left_on='keyLeft', right_on='keyRight', how='inner')</code>), you'll notice <code>keyLeft</code> is missing. You can figure out what column to keep based on which frame's index is set as the key. This may matter when, say, performing some OUTER JOIN operation.</p>
<hr />
<h3><strong>Merging only a single column from one of the <code>DataFrames</code></strong></h3>
<p>For example, consider</p>
<pre><code>right3 = right.assign(newcol=np.arange(len(right)))
right3
  key     value  newcol
0   B  1.867558       0
1   D -0.977278       1
2   E  0.950088       2
3   F -0.151357       3
</code></pre>
<p>If you are required to merge only &quot;newcol&quot; (without any of the other columns), you can usually just subset columns before merging:</p>
<pre><code>left.merge(right3[['key', 'newcol']], on='key')

  key     value  newcol
0   B  0.400157       0
1   D  2.240893       1
</code></pre>
<p>If you're doing a LEFT OUTER JOIN, a more performant solution would involve <code>map</code>:</p>
<pre><code># left['newcol'] = left['key'].map(right3.set_index('key')['newcol']))
left.assign(newcol=left['key'].map(right3.set_index('key')['newcol']))

  key     value  newcol
0   A  1.764052     NaN
1   B  0.400157     0.0
2   C  0.978738     NaN
3   D  2.240893     1.0
</code></pre>
<p>As mentioned, this is similar to, but faster than</p>
<pre><code>left.merge(right3[['key', 'newcol']], on='key', how='left')

  key     value  newcol
0   A  1.764052     NaN
1   B  0.400157     0.0
2   C  0.978738     NaN
3   D  2.240893     1.0
</code></pre>
<hr />
<h3><strong>Merging on multiple columns</strong></h3>
<p>To join on more than one column, specify a list for <code>on</code> (or <code>left_on</code> and <code>right_on</code>, as appropriate).</p>
<pre><code>left.merge(right, on=['key1', 'key2'] ...)
</code></pre>
<p>Or, in the event the names are different,</p>
<pre><code>left.merge(right, left_on=['lkey1', 'lkey2'], right_on=['rkey1', 'rkey2'])
</code></pre>
<hr />
<h3><strong>Other useful <code>merge*</code> operations and functions</strong></h3>
<ul>
<li><p>Merging a DataFrame with Series on index: See <a href=""https://stackoverflow.com/a/40762674/4909087"">this answer</a>.</p>
</li>
<li><p>Besides <code>merge</code>, <a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.update.html"" rel=""noreferrer""><code>DataFrame.update</code></a> and <a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.combine_first.html"" rel=""noreferrer""><code>DataFrame.combine_first</code></a> are also used in certain cases to update one DataFrame with another.</p>
</li>
<li><p><a href=""http://pandas.pydata.org/pandas-docs/version/0.19.0/generated/pandas.merge_ordered.html"" rel=""noreferrer""><code>pd.merge_ordered</code></a> is a useful function for ordered JOINs.</p>
</li>
<li><p><a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.merge_asof.html"" rel=""noreferrer""><code>pd.merge_asof</code></a> (read: merge_asOf) is useful for <em>approximate</em> joins.</p>
</li>
</ul>
<p><strong>This section only covers the very basics, and is designed to only whet your appetite. For more examples and cases, see the <a href=""https://pandas.pydata.org/pandas-docs/stable/merging.html"" rel=""noreferrer"">documentation on <code>merge</code>, <code>join</code>, and <code>concat</code></a> as well as the links to the function specifications.</strong></p>
<hr />
<hr />
<h1>Continue Reading</h1>
<p>Jump to other topics in Pandas Merging 101 to continue learning:</p>
<ul>
<li><p><a href=""https://stackoverflow.com/a/53645883/4909087"">Merging basics - basic types of joins</a> <sup>*</sup></p>
</li>
<li><p><a href=""https://stackoverflow.com/a/65167356/4909087"">Index-based joins</a></p>
</li>
<li><p><a href=""https://stackoverflow.com/a/65167327/4909087"">Generalizing to multiple DataFrames</a></p>
</li>
<li><p><a href=""https://stackoverflow.com/a/53699013/4909087"">Cross join</a></p>
</li>
</ul>
<p><sub>*You are here.</sub></p>
"
2612815,"<p><code>new_list = my_list</code> doesn't actually create a second list. The assignment just copies the reference to the list, not the actual list, so both <code>new_list</code> and <code>my_list</code> refer to the same list after the assignment.</p>
<p>To actually copy the list, you have several options:</p>
<ul>
<li><p>You can use the built-in <a href=""https://docs.python.org/library/stdtypes.html#mutable-sequence-types"" rel=""noreferrer""><code>list.copy()</code></a> method (available since Python 3.3):</p>
<pre><code>new_list = old_list.copy()
</code></pre>
</li>
<li><p>You can slice it:</p>
<pre><code>new_list = old_list[:]
</code></pre>
<p><a href=""https://en.wikipedia.org/wiki/Alex_Martelli"" rel=""noreferrer"">Alex Martelli</a>'s opinion (at least <a href=""https://www.youtube.com/watch?v=g7V89K8QfgQ"" rel=""noreferrer"">back in 2007</a>) about this is, that <em>it is a weird syntax and it does not make sense to use it ever</em>. ;) (In his opinion, the next one is more readable).</p>
</li>
<li><p>You can use the built-in <a href=""https://docs.python.org/library/stdtypes.html#list"" rel=""noreferrer""><code>list()</code></a> constructor:</p>
<pre><code>new_list = list(old_list)
</code></pre>
</li>
<li><p>You can use generic <a href=""https://docs.python.org/library/copy.html#copy.copy"" rel=""noreferrer""><code>copy.copy()</code></a>:</p>
<pre><code>import copy
new_list = copy.copy(old_list)
</code></pre>
<p>This is a little slower than <code>list()</code> because it has to find out the datatype of <code>old_list</code> first.</p>
</li>
<li><p>If you need to copy the elements of the list as well, use generic <a href=""https://docs.python.org/library/copy.html#copy.deepcopy"" rel=""noreferrer""><code>copy.deepcopy()</code></a>:</p>
<pre><code>import copy
new_list = copy.deepcopy(old_list)
</code></pre>
<p>Obviously the slowest and most memory-needing method, but sometimes unavoidable. This operates recursively; it will handle any number of levels of nested lists (or other containers).</p>
</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code>import copy

class Foo(object):
    def __init__(self, val):
         self.val = val

    def __repr__(self):
        return f'Foo({self.val!r})'

foo = Foo(1)

a = ['foo', foo]
b = a.copy()
c = a[:]
d = list(a)
e = copy.copy(a)
f = copy.deepcopy(a)

# edit orignal list and instance 
a.append('baz')
foo.val = 5

print(f'original: {a}\nlist.copy(): {b}\nslice: {c}\nlist(): {d}\ncopy: {e}\ndeepcopy: {f}')
</code></pre>
<p>Result:</p>
<pre><code>original: ['foo', Foo(5), 'baz']
list.copy(): ['foo', Foo(5)]
slice: ['foo', Foo(5)]
list(): ['foo', Foo(5)]
copy: ['foo', Foo(5)]
deepcopy: ['foo', Foo(1)]
</code></pre>
"
20449433,"<h3>Solution</h3>
<p>Since Python 3, <code>input</code> returns a string which you have to explicitly convert to <code>int</code>s, with <a href=""https://docs.python.org/3/library/functions.html#int"" rel=""noreferrer""><code>int</code></a>, like this</p>
<pre><code>x = int(input(&quot;Enter a number: &quot;))
y = int(input(&quot;Enter a number: &quot;))
</code></pre>
<p>You can accept numbers of any base and convert them directly to base-10 with the <code>int</code> function, like this</p>
<pre><code>&gt;&gt;&gt; data = int(input(&quot;Enter a number: &quot;), 8)
Enter a number: 777
&gt;&gt;&gt; data
511
&gt;&gt;&gt; data = int(input(&quot;Enter a number: &quot;), 16)
Enter a number: FFFF
&gt;&gt;&gt; data
65535
&gt;&gt;&gt; data = int(input(&quot;Enter a number: &quot;), 2)
Enter a number: 10101010101
&gt;&gt;&gt; data
1365
</code></pre>
<p>The second parameter tells what is the base of the numbers entered and then internally it understands and converts it. If the entered data is wrong it will throw a <code>ValueError</code>.</p>
<pre class=""lang-none prettyprint-override""><code>&gt;&gt;&gt; data = int(input(&quot;Enter a number: &quot;), 2)
Enter a number: 1234
Traceback (most recent call last):
  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;
ValueError: invalid literal for int() with base 2: '1234'
</code></pre>
<p>For values that can have a fractional component, the type would be <code>float</code> rather than <code>int</code>:</p>
<pre><code>x = float(input(&quot;Enter a number:&quot;))
</code></pre>
<h3>Differences between Python 2 and 3</h3>
<p><strong>Summary</strong></p>
<ul>
<li>Python 2's <code>input</code> function evaluated the received data, converting it to an integer implicitly (read the next section to understand the implication), but Python 3's <code>input</code> function does not do that anymore.</li>
<li>Python 2's equivalent of Python 3's <code>input</code> is the <code>raw_input</code> function.</li>
</ul>
<p><strong>Python 2.x</strong></p>
<p>There were two functions to get user input, called <a href=""https://docs.python.org/2/library/functions.html#input"" rel=""noreferrer""><code>input</code></a> and <a href=""https://docs.python.org/2/library/functions.html#raw_input"" rel=""noreferrer""><code>raw_input</code></a>. The difference between them is, <code>raw_input</code> doesn't evaluate the data and returns as it is, in string form. But, <code>input</code> will evaluate whatever you entered and the result of evaluation will be returned. For example,</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.version
'2.7.6 (default, Mar 22 2014, 22:59:56) \n[GCC 4.8.2]'
&gt;&gt;&gt; data = input(&quot;Enter a number: &quot;)
Enter a number: 5 + 17
&gt;&gt;&gt; data, type(data)
(22, &lt;type 'int'&gt;)
</code></pre>
<p>The data <code>5 + 17</code> is evaluated and the result is <code>22</code>. When it evaluates the expression <code>5 + 17</code>, it detects that you are adding two numbers and so the result will also be of the same <code>int</code> type. So, the type conversion is done for free and <code>22</code> is returned as the result of <code>input</code> and stored in <code>data</code> variable. You can think of <code>input</code> as the <code>raw_input</code> composed with an <a href=""https://docs.python.org/2/library/functions.html#eval"" rel=""noreferrer""><code>eval</code></a> call.</p>
<pre><code>&gt;&gt;&gt; data = eval(raw_input(&quot;Enter a number: &quot;))
Enter a number: 5 + 17
&gt;&gt;&gt; data, type(data)
(22, &lt;type 'int'&gt;)
</code></pre>
<p><strong>Note:</strong> you should be careful when you are using <code>input</code> in Python 2.x. I explained why one should be careful when using it, in <a href=""https://stackoverflow.com/a/21122817/1903116"">this answer</a>.</p>
<p>But, <code>raw_input</code> doesn't evaluate the input and returns as it is, as a string.</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.version
'2.7.6 (default, Mar 22 2014, 22:59:56) \n[GCC 4.8.2]'
&gt;&gt;&gt; data = raw_input(&quot;Enter a number: &quot;)
Enter a number: 5 + 17
&gt;&gt;&gt; data, type(data)
('5 + 17', &lt;type 'str'&gt;)
</code></pre>
<p><strong>Python 3.x</strong></p>
<p>Python 3.x's <a href=""https://docs.python.org/3/library/functions.html#input"" rel=""noreferrer""><code>input</code></a> and Python 2.x's <code>raw_input</code> are similar and <code>raw_input</code> is not available in Python 3.x.</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.version
'3.4.0 (default, Apr 11 2014, 13:05:11) \n[GCC 4.8.2]'
&gt;&gt;&gt; data = input(&quot;Enter a number: &quot;)
Enter a number: 5 + 17
&gt;&gt;&gt; data, type(data)
('5 + 17', &lt;class 'str'&gt;)
</code></pre>
"
1207461,"<p>You can use a <a href=""https://en.wikipedia.org/wiki/List_comprehension#Python"" rel=""noreferrer"">list comprehension</a> to create a new list containing only the elements you don't want to remove:</p>
<pre><code>somelist = [x for x in somelist if not determine(x)]
</code></pre>
<p>Or, by assigning to the slice <code>somelist[:]</code>, you can mutate the existing list to contain only the items you want:</p>
<pre><code>somelist[:] = [x for x in somelist if not determine(x)]
</code></pre>
<p>This approach could be useful if there are other references to <code>somelist</code> that need to reflect the changes.</p>
<p>Instead of a comprehension, you could also use <code>itertools</code>. In Python 2:</p>
<pre><code>from itertools import ifilterfalse
somelist[:] = ifilterfalse(determine, somelist)
</code></pre>
<p>Or in Python 3:</p>
<pre><code>from itertools import filterfalse
somelist[:] = filterfalse(determine, somelist)
</code></pre>
"
952952,"<p>Given a list of lists <code>l</code>,</p>
<pre><code>flat_list = [item for sublist in l for item in sublist]
</code></pre>
<p>which means:</p>
<pre><code>flat_list = []
for sublist in l:
    for item in sublist:
        flat_list.append(item)
</code></pre>
<p>is faster than the shortcuts posted so far. (<code>l</code> is the list to flatten.)</p>
<p>Here is the corresponding function:</p>
<pre><code>def flatten(l):
    return [item for sublist in l for item in sublist]
</code></pre>
<p>As evidence, you can use the <code>timeit</code> module in the standard library:</p>
<pre><code>$ python -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99' '[item for sublist in l for item in sublist]'
10000 loops, best of 3: 143 usec per loop
$ python -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99' 'sum(l, [])'
1000 loops, best of 3: 969 usec per loop
$ python -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99' 'reduce(lambda x,y: x+y,l)'
1000 loops, best of 3: 1.1 msec per loop
</code></pre>
<p>Explanation: the shortcuts based on <code>+</code> (including the implied use in <code>sum</code>) are, of necessity, <code>O(L**2)</code> when there are L sublists -- as the intermediate result list keeps getting longer, at each step a new intermediate result list object gets allocated, and all the items in the previous intermediate result must be copied over (as well as a few new ones added at the end). So, for simplicity and without actual loss of generality, say you have L sublists of I items each: the first I items are copied back and forth L-1 times, the second I items L-2 times, and so on; total number of copies is I times the sum of x for x from 1 to L excluded, i.e., <code>I * (L**2)/2</code>.</p>
<p>The list comprehension just generates one list, once, and copies each item over (from its original place of residence to the result list) also exactly once.</p>
"
312464,"<p>Here's a generator that yields evenly-sized chunks:</p>
<pre><code>def chunks(lst, n):
    &quot;&quot;&quot;Yield successive n-sized chunks from lst.&quot;&quot;&quot;
    for i in range(0, len(lst), n):
        yield lst[i:i + n]
</code></pre>
<pre><code>import pprint
pprint.pprint(list(chunks(range(10, 75), 10)))
[[10, 11, 12, 13, 14, 15, 16, 17, 18, 19],
 [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
 [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],
 [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],
 [50, 51, 52, 53, 54, 55, 56, 57, 58, 59],
 [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],
 [70, 71, 72, 73, 74]]
</code></pre>
<p>For Python 2, using <code>xrange</code> instead of <code>range</code>:</p>
<pre><code>def chunks(lst, n):
    &quot;&quot;&quot;Yield successive n-sized chunks from lst.&quot;&quot;&quot;
    for i in xrange(0, len(lst), n):
        yield lst[i:i + n]
</code></pre>
<hr />
<p>Below is a list comprehension one-liner. The method above is preferable, though, since using named functions makes code easier to understand. For Python 3:</p>
<pre><code>[lst[i:i + n] for i in range(0, len(lst), n)]
</code></pre>
<p>For Python 2:</p>
<pre><code>[lst[i:i + n] for i in xrange(0, len(lst), n)]
</code></pre>
"
,
20002504,"<p>In many cases, Python looks and behaves like natural English, but this is one case where that abstraction fails. People can use context clues to determine that &quot;Jon&quot; and &quot;Inbar&quot; are objects joined to the verb &quot;equals&quot;, but the Python interpreter is more literal minded.</p>
<pre><code>if name == &quot;Kevin&quot; or &quot;Jon&quot; or &quot;Inbar&quot;:
</code></pre>
<p>is logically equivalent to:</p>
<pre><code>if (name == &quot;Kevin&quot;) or (&quot;Jon&quot;) or (&quot;Inbar&quot;):
</code></pre>
<p>Which, for user Bob, is equivalent to:</p>
<pre><code>if (False) or (&quot;Jon&quot;) or (&quot;Inbar&quot;):
</code></pre>
<p>The <code>or</code> operator <a href=""https://stackoverflow.com/questions/47007680"">chooses the first operand</a> that is <a href=""https://stackoverflow.com/questions/39983695"">&quot;truthy&quot;</a>, i.e. which <a href=""http://docs.python.org/3/library/stdtypes.html#truth-value-testing"" rel=""noreferrer"">would satisfy an <code>if</code> condition</a> (or the last one, if none of them are &quot;truthy&quot;):</p>
<pre><code>if &quot;Jon&quot;:
</code></pre>
<p>Since &quot;Jon&quot; is truthy, the <code>if</code> block executes. That is what causes &quot;Access granted&quot; to be printed regardless of the name given.</p>
<p>All of this reasoning also applies to the expression <code>if &quot;Kevin&quot; or &quot;Jon&quot; or &quot;Inbar&quot; == name</code>. the first value, <code>&quot;Kevin&quot;</code>, is true, so the <code>if</code> block executes.</p>
<hr />
<p>There are two common ways to properly construct this conditional.</p>
<ol>
<li><p>Use multiple <code>==</code> operators to explicitly check against each value:</p>
<pre><code>if name == &quot;Kevin&quot; or name == &quot;Jon&quot; or name == &quot;Inbar&quot;:
</code></pre>
</li>
<li><p>Compose a collection of valid values (a set, a list or a tuple for example), and use the <code>in</code> operator to test for membership:</p>
<pre><code>if name in {&quot;Kevin&quot;, &quot;Jon&quot;, &quot;Inbar&quot;}:
</code></pre>
</li>
</ol>
<p>In general of the two the second should be preferred as it's easier to read and also faster:</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; timeit.timeit('name == &quot;Kevin&quot; or name == &quot;Jon&quot; or name == &quot;Inbar&quot;',
    setup=&quot;name='Inbar'&quot;)
0.4247764749999945
&gt;&gt;&gt; timeit.timeit('name in {&quot;Kevin&quot;, &quot;Jon&quot;, &quot;Inbar&quot;}', setup=&quot;name='Inbar'&quot;)
0.18493307199999265
</code></pre>
<hr />
<p>For those who may want proof that <code>if a == b or c or d or e: ...</code> is indeed parsed like this. The built-in <code>ast</code> module provides an answer:</p>
<pre><code>&gt;&gt;&gt; import ast
&gt;&gt;&gt; ast.parse(&quot;a == b or c or d or e&quot;, &quot;&lt;string&gt;&quot;, &quot;eval&quot;)
&lt;ast.Expression object at 0x7f929c898220&gt;
&gt;&gt;&gt; print(ast.dump(_, indent=4))
Expression(
    body=BoolOp(
        op=Or(),
        values=[
            Compare(
                left=Name(id='a', ctx=Load()),
                ops=[
                    Eq()],
                comparators=[
                    Name(id='b', ctx=Load())]),
            Name(id='c', ctx=Load()),
            Name(id='d', ctx=Load()),
            Name(id='e', ctx=Load())]))
</code></pre>
<p>As one can see, it's the boolean operator <code>or</code> applied to four sub-expressions: comparison <code>a == b</code>; and simple expressions <code>c</code>, <code>d</code>, and <code>e</code>.</p>
"
986145,"<p>Arguments are <a href=""http://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference"" rel=""noreferrer"">passed by assignment</a>. The rationale behind this is twofold:</p>

<ol>
<li>the parameter passed in is actually a <em>reference</em> to an object (but the reference is passed by value)</li>
<li>some data types are mutable, but others aren't</li>
</ol>

<p>So:</p>

<ul>
<li><p>If you pass a <em>mutable</em> object into a method, the method gets a reference to that same object and you can mutate it to your heart's delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you're done, the outer reference will still point at the original object. </p></li>
<li><p>If you pass an <em>immutable</em> object to a method, you still can't rebind the outer reference, and you can't even mutate the object.</p></li>
</ul>

<p>To make it even more clear, let's have some examples. </p>

<h2>List - a mutable type</h2>

<p><strong>Let's try to modify the list that was passed to a method:</strong></p>

<pre><code>def try_to_change_list_contents(the_list):
    print('got', the_list)
    the_list.append('four')
    print('changed to', the_list)

outer_list = ['one', 'two', 'three']

print('before, outer_list =', outer_list)
try_to_change_list_contents(outer_list)
print('after, outer_list =', outer_list)
</code></pre>

<p>Output:</p>

<pre class=""lang-none prettyprint-override""><code>before, outer_list = ['one', 'two', 'three']
got ['one', 'two', 'three']
changed to ['one', 'two', 'three', 'four']
after, outer_list = ['one', 'two', 'three', 'four']
</code></pre>

<p>Since the parameter passed in is a reference to <code>outer_list</code>, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope.</p>

<p><strong>Now let's see what happens when we try to change the reference that was passed in as a parameter:</strong></p>

<pre><code>def try_to_change_list_reference(the_list):
    print('got', the_list)
    the_list = ['and', 'we', 'can', 'not', 'lie']
    print('set to', the_list)

outer_list = ['we', 'like', 'proper', 'English']

print('before, outer_list =', outer_list)
try_to_change_list_reference(outer_list)
print('after, outer_list =', outer_list)
</code></pre>

<p>Output:</p>

<pre class=""lang-none prettyprint-override""><code>before, outer_list = ['we', 'like', 'proper', 'English']
got ['we', 'like', 'proper', 'English']
set to ['and', 'we', 'can', 'not', 'lie']
after, outer_list = ['we', 'like', 'proper', 'English']
</code></pre>

<p>Since the <code>the_list</code> parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see. The <code>the_list</code> was a copy of the <code>outer_list</code> reference, and we had <code>the_list</code> point to a new list, but there was no way to change where <code>outer_list</code> pointed.</p>

<h2>String - an immutable type</h2>

<p><strong>It's immutable, so there's nothing we can do to change the contents of the string</strong></p>

<p><strong>Now, let's try to change the reference</strong></p>

<pre><code>def try_to_change_string_reference(the_string):
    print('got', the_string)
    the_string = 'In a kingdom by the sea'
    print('set to', the_string)

outer_string = 'It was many and many a year ago'

print('before, outer_string =', outer_string)
try_to_change_string_reference(outer_string)
print('after, outer_string =', outer_string)
</code></pre>

<p>Output:</p>

<pre class=""lang-none prettyprint-override""><code>before, outer_string = It was many and many a year ago
got It was many and many a year ago
set to In a kingdom by the sea
after, outer_string = It was many and many a year ago
</code></pre>

<p>Again, since the <code>the_string</code> parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see. The <code>the_string</code> was a copy of the <code>outer_string</code> reference, and we had <code>the_string</code> point to a new string, but there was no way to change where <code>outer_string</code> pointed.</p>

<p>I hope this clears things up a little.</p>

<p><strong>EDIT:</strong> It's been noted that this doesn't answer the question that @David originally asked, ""Is there something I can do to pass the variable by actual reference?"". Let's work on that.</p>

<h2>How do we get around this?</h2>

<p>As @Andrea's answer shows, you could return the new value. This doesn't change the way things are passed in, but does let you get the information you want back out:</p>

<pre><code>def return_a_whole_new_string(the_string):
    new_string = something_to_do_with_the_old_string(the_string)
    return new_string

# then you could call it like
my_string = return_a_whole_new_string(my_string)
</code></pre>

<p>If you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list:</p>

<pre><code>def use_a_wrapper_to_simulate_pass_by_reference(stuff_to_change):
    new_string = something_to_do_with_the_old_string(stuff_to_change[0])
    stuff_to_change[0] = new_string

# then you could call it like
wrapper = [my_string]
use_a_wrapper_to_simulate_pass_by_reference(wrapper)

do_something_with(wrapper[0])
</code></pre>

<p>Although this seems a little cumbersome.</p>
"
423596,"<p>You can use a global variable within other functions by declaring it as <code>global</code> <strong>within each function that assigns a value to it</strong>:</p>
<pre><code>globvar = 0

def set_globvar_to_one():
    global globvar    # Needed to modify global copy of globvar
    globvar = 1

def print_globvar():
    print(globvar)     # No need for global declaration to read value of globvar

set_globvar_to_one()
print_globvar()       # Prints 1
</code></pre>
<p>Since it's unclear whether <code>globvar = 1</code> is creating a local variable or changing a global variable, Python defaults to creating a local variable, and makes you explicitly choose the other behavior with the <code>global</code> keyword.</p>
<p>See other answers if you want to share a global variable across modules.</p>
"
20627316,"<p>The <code>SettingWithCopyWarning</code> was created to flag potentially confusing &quot;chained&quot; assignments, such as the following, which does not always work as expected, particularly when the first selection returns a <em>copy</em>.  [see <a href=""https://github.com/pydata/pandas/pull/5390"" rel=""noreferrer"">GH5390</a> and <a href=""https://github.com/pydata/pandas/issues/5597"" rel=""noreferrer"">GH5597</a> for background discussion.]</p>
<pre><code>df[df['A'] &gt; 2]['B'] = new_val  # new_val not set in df
</code></pre>
<p>The warning offers a suggestion to rewrite as follows:</p>
<pre><code>df.loc[df['A'] &gt; 2, 'B'] = new_val
</code></pre>
<p>However, this doesn't fit your usage, which is equivalent to:</p>
<pre><code>df = df[df['A'] &gt; 2]
df['B'] = new_val
</code></pre>
<p>While it's clear that you don't care about writes making it back to the original frame (since you are overwriting the reference to it), unfortunately this pattern cannot be differentiated from the first chained assignment example. Hence the (false positive) warning. The potential for false positives is addressed in the <a href=""https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy"" rel=""noreferrer"">docs on indexing</a>, if you'd like to read further.  You can safely disable this new warning with the following assignment.</p>
<pre><code>import pandas as pd
pd.options.mode.chained_assignment = None  # default='warn'
</code></pre>
<hr />
<h2>Other Resources</h2>
<ul>
<li><a href=""https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html"" rel=""noreferrer"">pandas User Guide: Indexing and selecting data</a></li>
<li><a href=""https://jakevdp.github.io/PythonDataScienceHandbook/03.02-data-indexing-and-selection.html"" rel=""noreferrer"">Python Data Science Handbook: Data Indexing and Selection</a></li>
<li><a href=""https://realpython.com/pandas-settingwithcopywarning/"" rel=""noreferrer"">Real Python: SettingWithCopyWarning in Pandas: Views vs Copies</a></li>
<li><a href=""https://www.dataquest.io/blog/settingwithcopywarning/"" rel=""noreferrer"">Dataquest: SettingwithCopyWarning: How to Fix This Warning in Pandas</a></li>
<li><a href=""https://towardsdatascience.com/explaining-the-settingwithcopywarning-in-pandas-ebc19d799d25"" rel=""noreferrer"">Towards Data Science: Explaining the SettingWithCopyWarning in pandas</a></li>
</ul>
"
36908,"<p>The <code>*args</code> and <code>**kwargs</code> is a common idiom to allow arbitrary number of arguments to functions as described in the section <a href=""http://docs.python.org/3/tutorial/controlflow.html#more-on-defining-functions"" rel=""noreferrer"">more on defining functions</a> in the Python documentation.</p>
<p>The <code>*args</code> will give you all function parameters <a href=""https://docs.python.org/3/tutorial/controlflow.html#arbitrary-argument-lists"" rel=""noreferrer"">as a tuple</a>:</p>
<pre><code>def foo(*args):
    for a in args:
        print(a)        

foo(1)
# 1

foo(1,2,3)
# 1
# 2
# 3
</code></pre>
<p>The <code>**kwargs</code> will give you all
<strong>keyword arguments</strong> except for those corresponding to a formal parameter as a dictionary.</p>
<pre><code>def bar(**kwargs):
    for a in kwargs:
        print(a, kwargs[a])  

bar(name='one', age=27)
# name one
# age 27
</code></pre>
<p>Both idioms can be mixed with normal arguments to allow a set of fixed and some variable arguments:</p>
<pre><code>def foo(kind, *args, **kwargs):
   pass
</code></pre>
<p>It is also possible to use this the other way around:</p>
<pre><code>def foo(a, b, c):
    print(a, b, c)

obj = {'b':10, 'c':'lee'}

foo(100,**obj)
# 100 10 lee
</code></pre>
<p>Another usage of the <code>*l</code> idiom is to <strong>unpack argument lists</strong> when calling a function.</p>
<pre><code>def foo(bar, lee):
    print(bar, lee)

l = [1,2]

foo(*l)
# 1 2
</code></pre>
<p>In Python 3 it is possible to use <code>*l</code> on the left side of an assignment (<a href=""http://www.python.org/dev/peps/pep-3132/"" rel=""noreferrer"">Extended Iterable Unpacking</a>), though it gives a list instead of a tuple in this context:</p>
<pre><code>first, *rest = [1,2,3,4]
first, *l, last = [1,2,3,4]
</code></pre>
<p>Also Python 3 adds new semantic (refer <a href=""https://www.python.org/dev/peps/pep-3102/"" rel=""noreferrer"">PEP 3102</a>):</p>
<pre><code>def func(arg1, arg2, arg3, *, kwarg1, kwarg2):
    pass
</code></pre>
<p>For example the following works in python 3 but not python 2:</p>
<pre><code>&gt;&gt;&gt; x = [1, 2]
&gt;&gt;&gt; [*x]
[1, 2]
&gt;&gt;&gt; [*x, 3, 4]
[1, 2, 3, 4]

&gt;&gt;&gt; x = {1:1, 2:2}
&gt;&gt;&gt; x
{1: 1, 2: 2}
&gt;&gt;&gt; {**x, 3:3, 4:4}
{1: 1, 2: 2, 3: 3, 4: 4}
</code></pre>
<p>Such function accepts only 3 positional arguments, and everything after <code>*</code> can only be passed as keyword arguments.</p>
<h3>Note:</h3>
<ul>
<li>A Python <code>dict</code>, semantically used for keyword argument passing, are arbitrarily ordered. However, in Python 3.6, keyword arguments are guaranteed to remember insertion order.</li>
<li>&quot;The order of elements in <code>**kwargs</code> now corresponds to the order in which keyword arguments were passed to the function.&quot; - <a href=""https://docs.python.org/3/whatsnew/3.6.html"" rel=""noreferrer"">Whatâs New In Python 3.6</a></li>
<li>In fact, all dicts in CPython 3.6 will remember insertion order as an implementation detail, this becomes standard in Python 3.7.</li>
</ul>
"
419185,"<h1>Short Answer</h1>
<p>It's boilerplate code that protects users from accidentally invoking the script when they didn't intend to. Here are some common problems when the guard is omitted from a script:</p>
<ul>
<li><p>If you import the guardless script in another script (e.g. <code>import my_script_without_a_name_eq_main_guard</code>), then the latter script will trigger the former to run <em>at import time</em> and <em>using the second script's command line arguments</em>. This is almost always a mistake.</p>
</li>
<li><p>If you have a custom class in the guardless script and save it to a pickle file, then unpickling it in another script will trigger an import of the guardless script, with the same problems outlined in the previous bullet.</p>
</li>
</ul>
<h1>Long Answer</h1>
<p>To better understand why and how this matters, we need to take a step back to understand how Python initializes scripts and how this interacts with its module import mechanism.</p>
<p>Whenever the Python interpreter reads a source file, it does two things:</p>
<ul>
<li><p>it sets a few special variables like <code>__name__</code>, and then</p>
</li>
<li><p>it executes all of the code found in the file.</p>
</li>
</ul>
<p>Let's see how this works and how it relates to your question about the <code>__name__</code> checks we always see in Python scripts.</p>
<h2>Code Sample</h2>
<p>Let's use a slightly different code sample to explore how imports and scripts work.  Suppose the following is in a file called <code>foo.py</code>.</p>
<pre><code># Suppose this is foo.py.

print(&quot;before import&quot;)
import math

print(&quot;before function_a&quot;)
def function_a():
    print(&quot;Function A&quot;)

print(&quot;before function_b&quot;)
def function_b():
    print(&quot;Function B {}&quot;.format(math.sqrt(100)))

print(&quot;before __name__ guard&quot;)
if __name__ == '__main__':
    function_a()
    function_b()
print(&quot;after __name__ guard&quot;)
</code></pre>
<h2>Special Variables</h2>
<p>When the Python interpreter reads a source file, it first defines a few special variables. In this case, we care about the <code>__name__</code> variable.</p>
<p><strong>When Your Module Is the Main Program</strong></p>
<p>If you are running your module (the source file) as the main program, e.g.</p>
<pre><code>python foo.py
</code></pre>
<p>the interpreter will assign the hard-coded string <code>&quot;__main__&quot;</code> to the <code>__name__</code> variable, i.e.</p>
<pre><code># It's as if the interpreter inserts this at the top
# of your module when run as the main program.
__name__ = &quot;__main__&quot; 
</code></pre>
<p><strong>When Your Module Is Imported By Another</strong></p>
<p>On the other hand, suppose some other module is the main program and it imports your module. This means there's a statement like this in the main program, or in some other module the main program imports:</p>
<pre><code># Suppose this is in some other main program.
import foo
</code></pre>
<p>The interpreter will search for your <code>foo.py</code> file (along with searching for a few other variants), and prior to executing that module, it will assign the name <code>&quot;foo&quot;</code> from the import statement to the <code>__name__</code> variable, i.e.</p>
<pre><code># It's as if the interpreter inserts this at the top
# of your module when it's imported from another module.
__name__ = &quot;foo&quot;
</code></pre>
<h2>Executing the Module's Code</h2>
<p>After the special variables are set up, the interpreter executes all the code in the module, one statement at a time. You may want to open another window on the side with the code sample so you can follow along with this explanation.</p>
<p><strong>Always</strong></p>
<ol>
<li><p>It prints the string <code>&quot;before import&quot;</code> (without quotes).</p>
</li>
<li><p>It loads the <code>math</code> module and assigns it to a variable called <code>math</code>. This is equivalent to replacing <code>import math</code> with the following (note that <code>__import__</code> is a low-level function in Python that takes a string and triggers the actual import):</p>
</li>
</ol>
<pre><code># Find and load a module given its string name, &quot;math&quot;,
# then assign it to a local variable called math.
math = __import__(&quot;math&quot;)
</code></pre>
<ol start=""3"">
<li><p>It prints the string <code>&quot;before function_a&quot;</code>.</p>
</li>
<li><p>It executes the <code>def</code> block, creating a function object, then assigning that function object to a variable called <code>function_a</code>.</p>
</li>
<li><p>It prints the string <code>&quot;before function_b&quot;</code>.</p>
</li>
<li><p>It executes the second <code>def</code> block, creating another function object, then assigning it to a variable called <code>function_b</code>.</p>
</li>
<li><p>It prints the string <code>&quot;before __name__ guard&quot;</code>.</p>
</li>
</ol>
<p><strong>Only When Your Module Is the Main Program</strong></p>
<ol start=""8"">
<li>If your module is the main program, then it will see that <code>__name__</code> was indeed set to <code>&quot;__main__&quot;</code> and it calls the two functions, printing the strings <code>&quot;Function A&quot;</code> and <code>&quot;Function B 10.0&quot;</code>.</li>
</ol>
<p><strong>Only When Your Module Is Imported by Another</strong></p>
<ol start=""8"">
<li>(<strong>instead</strong>) If your module is not the main program but was imported by another one, then <code>__name__</code> will be <code>&quot;foo&quot;</code>, not <code>&quot;__main__&quot;</code>, and it'll skip the body of the <code>if</code> statement.</li>
</ol>
<p><strong>Always</strong></p>
<ol start=""9"">
<li>It will print the string <code>&quot;after __name__ guard&quot;</code> in both situations.</li>
</ol>
<p><em><strong>Summary</strong></em></p>
<p>In summary, here's what'd be printed in the two cases:</p>
<pre class=""lang-none prettyprint-override""><code># What gets printed if foo is the main program
before import
before function_a
before function_b
before __name__ guard
Function A
Function B 10.0
after __name__ guard
</code></pre>
<pre class=""lang-none prettyprint-override""><code># What gets printed if foo is imported as a regular module
before import
before function_a
before function_b
before __name__ guard
after __name__ guard
</code></pre>
<h2>Why Does It Work This Way?</h2>
<p>You might naturally wonder why anybody would want this.  Well, sometimes you want to write a <code>.py</code> file that can be both used by other programs and/or modules as a module, and can also be run as the main program itself.  Examples:</p>
<ul>
<li><p>Your module is a library, but you want to have a script mode where it runs some unit tests or a demo.</p>
</li>
<li><p>Your module is only used as a main program, but it has some unit tests, and the testing framework works by importing <code>.py</code> files like your script and running special test functions. You don't want it to try running the script just because it's importing the module.</p>
</li>
<li><p>Your module is mostly used as a main program, but it also provides a programmer-friendly API for advanced users.</p>
</li>
</ul>
<p>Beyond those examples, it's elegant that running a script in Python is just setting up a few magic variables and importing the script. &quot;Running&quot; the script is a side effect of importing the script's module.</p>
<h2>Food for Thought</h2>
<ul>
<li><p>Question: Can I have multiple <code>__name__</code> checking blocks?  Answer: it's strange to do so, but the language won't stop you.</p>
</li>
<li><p>Suppose the following is in <code>foo2.py</code>.  What happens if you say <code>python foo2.py</code> on the command-line? Why?</p>
</li>
</ul>
<pre class=""lang-py prettyprint-override""><code># Suppose this is foo2.py.
import os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters

def function_a():
    print(&quot;a1&quot;)
    from foo2 import function_b
    print(&quot;a2&quot;)
    function_b()
    print(&quot;a3&quot;)

def function_b():
    print(&quot;b&quot;)

print(&quot;t1&quot;)
if __name__ == &quot;__main__&quot;:
    print(&quot;m1&quot;)
    function_a()
    print(&quot;m2&quot;)
print(&quot;t2&quot;)
      
</code></pre>
<ul>
<li>Now, figure out what will happen if you remove the <code>__name__</code> check in <code>foo3.py</code>:</li>
</ul>
<pre class=""lang-py prettyprint-override""><code># Suppose this is foo3.py.
import os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters

def function_a():
    print(&quot;a1&quot;)
    from foo3 import function_b
    print(&quot;a2&quot;)
    function_b()
    print(&quot;a3&quot;)

def function_b():
    print(&quot;b&quot;)

print(&quot;t1&quot;)
print(&quot;m1&quot;)
function_a()
print(&quot;m2&quot;)
print(&quot;t2&quot;)
</code></pre>
<ul>
<li>What will this do when used as a script?  When imported as a module?</li>
</ul>
<pre class=""lang-py prettyprint-override""><code># Suppose this is in foo4.py
__name__ = &quot;__main__&quot;

def bar():
    print(&quot;bar&quot;)
    
print(&quot;before __name__ guard&quot;)
if __name__ == &quot;__main__&quot;:
    bar()
print(&quot;after __name__ guard&quot;)
</code></pre>
"
292502,"<p>Actually, a concise rule for Python Scope resolution, from <a href=""https://rads.stackoverflow.com/amzn/click/com/0596513984"" rel=""noreferrer"" rel=""nofollow noreferrer"">Learning Python, 3rd. Ed.</a>. (These rules are specific to variable names, not attributes. If you reference it without a period, these rules apply.)</p>

<p><strong>LEGB Rule</strong></p>

<ul>
<li><p><strong>L</strong>ocal â Names assigned in any way within a function (<code>def</code> or <code>lambda</code>), and not declared global in that function</p></li>
<li><p><strong>E</strong>nclosing-function â Names assigned in the local scope of any and all statically enclosing functions (<code>def</code> or <code>lambda</code>), from inner to outer</p></li>
<li><p><strong>G</strong>lobal (module) â Names assigned at the top-level of a module file, or by executing a <code>global</code> statement in a <code>def</code> within the file</p></li>
<li><p><strong>B</strong>uilt-in (Python) â Names preassigned in the built-in names module: <code>open</code>, <code>range</code>, <code>SyntaxError</code>, etc</p></li>
</ul>

<p>So, in the case of</p>

<pre><code>code1
class Foo:
    code2
    def spam():
        code3
        for code4:
            code5
            x()
</code></pre>

<p>The <code>for</code> loop does not have its own namespace. In LEGB order, the scopes would be </p>

<ul>
<li>L: Local in <code>def spam</code> (in <code>code3</code>, <code>code4</code>, and <code>code5</code>)</li>
<li>E: Any enclosing functions (if the whole example were in another <code>def</code>)</li>
<li>G: Were there any <code>x</code> declared globally in the module (in <code>code1</code>)?</li>
<li>B: Any builtin <code>x</code> in Python.</li>
</ul>

<p><code>x</code> will never be found in <code>code2</code> (even in cases where you might expect it would, see <a href=""https://stackoverflow.com/a/23471004/2810305"">Antti's answer</a> or <a href=""https://stackoverflow.com/q/13905741/2810305"">here</a>).</p>
"
,
17071908,"<p>To select rows whose column value equals a scalar, <code>some_value</code>, use <code>==</code>:</p>
<pre><code>df.loc[df['column_name'] == some_value]
</code></pre>
<p>To select rows whose column value is in an iterable, <code>some_values</code>, use <code>isin</code>:</p>
<pre><code>df.loc[df['column_name'].isin(some_values)]
</code></pre>
<p>Combine multiple conditions with <code>&amp;</code>:</p>
<pre><code>df.loc[(df['column_name'] &gt;= A) &amp; (df['column_name'] &lt;= B)]
</code></pre>
<p>Note the parentheses. Due to Python's <a href=""https://docs.python.org/3/reference/expressions.html#operator-precedence"" rel=""noreferrer"">operator precedence rules</a>, <code>&amp;</code> binds more tightly than <code>&lt;=</code> and <code>&gt;=</code>. Thus, the parentheses in the last example are necessary. Without the parentheses</p>
<pre><code>df['column_name'] &gt;= A &amp; df['column_name'] &lt;= B
</code></pre>
<p>is parsed as</p>
<pre><code>df['column_name'] &gt;= (A &amp; df['column_name']) &lt;= B
</code></pre>
<p>which results in a <a href=""https://stackoverflow.com/questions/36921951/truth-value-of-a-series-is-ambiguous-use-a-empty-a-bool-a-item-a-any-o"">Truth value of a Series is ambiguous error</a>.</p>
<hr />
<p>To select rows whose column value <em>does not equal</em> <code>some_value</code>, use <code>!=</code>:</p>
<pre><code>df.loc[df['column_name'] != some_value]
</code></pre>
<p>The <code>isin</code> returns a boolean Series, so to select rows whose value is <em>not</em> in <code>some_values</code>, negate the boolean Series using <code>~</code>:</p>
<pre><code>df.loc[~df['column_name'].isin(some_values)]
</code></pre>
<hr />
<p>For example,</p>
<pre><code>import pandas as pd
import numpy as np
df = pd.DataFrame({'A': 'foo bar foo bar foo bar foo foo'.split(),
                   'B': 'one one two three two two one three'.split(),
                   'C': np.arange(8), 'D': np.arange(8) * 2})
print(df)
#      A      B  C   D
# 0  foo    one  0   0
# 1  bar    one  1   2
# 2  foo    two  2   4
# 3  bar  three  3   6
# 4  foo    two  4   8
# 5  bar    two  5  10
# 6  foo    one  6  12
# 7  foo  three  7  14

print(df.loc[df['A'] == 'foo'])
</code></pre>
<p>yields</p>
<pre><code>     A      B  C   D
0  foo    one  0   0
2  foo    two  2   4
4  foo    two  4   8
6  foo    one  6  12
7  foo  three  7  14
</code></pre>
<hr />
<p>If you have multiple values you want to include, put them in a
list (or more generally, any iterable) and use <code>isin</code>:</p>
<pre><code>print(df.loc[df['B'].isin(['one','three'])])
</code></pre>
<p>yields</p>
<pre><code>     A      B  C   D
0  foo    one  0   0
1  bar    one  1   2
3  bar  three  3   6
6  foo    one  6  12
7  foo  three  7  14
</code></pre>
<hr />
<p>Note, however, that if you wish to do this many times, it is more efficient to
make an index first, and then use <code>df.loc</code>:</p>
<pre><code>df = df.set_index(['B'])
print(df.loc['one'])
</code></pre>
<p>yields</p>
<pre><code>       A  C   D
B              
one  foo  0   0
one  bar  1   2
one  foo  6  12
</code></pre>
<p>or, to include multiple values from the index use <code>df.index.isin</code>:</p>
<pre><code>df.loc[df.index.isin(['one','two'])]
</code></pre>
<p>yields</p>
<pre><code>       A  C   D
B              
one  foo  0   0
one  bar  1   2
two  foo  2   4
two  foo  4   8
two  bar  5  10
one  foo  6  12
</code></pre>
"
1101765,"<p>The <code>grid</code>, <code>pack</code> and <code>place</code> functions of the <code>Entry</code> object and of all other widgets returns <code>None</code>. In python when you do <code>a().b()</code>, the result of the expression is whatever <code>b()</code> returns, therefore <code>Entry(...).grid(...)</code> will return <code>None</code>. </p>

<p>You should split that on to two lines like this:</p>

<pre><code>entryBox = Entry(root, width=60)
entryBox.grid(row=2, column=1, sticky=W)
</code></pre>

<p>That way you get your <code>Entry</code> reference stored in <code>entryBox</code> and it's laid out like you expect. This has a bonus side effect of making your layout easier to understand and maintain if you collect all of your <code>grid</code> and/or <code>pack</code> statements in blocks.</p>
"
89243,"<p>Use the <a href=""https://docs.python.org/library/subprocess.html"" rel=""noreferrer""><code>subprocess</code></a> module in the standard library:</p>
<pre class=""lang-py prettyprint-override""><code>import subprocess

# for simple commands
subprocess.run([&quot;ls&quot;, &quot;-l&quot;]) 

# for complex commands, with many args, use string + `shell=True`:
cmd_str = &quot;ls -l /tmp | awk '{print $3,$9}' | grep root&quot;
subprocess.run(cmd_str, shell=True)
</code></pre>
<p>The advantage of <a href=""https://docs.python.org/library/subprocess.html#subprocess.run"" rel=""noreferrer""><code>subprocess.run</code></a> over <a href=""https://docs.python.org/library/os.html#os.system"" rel=""noreferrer""><code>os.system</code></a> is that it is more flexible (you can get the <a href=""https://docs.python.org/library/subprocess.html#subprocess.CompletedProcess.stdout"" rel=""noreferrer""><code>stdout</code></a>, <a href=""https://docs.python.org/library/subprocess.html#subprocess.CompletedProcess.stderr"" rel=""noreferrer""><code>stderr</code></a>, the <a href=""https://docs.python.org/library/subprocess.html#subprocess.CompletedProcess.returncode"" rel=""noreferrer"">&quot;real&quot; status code</a>, better <a href=""https://docs.python.org/library/subprocess.html#subprocess.CalledProcessError"" rel=""noreferrer"">error handling</a>, it is not prone to problems due to spaces in folders in the path to the executable, etc...).</p>
<p>Even <a href=""https://docs.python.org/library/os.html#os.system"" rel=""noreferrer"">the documentation for <code>os.system</code></a> recommends using <code>subprocess</code> instead:</p>
<blockquote>
<p>The <code>subprocess</code> module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function. See the <a href=""https://docs.python.org/library/subprocess.html#subprocess-replacements"" rel=""noreferrer"">Replacing Older Functions with the subprocess Module</a> section in the <a href=""https://docs.python.org/library/subprocess.html"" rel=""noreferrer""><code>subprocess</code></a> documentation for some helpful recipes.</p>
</blockquote>
<p>On Python 3.4 and earlier, use <code>subprocess.call</code> instead of <code>.run</code>:</p>
<pre class=""lang-py prettyprint-override""><code>subprocess.call([&quot;ls&quot;, &quot;-l&quot;])
</code></pre>
"
17778390,"<p>It is returning <code>None</code> because when you recursively call it:</p>
<pre><code>if my_var != &quot;a&quot; and my_var != &quot;b&quot;:
    print('You didn\'t type &quot;a&quot; or &quot;b&quot;. Try again.')
    get_input()
</code></pre>
<p>..you don't return the value.</p>
<p>So while the recursion does happen, the return value gets discarded, and then you fall off the end of the function.  Falling off the end of the function means that python implicitly returns <code>None</code>, just like this:</p>
<pre><code>&gt;&gt;&gt; def f(x):
...     pass
&gt;&gt;&gt; print(f(20))
None
</code></pre>
<p>So, instead of just <em>calling</em> <code>get_input()</code> in your <code>if</code> statement, you need to <code>return</code> what the recursive call returns:</p>
<pre><code>if my_var != &quot;a&quot; and my_var != &quot;b&quot;:
    print('You didn\'t type &quot;a&quot; or &quot;b&quot;. Try again.')
    return get_input()
</code></pre>
"
370363,"<p>Python treats variables in functions differently depending on whether you assign values to them from inside or outside the function.  If a variable is assigned within a function, it is treated by default as a local variable.  Therefore, when you uncomment the line, you are trying to reference the local variable <code>c</code> before any value has been assigned to it.</p>
<p>If you want the variable <code>c</code> to refer to the global <code>c = 3</code> assigned before the function, put</p>
<pre><code>global c
</code></pre>
<p>as the first line of the function.</p>
<p>As for python 3, there is now</p>
<pre><code>nonlocal c
</code></pre>
<p>that you can use to refer to the nearest enclosing function scope that has a <code>c</code> variable.</p>
"
613218,"<h3>Python 3.7+ or CPython 3.6</h3>
<p>Dicts preserve insertion order in Python 3.7+. Same in CPython 3.6, but <a href=""https://stackoverflow.com/q/39980323/4518341"">it's an implementation detail</a>.</p>
<pre><code>&gt;&gt;&gt; x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
&gt;&gt;&gt; {k: v for k, v in sorted(x.items(), key=lambda item: item[1])}
{0: 0, 2: 1, 1: 2, 4: 3, 3: 4}
</code></pre>
<p>or</p>
<pre><code>&gt;&gt;&gt; dict(sorted(x.items(), key=lambda item: item[1]))
{0: 0, 2: 1, 1: 2, 4: 3, 3: 4}
</code></pre>
<h3>Older Python</h3>
<p>It is not possible to sort a dictionary, only to get a representation of a dictionary that is sorted. Dictionaries are inherently orderless, but other types, such as lists and tuples, are not. So you need an ordered data type to represent sorted values, which will be a listâprobably a list of tuples.</p>
<p>For instance,</p>
<pre><code>import operator
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_x = sorted(x.items(), key=operator.itemgetter(1))
</code></pre>
<p><code>sorted_x</code> will be a list of tuples sorted by the second element in each tuple. <code>dict(sorted_x) == x</code>.</p>
<p>And for those wishing to sort on keys instead of values:</p>
<pre><code>import operator
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_x = sorted(x.items(), key=operator.itemgetter(0))
</code></pre>
<p>In Python3 since <a href=""https://stackoverflow.com/a/15712231/4293057"">unpacking is not allowed</a> we can use</p>
<pre><code>x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_x = sorted(x.items(), key=lambda kv: kv[1])
</code></pre>
<p>If you want the output as a dict, you can use <a href=""https://docs.python.org/3/library/collections.html#collections.OrderedDict"" rel=""noreferrer""><code>collections.OrderedDict</code></a>:</p>
<pre><code>import collections

sorted_dict = collections.OrderedDict(sorted_x)
</code></pre>
"
1663826,"<h2>Python 3</h2>

<pre><code>for f, b in zip(foo, bar):
    print(f, b)
</code></pre>

<p><code>zip</code> stops when the shorter of <code>foo</code> or <code>bar</code> stops.</p>

<p>In <strong>Python 3</strong>, <a href=""https://docs.python.org/3/library/functions.html#zip"" rel=""noreferrer""><code>zip</code></a>
returns an iterator of tuples, like <code>itertools.izip</code> in Python2.  To get a list
of tuples, use <code>list(zip(foo, bar))</code>. And to zip until both iterators are
exhausted, you would use
<a href=""https://docs.python.org/3.4/library/itertools.html#itertools.zip_longest"" rel=""noreferrer"">itertools.zip_longest</a>.</p>

<h2>Python 2</h2>

<p>In <strong>Python 2</strong>, <a href=""https://docs.python.org/2/library/functions.html#zip"" rel=""noreferrer""><code>zip</code></a>
returns a list of tuples. This is fine when <code>foo</code> and <code>bar</code> are not massive. If they are both massive then forming <code>zip(foo,bar)</code> is an unnecessarily massive
temporary variable, and should be replaced by <code>itertools.izip</code> or
<code>itertools.izip_longest</code>, which returns an iterator instead of a list.</p>

<pre><code>import itertools
for f,b in itertools.izip(foo,bar):
    print(f,b)
for f,b in itertools.izip_longest(foo,bar):
    print(f,b)
</code></pre>

<p><code>izip</code> stops when either <code>foo</code> or <code>bar</code> is exhausted.
<code>izip_longest</code> stops when both <code>foo</code> and <code>bar</code> are exhausted.
When the shorter iterator(s) are exhausted, <code>izip_longest</code> yields a tuple with <code>None</code> in the position corresponding to that iterator. You can also set a different <code>fillvalue</code> besides <code>None</code> if you wish. See here for the <a href=""http://docs.python.org/library/itertools.html#itertools.izip_longest"" rel=""noreferrer"">full story</a>.</p>

<hr>

<p>Note also that <code>zip</code> and its <code>zip</code>-like brethen can accept an arbitrary number of iterables as arguments. For example,</p>

<pre><code>for num, cheese, color in zip([1,2,3], ['manchego', 'stilton', 'brie'], 
                              ['red', 'blue', 'green']):
    print('{} {} {}'.format(num, color, cheese))
</code></pre>

<p>prints</p>

<pre><code>1 red manchego
2 blue stilton
3 green brie
</code></pre>
"
231855,"<p>To understand what <code>yield</code> does, you must understand what <em>generators</em> are. And before you can understand generators, you must understand <em>iterables</em>.</p>
<h2>Iterables</h2>
<p>When you create a list, you can read its items one by one. Reading its items one by one is called iteration:</p>
<pre><code>&gt;&gt;&gt; mylist = [1, 2, 3]
&gt;&gt;&gt; for i in mylist:
...    print(i)
1
2
3
</code></pre>
<p><code>mylist</code> is an <em>iterable</em>. When you use a list comprehension, you create a list, and so an iterable:</p>
<pre><code>&gt;&gt;&gt; mylist = [x*x for x in range(3)]
&gt;&gt;&gt; for i in mylist:
...    print(i)
0
1
4
</code></pre>
<p>Everything you can use &quot;<code>for... in...</code>&quot; on is an iterable; <code>lists</code>, <code>strings</code>, files...</p>
<p>These iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values.</p>
<h2>Generators</h2>
<p>Generators are iterators, a kind of iterable <strong>you can only iterate over once</strong>. Generators do not store all the values in memory, <strong>they generate the values on the fly</strong>:</p>
<pre><code>&gt;&gt;&gt; mygenerator = (x*x for x in range(3))
&gt;&gt;&gt; for i in mygenerator:
...    print(i)
0
1
4
</code></pre>
<p>It is just the same except you used <code>()</code> instead of <code>[]</code>. BUT, you <strong>cannot</strong> perform <code>for i in mygenerator</code> a second time since generators can only be used once: they calculate 0, then forget about it and calculate 1, and end calculating 4, one by one.</p>
<h2>Yield</h2>
<p><code>yield</code> is a keyword that is used like <code>return</code>, except the function will return a generator.</p>
<pre><code>&gt;&gt;&gt; def create_generator():
...    mylist = range(3)
...    for i in mylist:
...        yield i*i
...
&gt;&gt;&gt; mygenerator = create_generator() # create a generator
&gt;&gt;&gt; print(mygenerator) # mygenerator is an object!
&lt;generator object create_generator at 0xb7555c34&gt;
&gt;&gt;&gt; for i in mygenerator:
...     print(i)
0
1
4
</code></pre>
<p>Here it's a useless example, but it's handy when you know your function will return a huge set of values that you will only need to read once.</p>
<p>To master <code>yield</code>, you must understand that <strong>when you call the function, the code you have written in the function body does not run.</strong> The function only returns the generator object, this is a bit tricky.</p>
<p>Then, your code will continue from where it left off each time <code>for</code> uses the generator.</p>
<p>Now the hard part:</p>
<p>The first time the <code>for</code> calls the generator object created from your function, it will run the code in your function from the beginning until it hits <code>yield</code>, then it'll return the first value of the loop. Then, each subsequent call will run another iteration of the loop you have written in the function and return the next value. This will continue until the generator is considered empty, which happens when the function runs without hitting <code>yield</code>. That can be because the loop has come to an end, or because you no longer satisfy an <code>&quot;if/else&quot;</code>.</p>
<hr />
<h2>Your code explained</h2>
<p><em>Generator:</em></p>
<pre><code># Here you create the method of the node object that will return the generator
def _get_child_candidates(self, distance, min_dist, max_dist):

    # Here is the code that will be called each time you use the generator object:

    # If there is still a child of the node object on its left
    # AND if the distance is ok, return the next child
    if self._leftchild and distance - max_dist &lt; self._median:
        yield self._leftchild

    # If there is still a child of the node object on its right
    # AND if the distance is ok, return the next child
    if self._rightchild and distance + max_dist &gt;= self._median:
        yield self._rightchild

    # If the function arrives here, the generator will be considered empty
    # there are no more than two values: the left and the right children
</code></pre>
<p><em>Caller:</em></p>
<pre><code># Create an empty list and a list with the current object reference
result, candidates = list(), [self]

# Loop on candidates (they contain only one element at the beginning)
while candidates:

    # Get the last candidate and remove it from the list
    node = candidates.pop()

    # Get the distance between obj and the candidate
    distance = node._get_dist(obj)

    # If the distance is ok, then you can fill in the result
    if distance &lt;= max_dist and distance &gt;= min_dist:
        result.extend(node._values)

    # Add the children of the candidate to the candidate's list
    # so the loop will keep running until it has looked
    # at all the children of the children of the children, etc. of the candidate
    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))

return result
</code></pre>
<p>This code contains several smart parts:</p>
<ul>
<li><p>The loop iterates on a list, but the list expands while the loop is being iterated. It's a concise way to go through all these nested data even if it's a bit dangerous since you can end up with an infinite loop. In this case, <code>candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))</code> exhausts all the values of the generator, but <code>while</code> keeps creating new generator objects which will produce different values from the previous ones since it's not applied on the same node.</p>
</li>
<li><p>The <code>extend()</code> method is a list object method that expects an iterable and adds its values to the list.</p>
</li>
</ul>
<p>Usually, we pass a list to it:</p>
<pre><code>&gt;&gt;&gt; a = [1, 2]
&gt;&gt;&gt; b = [3, 4]
&gt;&gt;&gt; a.extend(b)
&gt;&gt;&gt; print(a)
[1, 2, 3, 4]
</code></pre>
<p>But in your code, it gets a generator, which is good because:</p>
<ol>
<li>You don't need to read the values twice.</li>
<li>You may have a lot of children and you don't want them all stored in memory.</li>
</ol>
<p>And it works because Python does not care if the argument of a method is a list or not. Python expects iterables so it will work with strings, lists, tuples, and generators! This is called duck typing and is one of the reasons why Python is so cool. But this is another story, for another question...</p>
<p>You can stop here, or read a little bit to see an advanced use of a generator:</p>
<h2>Controlling a generator exhaustion</h2>
<pre><code>&gt;&gt;&gt; class Bank(): # Let's create a bank, building ATMs
...    crisis = False
...    def create_atm(self):
...        while not self.crisis:
...            yield &quot;$100&quot;
&gt;&gt;&gt; hsbc = Bank() # When everything's ok the ATM gives you as much as you want
&gt;&gt;&gt; corner_street_atm = hsbc.create_atm()
&gt;&gt;&gt; print(corner_street_atm.next())
$100
&gt;&gt;&gt; print(corner_street_atm.next())
$100
&gt;&gt;&gt; print([corner_street_atm.next() for cash in range(5)])
['$100', '$100', '$100', '$100', '$100']
&gt;&gt;&gt; hsbc.crisis = True # Crisis is coming, no more money!
&gt;&gt;&gt; print(corner_street_atm.next())
&lt;type 'exceptions.StopIteration'&gt;
&gt;&gt;&gt; wall_street_atm = hsbc.create_atm() # It's even true for new ATMs
&gt;&gt;&gt; print(wall_street_atm.next())
&lt;type 'exceptions.StopIteration'&gt;
&gt;&gt;&gt; hsbc.crisis = False # The trouble is, even post-crisis the ATM remains empty
&gt;&gt;&gt; print(corner_street_atm.next())
&lt;type 'exceptions.StopIteration'&gt;
&gt;&gt;&gt; brand_new_atm = hsbc.create_atm() # Build a new one to get back in business
&gt;&gt;&gt; for cash in brand_new_atm:
...    print cash
$100
$100
$100
$100
$100
$100
$100
$100
$100
...
</code></pre>
<p><strong>Note:</strong> For Python 3, use<code>print(corner_street_atm.__next__())</code> or <code>print(next(corner_street_atm))</code></p>
<p>It can be useful for various things like controlling access to a resource.</p>
<h2>Itertools, your best friend</h2>
<p>The itertools module contains special functions to manipulate iterables. Ever wish to duplicate a generator?
Chain two generators? Group values in a nested list with a one-liner? <code>Map / Zip</code> without creating another list?</p>
<p>Then just <code>import itertools</code>.</p>
<p>An example? Let's see the possible orders of arrival for a four-horse race:</p>
<pre><code>&gt;&gt;&gt; horses = [1, 2, 3, 4]
&gt;&gt;&gt; races = itertools.permutations(horses)
&gt;&gt;&gt; print(races)
&lt;itertools.permutations object at 0xb754f1dc&gt;
&gt;&gt;&gt; print(list(itertools.permutations(horses)))
[(1, 2, 3, 4),
 (1, 2, 4, 3),
 (1, 3, 2, 4),
 (1, 3, 4, 2),
 (1, 4, 2, 3),
 (1, 4, 3, 2),
 (2, 1, 3, 4),
 (2, 1, 4, 3),
 (2, 3, 1, 4),
 (2, 3, 4, 1),
 (2, 4, 1, 3),
 (2, 4, 3, 1),
 (3, 1, 2, 4),
 (3, 1, 4, 2),
 (3, 2, 1, 4),
 (3, 2, 4, 1),
 (3, 4, 1, 2),
 (3, 4, 2, 1),
 (4, 1, 2, 3),
 (4, 1, 3, 2),
 (4, 2, 1, 3),
 (4, 2, 3, 1),
 (4, 3, 1, 2),
 (4, 3, 2, 1)]
</code></pre>
<h2>Understanding the inner mechanisms of iteration</h2>
<p>Iteration is a process implying iterables (implementing the <code>__iter__()</code> method) and iterators (implementing the <code>__next__()</code> method).
Iterables are any objects you can get an iterator from. Iterators are objects that let you iterate on iterables.</p>
<p>There is more about it in this article about <a href=""https://web.archive.org/web/20201109034340/http://effbot.org/zone/python-for-statement.htm"" rel=""noreferrer"">how <code>for</code> loops work</a>.</p>
"
16424553,"<p>The variable <code>photo</code> is a local variable which gets garbage collected after the class is instantiated. Save a reference to the photo, for example:</p>
<pre><code>self.photo = tkinter.PhotoImage(...)
</code></pre>
<p>If you do a Google search on &quot;tkinter image doesn't display&quot;, the first result is this:</p>
<p><a href=""https://web.archive.org/web/20201111190625id_/http://effbot.org/pyfaq/why-do-my-tkinter-images-not-appear.htm"" rel=""noreferrer"">Why do my Tkinter images not appear?</a> (The FAQ answer is currently <em>not</em> outdated)</p>
"
1894296,"<pre><code>&gt;&gt;&gt; import ast
&gt;&gt;&gt; x = '[ &quot;A&quot;,&quot;B&quot;,&quot;C&quot; , &quot; D&quot;]'
&gt;&gt;&gt; x = ast.literal_eval(x)
&gt;&gt;&gt; x
['A', 'B', 'C', ' D']
&gt;&gt;&gt; x = [n.strip() for n in x]
&gt;&gt;&gt; x
['A', 'B', 'C', 'D']
</code></pre>
<p><a href=""https://docs.python.org/library/ast.html#ast.literal_eval"" rel=""noreferrer""><code>ast.literal_eval</code></a>:</p>
<blockquote>
<p>With <code>ast.literal_eval</code> you can safely evaluate an expression node or a string containing a Python literal or container display. The string or node provided may only consist of the following Python literal structures: strings, bytes, numbers, tuples, lists, dicts, booleans, and <code>None</code>.</p>
</blockquote>
"
2158532,"<p>Using generator functions can make your example easier to read and improve performance.</p>
<h3>Python 2</h3>
<p>Using the <a href=""https://docs.python.org/2/library/collections.html#collections-abstract-base-classes"" rel=""noreferrer""><code>Iterable</code> ABC</a> added in 2.6:</p>
<pre><code>from collections import Iterable

def flatten(xs):
    for x in xs:
        if isinstance(x, Iterable) and not isinstance(x, basestring):
            for item in flatten(x):
                yield item
        else:
            yield x
</code></pre>
<h3>Python 3</h3>
<p>In Python 3, <code>basestring</code> is no more, but the tuple <code>(str, bytes)</code> gives the same effect. Also, the <a href=""https://docs.python.org/3/whatsnew/3.3.html#pep-380"" rel=""noreferrer""><code>yield from</code></a> operator returns an item from a generator one at a time.</p>
<pre><code>from collections.abc import Iterable

def flatten(xs):
    for x in xs:
        if isinstance(x, Iterable) and not isinstance(x, (str, bytes)):
            yield from flatten(x)
        else:
            yield x
</code></pre>
"
16476974,"<p><a href=""https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html#pandas-dataframe-iterrows"" rel=""noreferrer""><code>DataFrame.iterrows</code></a> is a generator which yields both the index and row (as a Series):</p>
<pre><code>import pandas as pd

df = pd.DataFrame({'c1': [10, 11, 12], 'c2': [100, 110, 120]})
df = df.reset_index()  # make sure indexes pair with number of rows

for index, row in df.iterrows():
    print(row['c1'], row['c2'])
</code></pre>

<pre><code>10 100
11 110
12 120
</code></pre>
"
1832957,"<p>Yes, using <code>eval</code> is a bad practice. Just to name a few reasons:</p>
<ol>
<li>There is almost always a better way to do it</li>
<li>Very dangerous and insecure</li>
<li>Makes debugging difficult</li>
<li>Slow</li>
</ol>
<p>In your case you can use <a href=""http://docs.python.org/library/functions.html#setattr"" rel=""noreferrer"">setattr</a> instead:</p>
<pre><code>class Song:
    &quot;&quot;&quot;The class to store the details of each song&quot;&quot;&quot;
    attsToStore=('Name', 'Artist', 'Album', 'Genre', 'Location')
    def __init__(self):
        for att in self.attsToStore:
            setattr(self, att.lower(), None)
    def setDetail(self, key, val):
        if key in self.attsToStore:
            setattr(self, key.lower(), val)
</code></pre>
<p>There are some cases where you have to use <code>eval</code> or <code>exec</code>. But they are rare. Using <code>eval</code> in your case is a bad practice for sure. I'm emphasizing on bad practice because <code>eval</code> and <code>exec</code> are frequently used in the wrong place.</p>
<p><strong>Replying to the comments:</strong></p>
<p>It looks like some disagree that <code>eval</code> is 'very dangerous and insecure' in the OP case. That might be true for this specific case but not in general. The question was general and the reasons I listed are true for the general case as well.</p>
"
19913845,"<p><strong>If you only have two choices to select from:</strong></p>

<pre><code>df['color'] = np.where(df['Set']=='Z', 'green', 'red')
</code></pre>

<p>For example,</p>

<pre><code>import pandas as pd
import numpy as np

df = pd.DataFrame({'Type':list('ABBC'), 'Set':list('ZZXY')})
df['color'] = np.where(df['Set']=='Z', 'green', 'red')
print(df)
</code></pre>

<p>yields</p>

<pre><code>  Set Type  color
0   Z    A  green
1   Z    B  green
2   X    B    red
3   Y    C    red
</code></pre>

<hr>

<p><strong>If you have more than two conditions then use <a href=""https://docs.scipy.org/doc/numpy/reference/generated/numpy.select.html"" rel=""noreferrer""><code>np.select</code></a></strong>. For example, if you want <code>color</code> to be </p>

<ul>
<li><code>yellow</code> when <code>(df['Set'] == 'Z') &amp; (df['Type'] == 'A')</code></li>
<li>otherwise <code>blue</code> when <code>(df['Set'] == 'Z') &amp; (df['Type'] == 'B')</code> </li>
<li>otherwise <code>purple</code> when <code>(df['Type'] == 'B')</code></li>
<li>otherwise <code>black</code>,</li>
</ul>

<p>then use</p>

<pre><code>df = pd.DataFrame({'Type':list('ABBC'), 'Set':list('ZZXY')})
conditions = [
    (df['Set'] == 'Z') &amp; (df['Type'] == 'A'),
    (df['Set'] == 'Z') &amp; (df['Type'] == 'B'),
    (df['Type'] == 'B')]
choices = ['yellow', 'blue', 'purple']
df['color'] = np.select(conditions, choices, default='black')
print(df)
</code></pre>

<p>which yields</p>

<pre><code>  Set Type   color
0   Z    A  yellow
1   Z    B    blue
2   X    B  purple
3   Y    C   black
</code></pre>
"
11205638,"<p>The general design principle in Python is for <strong>functions that mutate an object in-place to return <code>None</code></strong>. I'm not sure it would have been the design choice I'd have chosen, but it's basically to emphasise that a new object is not returned.</p>
<p>Guido van Rossum (our Python BDFL) states the design choice <a href=""http://mail.python.org/pipermail/python-dev/2003-October/038855.html"" rel=""noreferrer"">on the Python-Dev mailing list</a>:</p>
<blockquote>
<p>I'd like to explain once more why I'm so adamant that sort() shouldn't
return 'self'.</p>
<p>This comes from a coding style (popular in various other languages, I
believe especially Lisp revels in it) where a series of side effects
on a single object can be chained like this:</p>
<pre><code>x.compress().chop(y).sort(z)
</code></pre>
<p>which would be the same as</p>
<pre><code>x.compress()
x.chop(y)
x.sort(z)
</code></pre>
<p>I find the chaining form a threat to readability; it requires that the
reader must be intimately familiar with each of the methods.  The
second form makes it clear that each of these calls acts on the same
object, and so even if you don't know the class and its methods very
well, you can understand that the second and third call are applied to
x (and that all calls are made for their side-effects), and not to
something else.</p>
<p>I'd like to reserve chaining for operations that return new values,
like string processing operations:</p>
<pre><code>y = x.rstrip(&quot;\n&quot;).split(&quot;:&quot;).lower()
</code></pre>
<p>There are a few standard library modules that encourage chaining of
side-effect calls (pstat comes to mind).  There shouldn't be any new
ones; pstat slipped through my filter when it was weak.</p>
</blockquote>
"
65064907,"<p>In PyGame, collision detection is done using <a href=""https://www.pygame.org/docs/ref/rect.html"" rel=""nofollow noreferrer""><code>pygame.Rect</code></a> objects. The <code>Rect</code> object offers various methods for detecting collisions between objects. Even the collision between a rectangular and circular object such as a paddle and a ball can be detected by a collision between two rectangular objects, the paddle and the bounding rectangle of the ball.</p>
<p>Some examples:</p>
<ul>
<li><p><a href=""https://www.pygame.org/docs/ref/rect.html#pygame.Rect.collidepoint"" rel=""nofollow noreferrer""><code>pygame.Rect.collidepoint</code></a>:</p>
<blockquote>
<p>Test if a point is inside a rectangle</p>
</blockquote>
<p><kbd><a href=""https://repl.it/@Rabbid76/PyGame-collidepoint#main.py"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5jD0C.png"" alt="""" /> repl.it/@Rabbid76/PyGame-collidepoint</a></kbd></p>
<p><a href=""https://i.stack.imgur.com/wCi2z.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wCi2z.gif"" alt="""" /></a></p>
<pre class=""lang-py prettyprint-override""><code>import pygame

pygame.init()
window = pygame.display.set_mode((250, 250))
rect = pygame.Rect(*window.get_rect().center, 0, 0).inflate(100, 100)

run = True
while run:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False

    point = pygame.mouse.get_pos()
    collide = rect.collidepoint(point)
    color = (255, 0, 0) if collide else (255, 255, 255)

    window.fill(0)
    pygame.draw.rect(window, color, rect)
    pygame.display.flip()

pygame.quit()
exit()
</code></pre>
</li>
<li><p><a href=""https://www.pygame.org/docs/ref/rect.html#pygame.Rect.colliderect"" rel=""nofollow noreferrer""><code>pygame.Rect.colliderect</code></a></p>
<blockquote>
<p>Test if two rectangles overlap</p>
</blockquote>
<p>See also <a href=""https://stackoverflow.com/questions/63561028/how-to-detect-collision-between-two-images-in-pygame/63561152#63561152"">How to detect collisions between two rectangular objects or images in pygame</a></p>
<p><kbd><a href=""https://repl.it/@Rabbid76/PyGame-colliderect#main.py"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5jD0C.png"" alt="""" /> repl.it/@Rabbid76/PyGame-colliderect</a></kbd></p>
<p><a href=""https://i.stack.imgur.com/r2y9r.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/r2y9r.gif"" alt=""colliderect"" /></a></p>
<pre class=""lang-py prettyprint-override""><code>import pygame

pygame.init()
window = pygame.display.set_mode((250, 250))
rect1 = pygame.Rect(*window.get_rect().center, 0, 0).inflate(75, 75)
rect2 = pygame.Rect(0, 0, 75, 75)

run = True
while run:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False

    rect2.center = pygame.mouse.get_pos()
    collide = rect1.colliderect(rect2)
    color = (255, 0, 0) if collide else (255, 255, 255)

    window.fill(0)
    pygame.draw.rect(window, color, rect1)
    pygame.draw.rect(window, (0, 255, 0), rect2, 6, 1)
    pygame.display.flip()

pygame.quit()
exit()
</code></pre>
</li>
</ul>
<p>Furthermore, <a href=""https://www.pygame.org/docs/ref/rect.html#pygame.Rect.collidelist"" rel=""nofollow noreferrer""><code>pygame.Rect.collidelist</code></a> and <a href=""https://www.pygame.org/docs/ref/rect.html#pygame.Rect.collidelistall"" rel=""nofollow noreferrer""><code>pygame.Rect.collidelistall</code></a> can be used for the collision test between a rectangle and a list of rectangles. <a href=""https://www.pygame.org/docs/ref/rect.html#pygame.Rect.collidedict"" rel=""nofollow noreferrer""><code>pygame.Rect.collidedict</code></a> and <a href=""https://www.pygame.org/docs/ref/rect.html#pygame.Rect.collidedictall"" rel=""nofollow noreferrer""><code>pygame.Rect.collidedictall</code></a> can be used for the collision test between a rectangle and a dictionary of rectangles.</p>
<p>The collision of <a href=""https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.Sprite"" rel=""nofollow noreferrer""><code>pygame.sprite.Sprite</code></a> and <a href=""https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.Group"" rel=""nofollow noreferrer""><code>pygame.sprite.Group</code></a> objects, can be detected by <a href=""https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.spritecollide"" rel=""nofollow noreferrer""><code>pygame.sprite.spritecollide()</code></a>, <a href=""https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.groupcollide"" rel=""nofollow noreferrer""><code>pygame.sprite.groupcollide()</code></a> or <a href=""https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.spritecollideany"" rel=""nofollow noreferrer""><code>pygame.sprite.spritecollideany()</code></a>. When using these methods, the collision detection algorithm can be specified by the <code>collided</code> argument:</p>
<blockquote>
<p>The collided argument is a callback function used to calculate if two sprites are colliding.</p>
</blockquote>
<p>Possible <code>collided</code> callables are <a href=""https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.collide_rect"" rel=""nofollow noreferrer""><code>collide_rect</code></a>, <a href=""https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.collide_rect_ratio"" rel=""nofollow noreferrer""><code>collide_rect_ratio</code></a>, <a href=""https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.collide_circle"" rel=""nofollow noreferrer""><code>collide_circle</code></a>, <a href=""https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.collide_circle_ratio"" rel=""nofollow noreferrer""><code>collide_circle_ratio</code></a>, <a href=""https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.collide_mask"" rel=""nofollow noreferrer""><code>collide_mask</code></a></p>
<p>Some examples:</p>
<ul>
<li><p><a href=""https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.spritecollide"" rel=""nofollow noreferrer""><code>pygame.sprite.spritecollide()</code></a></p>
<p><kbd><a href=""https://repl.it/@Rabbid76/PyGame-spritecollide#main.py"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5jD0C.png"" alt="""" /> repl.it/@Rabbid76/PyGame-spritecollide</a></kbd></p>
<p><a href=""https://i.stack.imgur.com/3DdjL.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/3DdjL.gif"" alt="""" /></a></p>
<pre class=""lang-py prettyprint-override""><code>import pygame

pygame.init()
window = pygame.display.set_mode((250, 250))

sprite1 = pygame.sprite.Sprite()
sprite1.image = pygame.Surface((75, 75))
sprite1.image.fill((255, 0, 0))
sprite1.rect = pygame.Rect(*window.get_rect().center, 0, 0).inflate(75, 75)
sprite2 = pygame.sprite.Sprite()
sprite2.image = pygame.Surface((75, 75))
sprite2.image.fill((0, 255, 0))
sprite2.rect = pygame.Rect(*window.get_rect().center, 0, 0).inflate(75, 75)

all_group = pygame.sprite.Group([sprite2, sprite1])
test_group = pygame.sprite.Group(sprite2)

run = True
while run:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False

    sprite1.rect.center = pygame.mouse.get_pos()
    collide = pygame.sprite.spritecollide(sprite1, test_group, False)

    window.fill(0)
    all_group.draw(window)
    for s in collide:
        pygame.draw.rect(window, (255, 255, 255), s.rect, 5, 1)
    pygame.display.flip()

pygame.quit()
exit()
</code></pre>
</li>
</ul>
<p>For a collision with masks, see <a href=""https://stackoverflow.com/questions/56043600/how-can-i-made-a-collision-mask/56045037#56045037"">How can I make a collision mask?</a> or <a href=""https://stackoverflow.com/questions/60077813/pygame-mask-collision/60078039#60078039"">Pygame mask collision</a></p>
<p>See also <a href=""https://github.com/Rabbid76/PyGameExamplesAndAnswers/blob/master/documentation/pygame/pygame_collision_and_intesection.md"" rel=""nofollow noreferrer"">Collision and Intersection</a></p>
<ul>
<li><p><a href=""https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.spritecollide"" rel=""nofollow noreferrer""><code>pygame.sprite.spritecollide()</code></a> / <a href=""https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.collide_circle"" rel=""nofollow noreferrer""><code>collide_circle</code></a></p>
<p><kbd><a href=""https://repl.it/@Rabbid76/PyGame-spritecollidecollidecircle#main.py"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5jD0C.png"" alt="""" /> repl.it/@Rabbid76/PyGame-spritecollidecollidecircle</a></kbd></p>
<p><a href=""https://i.stack.imgur.com/SS1Pb.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/SS1Pb.gif"" alt="""" /></a></p>
<pre class=""lang-py prettyprint-override""><code>import pygame

pygame.init()
window = pygame.display.set_mode((250, 250))

sprite1 = pygame.sprite.Sprite()
sprite1.image = pygame.Surface((80, 80), pygame.SRCALPHA)
pygame.draw.circle(sprite1.image, (255, 0, 0), (40, 40), 40)
sprite1.rect = pygame.Rect(*window.get_rect().center, 0, 0).inflate(80, 80)
sprite1.radius = 40
sprite2 = pygame.sprite.Sprite()
sprite2.image = pygame.Surface((80, 89), pygame.SRCALPHA)
pygame.draw.circle(sprite2.image, (0, 255, 0), (40, 40), 40)
sprite2.rect = pygame.Rect(*window.get_rect().center, 0, 0).inflate(80, 80)
sprite2.radius = 40 

all_group = pygame.sprite.Group([sprite2, sprite1])
test_group = pygame.sprite.Group(sprite2)

run = True
while run:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False

    sprite1.rect.center = pygame.mouse.get_pos()
    collide = pygame.sprite.spritecollide(sprite1, test_group, False, pygame.sprite.collide_circle)

    window.fill(0)
    all_group.draw(window)
    for s in collide:
        pygame.draw.circle(window, (255, 255, 255), s.rect.center, s.rect.width // 2, 5)
    pygame.display.flip()

pygame.quit()
exit()
</code></pre>
</li>
</ul>
<hr />
<p>What does this all mean for your code?</p>
<p><a href=""https://www.pygame.org/docs/ref/surface.html#pygame.Surface.get_rect"" rel=""nofollow noreferrer""><code>pygame.Surface.get_rect.get_rect()</code></a> returns a rectangle with the size of the <em>Surface</em> object, that always starts at (0, 0) since a <em>Surface</em> object has no position. The position of the rectangle can be specified by a keyword argument. For example, the centre of the rectangle can be specified with the keyword argument <code>center</code>. These keyword arguments are applied to the attributes of the <a href=""https://www.pygame.org/docs/ref/rect.html"" rel=""nofollow noreferrer""><code>pygame.Rect</code></a> before it is returned (see <a href=""https://www.pygame.org/docs/ref/rect.html"" rel=""nofollow noreferrer""><code>pygame.Rect</code></a> for a list of the keyword arguments).<br />
See *<a href=""https://stackoverflow.com/questions/57730329/pygame-collide-rect-function-always-returning-true/57730378#57730378"">Why is my collision test always returning 'true' and why is the position of the rectangle of the image always wrong (0, 0)?</a></p>
<p>You do not need the <code>x</code> and <code>y</code> attributes of <code>Sprite</code> and <code>Bullet</code> at all. Use the position of the <code>rect</code> attribute instead:</p>
<pre class=""lang-py prettyprint-override""><code>#Define the sprite class
class Sprite:
    def __init__(self, x, y, name):
        self.image = pygame.image.load(name)
        self.rect = self.image.get_rect(topleft = (x, y))

    def render(self):
        window.blit(self.image, self.rect)

# Define the bullet class to create bullets          
class Bullet:
    def __init__(self, x, y):
        self.bullet = pygame.image.load(&quot;user_bullet.BMP&quot;)
        self.rect = self.bullet.get_rect(topleft = (x + 23, y))

    def render(self):
        window.blit(self.bullet, self.rect)
</code></pre>
<p>Use <a href=""https://www.pygame.org/docs/ref/rect.html#pygame.Rect.colliderect"" rel=""nofollow noreferrer""><code>pygame.Rect.colliderect()</code></a> to detect collisions between instances of <code>Sprite</code> and<code> Bullet</code>.<br />
See <a href=""https://stackoverflow.com/questions/63561028/how-to-detect-collision-between-two-images-in-pygame/63561152#63561152"">How to detect collisions between two rectangular objects or images in pygame</a>:</p>
<pre class=""lang-py prettyprint-override""><code>my_sprite = Sprite(sx, sy, name)
my_bullet = Bullet(by, by)
</code></pre>
<pre class=""lang-py prettyprint-override""><code>while True:
    # [...]

    if my_sprite.rect.colliderect(my_bullet.rect):
        printe(&quot;hit&quot;)
</code></pre>
"
36250354,"<p>This happens because your local module named <code>requests.py</code> shadows the installed <code>requests</code> module you are trying to use.  The current directory is prepended to <code>sys.path</code>, so the local name takes precedence over the installed name.</p>
<p>An extra debugging tip when this comes up is to look at the Traceback carefully, and realize that the name of your script in question is matching the module you are trying to import:</p>
<p>Notice the name you used in your script:</p>
<pre><code>File &quot;/Users/me/dev/rough/requests.py&quot;, line 1, in &lt;module&gt;
</code></pre>
<p>The module you are trying to import: <code>requests</code></p>
<p>Rename your module to something else to avoid the name collision.</p>
<p>Python may generate a <code>requests.pyc</code> file next to your <code>requests.py</code> file (in the <code>__pycache__</code> directory in Python 3).  Remove that as well after your rename, as the interpreter will still reference that file, re-producing the error. However, the <code>pyc</code> file in <code>__pycache__</code> <em>should</em> not affect your code if the <code>py</code> file has been removed.</p>
<p>In the example, renaming the file to <code>my_requests.py</code>, removing <code>requests.pyc</code>, and running again successfully prints <code>&lt;Response [200]&gt;</code>.</p>
<hr />
<p><em><strong>Note:</strong></em> This doesn't only happen when naming your file as the module you are trying to import. This can also happen if you name your file the same as a module imported by a module you import directly. For example, having a file called <em><strong><code>copy.py</code></strong></em> and trying to <code>import pandas</code> from there, will give</p>
<pre><code>ImportError: cannot import name 'copy' from 'copy'
</code></pre>
<p>That is because <code>pandas</code> imports <code>copy</code>. There is no magic solution here as you can't know all the modules' names in the world, but a rule of thumb is to try to make names of modules as unique as possible and try to change the name whenever you get such error.</p>
"
49775808,"<p>Once you wait for the element and moving forward as you are trying to invoke <code>click()</code> method instead of using <code>presence_of_element_located()</code> method you need to use <a href=""https://seleniumhq.github.io/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html#selenium.webdriver.support.expected_conditions.element_to_be_clickable"" rel=""noreferrer""><strong><code>element_to_be_clickable()</code></strong></a> as follows :</p>

<pre><code>try:
    myElem = WebDriverWait(self.browser, delay).until(EC.element_to_be_clickable((By.XPATH , xpath)))
</code></pre>

<hr>

<h2>Update</h2>

<p>As per your counter question in the comments here are the details of the three methods :</p>

<h2>presence_of_element_located</h2>

<p><a href=""https://seleniumhq.github.io/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html#selenium.webdriver.support.expected_conditions.presence_of_element_located"" rel=""noreferrer"">presence_of_element_located(locator)</a> is defined as follows :</p>

<pre><code>class selenium.webdriver.support.expected_conditions.presence_of_element_located(locator)

Parameter : locator - used to find the element returns the WebElement once it is located

Description : An expectation for checking that an element is present on the DOM of a page. This does not necessarily mean that the element is visible or interactable (i.e. clickable). 
</code></pre>

<h2>visibility_of_element_located</h2>

<p><a href=""https://seleniumhq.github.io/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html#selenium.webdriver.support.expected_conditions.visibility_of_element_located"" rel=""noreferrer"">visibility_of_element_located(locator)</a> is defined as follows :</p>

<pre><code>class selenium.webdriver.support.expected_conditions.visibility_of_element_located(locator)

Parameter : locator -  used to find the element returns the WebElement once it is located and visible

Description : An expectation for checking that an element is present on the DOM of a page and visible. Visibility means that the element is not only displayed but also has a height and width that is greater than 0.
</code></pre>

<h2>element_to_be_clickable</h2>

<p><a href=""https://seleniumhq.github.io/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html#selenium.webdriver.support.expected_conditions.element_to_be_clickable"" rel=""noreferrer"">element_to_be_clickable(locator)</a> is defined as follows :</p>

<pre><code>class selenium.webdriver.support.expected_conditions.element_to_be_clickable(locator)

Parameter : locator - used to find the element returns the WebElement once it is visible, enabled and interactable (i.e. clickable).

Description : An Expectation for checking an element is visible, enabled and interactable such that you can click it. 
</code></pre>
"
19960116,"<p>You can use <a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.isin.html"" rel=""noreferrer""><code>pd.Series.isin</code></a>.</p>
<p>For &quot;IN&quot; use: <code>something.isin(somewhere)</code></p>
<p>Or for &quot;NOT IN&quot;: <code>~something.isin(somewhere)</code></p>
<p>As a worked example:</p>
<pre><code>&gt;&gt;&gt; df
    country
0        US
1        UK
2   Germany
3     China
&gt;&gt;&gt; countries_to_keep
['UK', 'China']
&gt;&gt;&gt; df.country.isin(countries_to_keep)
0    False
1     True
2    False
3     True
Name: country, dtype: bool
&gt;&gt;&gt; df[df.country.isin(countries_to_keep)]
    country
1        UK
3     China
&gt;&gt;&gt; df[~df.country.isin(countries_to_keep)]
    country
0        US
2   Germany
</code></pre>
"
533917,"<p>Use <a href=""https://docs.python.org/3/library/itertools.html#itertools.product"" rel=""noreferrer""><code>itertools.product</code></a>, which has been available since Python 2.6.</p>
<pre><code>import itertools

somelists = [
   [1, 2, 3],
   ['a', 'b'],
   [4, 5]
]
for element in itertools.product(*somelists):
    print(element)
</code></pre>
<p>This is the same as:</p>
<pre><code>for element in itertools.product([1, 2, 3], ['a', 'b'], [4, 5]):
    print(element)
</code></pre>
"
2709832,"<p>The reason you need to use <code>self.</code> is because Python does not use special syntax to refer to instance attributes. Python decided to do methods in a way that makes the instance to which the method belongs be <em>passed</em> automatically, but not <em>received</em> automatically: the first parameter of methods is the instance the method is called on. That makes methods entirely the same as functions, and leaves the actual name to use up to you (although <code>self</code> is the convention, and people will generally frown at you when you use something else.) <code>self</code> is not special to the code, it's just another object.</p>
<p>Python could have done something else to distinguish normal names from attributes -- special syntax like Ruby has, or requiring declarations like C++ and Java do, or perhaps something  yet more different -- but it didn't. Python's all for making things explicit, making it obvious what's what, and although it doesn't do it entirely everywhere, it does do it for instance attributes. That's why assigning to an instance attribute needs to know what instance to assign to, and that's why it needs <code>self.</code>.</p>
"
6260097,"<p>You're modifying the list while you iterate over it. That means that the first time through the loop, <code>i == 1</code>, so 1 is removed from the list. Then the <code>for</code> loop goes to the second item in the list, which is not 2, but 3! Then that's removed from the list, and then the <code>for</code> loop goes on to the third item in the list, which is now 5. And so on. Perhaps it's easier to visualize like so, with a ^ pointing to the value of <code>i</code>:</p>

<pre><code>[1, 2, 3, 4, 5, 6...]
 ^
</code></pre>

<p>That's the state of the list initially; then 1 is removed and the loop goes to the second item in the list:</p>

<pre><code>[2, 3, 4, 5, 6...]
    ^
[2, 4, 5, 6...]
       ^
</code></pre>

<p>And so on. </p>

<p>There's no good way to alter a list's length while iterating over it. The best you can do is something like this:</p>

<pre><code>numbers = [n for n in numbers if n &gt;= 20]
</code></pre>

<p>or this, for in-place alteration (the thing in parens is a generator expression, which is implicitly converted into a tuple before slice-assignment):</p>

<pre><code>numbers[:] = (n for in in numbers if n &gt;= 20)
</code></pre>

<p>If you want to perform an operation on n before removing it, one trick you could try is this:</p>

<pre><code>for i, n in enumerate(numbers):
    if n &lt; 20 :
        print(""do something"")
        numbers[i] = None
numbers = [n for n in numbers if n is not None]
</code></pre>
"
48056120,"<p>This question have been asked and answered in numerous forums in different formats. Considering them all if we prioritize the locators the list would be as follows :</p>
<ul>
<li><strong>id</strong>: Select element with the specified <code>id</code> attribute.</li>
<li><strong>name</strong>: Select first element with the specified <code>name</code> attribute.</li>
<li><strong>link_text</strong>: Select link (anchor tag) element which contains <em>text</em> matching the specified <code>LinkText</code>.</li>
<li><strong>partial_link_text</strong>: Select link (anchor tag) element which contains <em>text</em> matching the specified <code>PartialLinkText</code>.</li>
<li><strong>tag_name</strong>: Locate Element using a <code>Tag Name</code>.</li>
<li><strong>class_name</strong>: Locate Element using a <code>ClassName</code>.</li>
<li><strong>css_selector</strong>: Select the element using <code>CssSelectors</code>.</li>
<li><strong>xpath</strong>: Locate an element using an <code>XPath</code> expression.</li>
</ul>
<p>So the question now is <strong>Whats New</strong>?</p>
<p>The answer is <strong>Selenium have evolved a lot recently</strong>. <strong><code>WebDriver</code></strong> is now a <a href=""https://www.w3.org/TR/webdriver/"" rel=""nofollow noreferrer""><strong><code>W3C Recommendation Candidate</code></strong></a>. Things within <code>Selenium</code> are changing pretty fast. It's no more only about choosing the locator. We need to use a locator which will :</p>
<ul>
<li><em>Uniquely identify an element</em>.</li>
<li><em>The performance of the locator must be optimized.</em></li>
</ul>
<p>Keeping these two factors in mind, the best strategy would be to <strong>Mock the DOM</strong>. The <a href=""https://www.w3.org/TR/webdriver/#locator-strategies"" rel=""nofollow noreferrer""><strong><code>W3C Recommendation Candidate</code></strong></a> does mentions the list of the locators as per the below :</p>
<p><a href=""https://i.stack.imgur.com/ZTq7X.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZTq7X.png"" alt=""Selenium_Locators"" /></a></p>
<p>So the verdict is clear and concise.</p>
"
394814,"<p>Yes, it was <a href=""https://mail.python.org/pipermail/python-dev/2005-September/056846.html"" rel=""noreferrer"" title=""[Python-Dev] Conditional Expression Resolution"">added</a> in version 2.5. The expression syntax is:</p>
<pre class=""lang-py prettyprint-override""><code>a if condition else b
</code></pre>
<p>First <code>condition</code> is evaluated, then exactly one of either <code>a</code> or <code>b</code> is evaluated and returned based on the <a href=""https://en.wikipedia.org/wiki/Boolean_data_type"" rel=""noreferrer"" title=""Boolean data type"">Boolean</a> value of <code>condition</code>. If <code>condition</code> evaluates to <code>True</code>, then <code>a</code> is evaluated and returned but <code>b</code> is ignored, or else when <code>b</code> is evaluated and returned but <code>a</code> is ignored.</p>
<p>This allows short-circuiting because when <code>condition</code> is true only <code>a</code> is evaluated and <code>b</code> is not evaluated at all, but when <code>condition</code> is false only <code>b</code> is evaluated and <code>a</code> is not evaluated at all.</p>
<p>For example:</p>
<pre class=""lang-py prettyprint-override""><code>&gt;&gt;&gt; 'true' if True else 'false'
'true'
&gt;&gt;&gt; 'true' if False else 'false'
'false'
</code></pre>
<p>Note that conditionals are an <em>expression</em>, not a <em>statement</em>. This means you can't use <strong>statements</strong> such as <code>pass</code>, or assignments with <code>=</code> (or &quot;augmented&quot; assignments like <code>+=</code>), within a conditional <strong>expression</strong>:</p>
<pre class=""lang-py prettyprint-override""><code>&gt;&gt;&gt; pass if False else pass
  File &quot;&lt;stdin&gt;&quot;, line 1
    pass if False else pass
         ^
SyntaxError: invalid syntax

&gt;&gt;&gt; # Python parses this as `x = (1 if False else y) = 2`
&gt;&gt;&gt; # The `(1 if False else x)` part is actually valid, but
&gt;&gt;&gt; # it can't be on the left-hand side of `=`.
&gt;&gt;&gt; x = 1 if False else y = 2
  File &quot;&lt;stdin&gt;&quot;, line 1
SyntaxError: cannot assign to conditional expression

&gt;&gt;&gt; # If we parenthesize it instead...
&gt;&gt;&gt; (x = 1) if False else (y = 2)
  File &quot;&lt;stdin&gt;&quot;, line 1
    (x = 1) if False else (y = 2)
       ^
SyntaxError: invalid syntax
</code></pre>
<p>(In 3.8 and above, the <code>:=</code> &quot;walrus&quot; operator allows simple assignment of values <em>as an expression</em>, which is then compatible with this syntax. But please don't write code like that; it will quickly become very difficult to understand.)</p>
<p>Similarly, because it is an expression, the <code>else</code> part is <em>mandatory</em>:</p>
<pre><code># Invalid syntax: we didn't specify what the value should be if the 
# condition isn't met. It doesn't matter if we can verify that
# ahead of time.
a if True
</code></pre>
<p>You can, however, use conditional expressions to assign a variable like so:</p>
<pre class=""lang-py prettyprint-override""><code>x = a if True else b
</code></pre>
<p>Or for example to return a value:</p>
<pre><code># Of course we should just use the standard library `max`;
# this is just for demonstration purposes.
def my_max(a, b):
    return a if a &gt; b else b
</code></pre>
<p>Think of the conditional expression as switching between two values. We can use it when we are in a 'one value or another' situation, where we will <em>do the same thing</em> with the result, regardless of whether the condition is met. We use the expression to compute the value, and then do something with it. If you need to <em>do something different</em> depending on the condition, then use a normal <code>if</code> <strong>statement</strong> instead.</p>
<hr />
<p>Keep in mind that it's frowned upon by some Pythonistas for several reasons:</p>
<ul>
<li>The order of the arguments is different from those of the classic <code>condition ? a : b</code> ternary operator from many other languages (such as <a href=""https://en.wikipedia.org/wiki/C_%28programming_language%29"" rel=""noreferrer"">C</a>, <a href=""https://en.wikipedia.org/wiki/C%2B%2B"" rel=""noreferrer"">C++</a>, <a href=""https://en.wikipedia.org/wiki/Go_%28programming_language%29"" rel=""noreferrer"">Go</a>, <a href=""https://en.wikipedia.org/wiki/Perl"" rel=""noreferrer"">Perl</a>, <a href=""https://en.wikipedia.org/wiki/Ruby_%28programming_language%29"" rel=""noreferrer"">Ruby</a>, <a href=""https://en.wikipedia.org/wiki/Java_%28programming_language%29"" rel=""noreferrer"">Java</a>, <a href=""https://en.wikipedia.org/wiki/JavaScript"" rel=""noreferrer"">JavaScript</a>, etc.), which may lead to bugs when people unfamiliar with Python's &quot;surprising&quot; behaviour use it (they may reverse the argument order).</li>
<li>Some find it &quot;unwieldy&quot;, since it goes contrary to the normal flow of thought (thinking of the condition first and then the effects).</li>
<li>Stylistic reasons. (Although the 'inline <code>if</code>' can be <em>really</em> useful, and make your script more concise, it really does complicate your code)</li>
</ul>
<p>If you're having trouble remembering the order, then remember that when read aloud, you (almost) say what you mean. For example, <code>x = 4 if b &gt; 8 else 9</code> is read aloud as <code>x will be 4 if b is greater than 8 otherwise 9</code>.</p>
<p>Official documentation:</p>
<ul>
<li><a href=""https://docs.python.org/3/reference/expressions.html#conditional-expressions"" rel=""noreferrer"" title=""Conditional expressions"">Conditional expressions</a></li>
<li><a href=""https://docs.python.org/3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator"" rel=""noreferrer"" title=""Is there an equivalent of Câs â?:â ternary operator?"">Is there an equivalent of Câs â?:â ternary operator?</a></li>
</ul>
"
36922103,"<p>The <code>or</code> and <code>and</code> Python statements require <strong>truth</strong>-values. For pandas, these are considered ambiguous, so you should use &quot;bitwise&quot; <code>|</code> (or) or <code>&amp;</code> (and) operations:</p>
<pre><code>df = df[(df['col'] &lt; -0.25) | (df['col'] &gt; 0.25)]
</code></pre>
<p>These are overloaded for these kinds of data structures to yield the element-wise <code>or</code> or <code>and</code>.</p>
<hr />
<p>Just to add some more explanation to this statement:</p>
<p>The exception is thrown when you want to get the <code>bool</code> of a <code>pandas.Series</code>:</p>
<pre><code>&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; x = pd.Series([1])
&gt;&gt;&gt; bool(x)
ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
</code></pre>
<p>You hit a place where the operator <strong>implicitly</strong> converted the operands to <code>bool</code> (you used <code>or</code> but it also happens for <code>and</code>, <code>if</code> and <code>while</code>):</p>
<pre><code>&gt;&gt;&gt; x or x
ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
&gt;&gt;&gt; x and x
ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
&gt;&gt;&gt; if x:
...     print('fun')
ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
&gt;&gt;&gt; while x:
...     print('fun')
ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
</code></pre>
<p>Besides these four statements, there are several Python functions that hide some <code>bool</code> calls (like <code>any</code>, <code>all</code>, <code>filter</code>, ...). These are normally not problematic with <code>pandas.Series</code>, but for completeness I wanted to mention these.</p>
<hr />
<p>In your case, the exception isn't really helpful, because it doesn't mention the <strong>right alternatives</strong>. For <code>and</code> and <code>or</code>, if you want element-wise comparisons, you can use:</p>
<ul>
<li><p><a href=""https://docs.scipy.org/doc/numpy/reference/generated/numpy.logical_or.html"" rel=""noreferrer""><code>numpy.logical_or</code></a>:</p>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; np.logical_or(x, y)
</code></pre>
<p>or simply the <code>|</code> operator:</p>
<pre><code>&gt;&gt;&gt; x | y
</code></pre>
</li>
<li><p><a href=""https://docs.scipy.org/doc/numpy/reference/generated/numpy.logical_and.html"" rel=""noreferrer""><code>numpy.logical_and</code></a>:</p>
<pre><code>&gt;&gt;&gt; np.logical_and(x, y)
</code></pre>
<p>or simply the <code>&amp;</code> operator:</p>
<pre><code>&gt;&gt;&gt; x &amp; y
</code></pre>
</li>
</ul>
<p>If you're using the operators, then be sure to set your parentheses correctly because of <a href=""https://docs.python.org/reference/expressions.html#operator-precedence"" rel=""noreferrer"">operator precedence</a>.</p>
<p>There are <a href=""https://docs.scipy.org/doc/numpy/reference/routines.logic.html"" rel=""noreferrer"">several logical NumPy functions</a> which <em>should</em> work on <code>pandas.Series</code>.</p>
<hr />
<p>The alternatives mentioned in the Exception are more suited if you encountered it when doing <code>if</code> or <code>while</code>. I'll shortly explain each of these:</p>
<ul>
<li><p>If you want to check if your Series is <strong>empty</strong>:</p>
<pre><code>&gt;&gt;&gt; x = pd.Series([])
&gt;&gt;&gt; x.empty
True
&gt;&gt;&gt; x = pd.Series([1])
&gt;&gt;&gt; x.empty
False
</code></pre>
<p>Python normally interprets the <code>len</code>gth of containers (like <code>list</code>, <code>tuple</code>, ...) as truth-value if it has no explicit Boolean interpretation. So if you want the Python-like check, you could do: <code>if x.size</code> or <code>if not x.empty</code> instead of <code>if x</code>.</p>
</li>
<li><p>If your <code>Series</code> contains <strong>one and only one</strong> Boolean value:</p>
<pre><code>&gt;&gt;&gt; x = pd.Series([100])
&gt;&gt;&gt; (x &gt; 50).bool()
True
&gt;&gt;&gt; (x &lt; 50).bool()
False
</code></pre>
</li>
<li><p>If you want to check the <strong>first and only item</strong> of your Series (like <code>.bool()</code>, but it works even for non-Boolean contents):</p>
<pre><code>&gt;&gt;&gt; x = pd.Series([100])
&gt;&gt;&gt; x.item()
100
</code></pre>
</li>
<li><p>If you want to check if <strong>all</strong> or <strong>any</strong> item is not-zero, not-empty or not-False:</p>
<pre><code>&gt;&gt;&gt; x = pd.Series([0, 1, 2])
&gt;&gt;&gt; x.all()   # Because one element is zero
False
&gt;&gt;&gt; x.any()   # because one (or more) elements are non-zero
True
</code></pre>
</li>
</ul>
"
14132912,"<p><strong>Script vs. Module</strong></p>
<p>Here's an explanation.  The short version is that there is a big difference between directly running a Python file, and importing that file from somewhere else.  <strong>Just knowing what directory a file is in does not determine what package Python thinks it is in.</strong>  That depends, additionally, on how you load the file into Python (by running or by importing).</p>
<p>There are two ways to load a Python file: as the top-level script, or as a
module.  A file is loaded as the top-level script if you execute it directly, for instance by typing <code>python myfile.py</code> on the command line.  It is loaded as a module when an <code>import</code> statement is encountered inside some other file.  There can only be one top-level script at a time; the top-level script is the Python file you ran to start things off.</p>
<p><strong>Naming</strong></p>
<p>When a file is loaded, it is given a name (which is stored in its <code>__name__</code> attribute).</p>
<ul>
<li>If it was loaded as the top-level script, its name is <code>__main__</code>.</li>
<li>If it was loaded as a module, its name is [ the filename, preceded by the names of any packages/subpackages of which it is a part, separated by dots ], for example, <code>package.subpackage1.moduleX</code>.</li>
</ul>
<p>But be aware, if you load <code>moduleX</code> as a module from shell command line using something like <code>python -m package.subpackage1.moduleX</code>, the <code>__name__</code> will still be <code>__main__</code>.</p>
<p>So for instance in your example:</p>
<pre><code>package/
    __init__.py
    subpackage1/
        __init__.py
        moduleX.py
    moduleA.py
</code></pre>
<p>if you imported <code>moduleX</code> (note: <em>imported</em>, not directly executed), its name would be <code>package.subpackage1.moduleX</code>.  If you imported <code>moduleA</code>, its name would be <code>package.moduleA</code>.  However, if you <em>directly run</em> <code>moduleX</code> from the command line, its name will instead be <code>__main__</code>, and if you directly run <code>moduleA</code> from the command line, its name will be <code>__main__</code>.  When a module is run as the top-level script, it loses its normal name and its name is instead <code>__main__</code>.</p>
<p><strong>Accessing a module NOT through its containing package</strong></p>
<p>There is an additional wrinkle: the module's name depends on whether it was imported &quot;directly&quot; from the directory it is in or imported via a package.  This only makes a difference if you run Python in a directory, and try to import a file in that same directory (or a subdirectory of it).  For instance, if you start the Python interpreter in the directory <code>package/subpackage1</code> and then do <code>import moduleX</code>, the name of <code>moduleX</code> will just be <code>moduleX</code>, and not <code>package.subpackage1.moduleX</code>.  This is because Python adds the current directory to its search path when the interpreter is entered interactively; if it finds the to-be-imported module in the current directory, it will not know that that directory is part of a package, and the package information will not become part of the module's name.</p>
<p>A special case is if you run the interpreter interactively (e.g., just type <code>python</code> and start entering Python code on the fly).  In this case, the name of that interactive session is <code>__main__</code>.</p>
<p>Now here is the crucial thing for your error message: <strong>if a module's name has no dots, it is not considered to be part of a package</strong>.  It doesn't matter where the file actually is on disk.  All that matters is what its name is, and its name depends on how you loaded it.</p>
<p>Now look at the quote you included in your question:</p>
<blockquote>
<p>Relative imports use a module's name attribute to determine that module's position in the package hierarchy. If the module's name does not contain any package information (e.g. it is set to 'main') then relative imports are resolved as if the module were a top-level module, regardless of where the module is actually located on the file system.</p>
</blockquote>
<p><strong>Relative imports...</strong></p>
<p>Relative imports use the module's <em>name</em> to determine where it is in a package.  When you use a relative import like <code>from .. import foo</code>, the dots indicate to step up some number of levels in the package hierarchy.  For instance, if your current module's name is <code>package.subpackage1.moduleX</code>, then <code>..moduleA</code> would mean <code>package.moduleA</code>.  For a <code>from .. import</code> to work, the module's name must have at least as many dots as there are in the <code>import</code> statement.</p>
<p><strong>... are only relative in a package</strong></p>
<p>However, if your module's name is <code>__main__</code>, it is not considered to be in a package.  Its name has no dots, and therefore you cannot use <code>from .. import</code> statements inside it.  If you try to do so, you will get the &quot;relative-import in non-package&quot; error.</p>
<p><strong>Scripts can't import relative</strong></p>
<p>What you probably did is you tried to run <code>moduleX</code> or the like from the command line.  When you did this, its name was set to <code>__main__</code>, which means that relative imports within it will fail, because its name does not reveal that it is in a package. Note that this will also happen if you run Python from the same directory where a module is, and then try to import that module, because, as described above, Python will find the module in the current directory &quot;too early&quot; without realizing it is part of a package.</p>
<p>Also remember that when you run the interactive interpreter, the &quot;name&quot; of that interactive session is always <code>__main__</code>.  Thus <strong>you cannot do relative imports directly from an interactive session</strong>.  Relative imports are only for use within module files.</p>
<p><strong>Two solutions:</strong></p>
<ol>
<li><p>If you really do want to run <code>moduleX</code> directly, but you still want it to be considered part of a package, you can do <code>python -m package.subpackage1.moduleX</code>.  The <code>-m</code> tells Python to load it as a module, not as the top-level script.</p>
</li>
<li><p>Or perhaps you don't actually want to <em>run</em> <code>moduleX</code>, you just want to run some other script, say <code>myfile.py</code>, that <em>uses</em> functions inside <code>moduleX</code>.  If that is the case, put <code>myfile.py</code> <em>somewhere else</em> â <em>not</em> inside the <code>package</code> directory â and run it.  If inside <code>myfile.py</code> you do things like <code>from package.moduleA import spam</code>, it will work fine.</p>
</li>
</ol>
<p><strong>Notes</strong></p>
<ul>
<li><p>For either of these solutions, the package directory (<code>package</code> in your example) must be accessible from the Python module search path (<code>sys.path</code>).  If it is not, you will not be able to use anything in the package reliably at all.</p>
</li>
<li><p>Since Python 2.6, the module's &quot;name&quot; for package-resolution purposes is determined not just by its <code>__name__</code> attributes but also by the <code>__package__</code> attribute.  That's why I'm avoiding using the explicit symbol <code>__name__</code> to refer to the module's &quot;name&quot;.  Since Python 2.6 a module's &quot;name&quot; is effectively <code>__package__ + '.' + __name__</code>, or just <code>__name__</code> if <code>__package__</code> is <code>None</code>.)</p>
</li>
</ul>
"
306353,"<p>Take a look at this:</p>
<pre><code>&gt;&gt;&gt; a = 256
&gt;&gt;&gt; b = 256
&gt;&gt;&gt; id(a) == id(b)
True
&gt;&gt;&gt; a = 257
&gt;&gt;&gt; b = 257
&gt;&gt;&gt; id(a) == id(b)
False
</code></pre>
<p>Here's what I found in the documentation for <a href=""https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong"" rel=""nofollow noreferrer"">&quot;Plain Integer Objects&quot;</a>:</p>
<blockquote>
<p>The current implementation keeps an array of integer objects for all integers between <code>-5</code> and <code>256</code>. When you create an int in that range you actually just get back a reference to the existing object.</p>
</blockquote>
<p>So, integers 256 are <a href=""https://docs.python.org/3/library/functions.html#id"" rel=""nofollow noreferrer"">identical</a>, but 257 are not. This is a CPython implementation detail, and not guaranteed for other Python implementations.</p>
"
26853961,"<h2>How can I merge two Python dictionaries in a single expression?</h2>
<p>For dictionaries <code>x</code> and <code>y</code>, their shallowly-merged dictionary <code>z</code> takes values from <code>y</code>, replacing those from <code>x</code>.</p>
<ul>
<li><p>In Python 3.9.0 or greater (released 17 October 2020, <a href=""https://www.python.org/dev/peps/pep-0584/"" rel=""noreferrer""><code>PEP-584</code></a>, <a href=""https://bugs.python.org/issue36144"" rel=""noreferrer"">discussed here</a>):</p>
<pre class=""lang-py prettyprint-override""><code>z = x | y
</code></pre>
</li>
<li><p>In Python 3.5 or greater:</p>
<pre class=""lang-py prettyprint-override""><code>z = {**x, **y}
</code></pre>
</li>
<li><p>In Python 2, (or 3.4 or lower) write a function:</p>
<pre class=""lang-py prettyprint-override""><code>def merge_two_dicts(x, y):
    z = x.copy()   # start with keys and values of x
    z.update(y)    # modifies z with keys and values of y
    return z
</code></pre>
<p>and now:</p>
<pre class=""lang-py prettyprint-override""><code>z = merge_two_dicts(x, y)
</code></pre>
</li>
</ul>
<h3>Explanation</h3>
<p>Say you have two dictionaries and you want to merge them into a new dictionary without altering the original dictionaries:</p>
<pre class=""lang-py prettyprint-override""><code>x = {'a': 1, 'b': 2}
y = {'b': 3, 'c': 4}
</code></pre>
<p>The desired result is to get a new dictionary (<code>z</code>) with the values merged, and the second dictionary's values overwriting those from the first.</p>
<pre class=""lang-py prettyprint-override""><code>&gt;&gt;&gt; z
{'a': 1, 'b': 3, 'c': 4}
</code></pre>
<p>A new syntax for this, proposed in <a href=""https://www.python.org/dev/peps/pep-0448"" rel=""noreferrer"">PEP 448</a> and <a href=""https://mail.python.org/pipermail/python-dev/2015-February/138564.html"" rel=""noreferrer"">available as of Python 3.5</a>, is</p>
<pre class=""lang-py prettyprint-override""><code>z = {**x, **y}
</code></pre>
<p>And it is indeed a single expression.</p>
<p>Note that we can merge in with literal notation as well:</p>
<pre class=""lang-py prettyprint-override""><code>z = {**x, 'foo': 1, 'bar': 2, **y}
</code></pre>
<p>and now:</p>
<pre class=""lang-py prettyprint-override""><code>&gt;&gt;&gt; z
{'a': 1, 'b': 3, 'foo': 1, 'bar': 2, 'c': 4}
</code></pre>
<p>It is now showing as implemented in the <a href=""https://www.python.org/dev/peps/pep-0478/#features-for-3-5"" rel=""noreferrer"">release schedule for 3.5, PEP 478</a>, and it has now made its way into the <a href=""https://docs.python.org/dev/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations"" rel=""noreferrer"">What's New in Python 3.5</a> document.</p>
<p>However, since many organizations are still on Python 2, you may wish to do this in a backward-compatible way. The classically Pythonic way, available in Python 2 and Python 3.0-3.4, is to do this as a two-step process:</p>
<pre class=""lang-py prettyprint-override""><code>z = x.copy()
z.update(y) # which returns None since it mutates z
</code></pre>
<p>In both approaches, <code>y</code> will come second and its values will replace <code>x</code>'s values, thus <code>b</code> will point to <code>3</code> in our final result.</p>
<h2>Not yet on Python 3.5, but want a <em>single expression</em></h2>
<p>If you are not yet on Python 3.5 or need to write backward-compatible code, and you want this in a <em>single expression</em>, the most performant while the correct approach is to put it in a function:</p>
<pre class=""lang-py prettyprint-override""><code>def merge_two_dicts(x, y):
    &quot;&quot;&quot;Given two dictionaries, merge them into a new dict as a shallow copy.&quot;&quot;&quot;
    z = x.copy()
    z.update(y)
    return z
</code></pre>
<p>and then you have a single expression:</p>
<pre class=""lang-py prettyprint-override""><code>z = merge_two_dicts(x, y)
</code></pre>
<p>You can also make a function to merge an arbitrary number of dictionaries, from zero to a very large number:</p>
<pre class=""lang-py prettyprint-override""><code>def merge_dicts(*dict_args):
    &quot;&quot;&quot;
    Given any number of dictionaries, shallow copy and merge into a new dict,
    precedence goes to key-value pairs in latter dictionaries.
    &quot;&quot;&quot;
    result = {}
    for dictionary in dict_args:
        result.update(dictionary)
    return result
</code></pre>
<p>This function will work in Python 2 and 3 for all dictionaries. e.g. given dictionaries <code>a</code> to <code>g</code>:</p>
<pre class=""lang-py prettyprint-override""><code>z = merge_dicts(a, b, c, d, e, f, g) 
</code></pre>
<p>and key-value pairs in <code>g</code> will take precedence over dictionaries <code>a</code> to <code>f</code>, and so on.</p>
<h2>Critiques of Other Answers</h2>
<p>Don't use what you see in the formerly accepted answer:</p>
<pre class=""lang-py prettyprint-override""><code>z = dict(x.items() + y.items())
</code></pre>
<p>In Python 2, you create two lists in memory for each dict, create a third list in memory with length equal to the length of the first two put together, and then discard all three lists to create the dict. <strong>In Python 3, this will fail</strong> because you're adding two <code>dict_items</code> objects together, not two lists -</p>
<pre class=""lang-py prettyprint-override""><code>&gt;&gt;&gt; c = dict(a.items() + b.items())
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: 'dict_items' and 'dict_items'
</code></pre>
<p>and you would have to explicitly create them as lists, e.g. <code>z = dict(list(x.items()) + list(y.items()))</code>. This is a waste of resources and computation power.</p>
<p>Similarly, taking the union of <code>items()</code> in Python 3 (<code>viewitems()</code> in Python 2.7) will also fail when values are unhashable objects (like lists, for example). Even if your values are hashable, <strong>since sets are semantically unordered, the behavior is undefined in regards to precedence. So don't do this:</strong></p>
<pre class=""lang-py prettyprint-override""><code>&gt;&gt;&gt; c = dict(a.items() | b.items())
</code></pre>
<p>This example demonstrates what happens when values are unhashable:</p>
<pre class=""lang-py prettyprint-override""><code>&gt;&gt;&gt; x = {'a': []}
&gt;&gt;&gt; y = {'b': []}
&gt;&gt;&gt; dict(x.items() | y.items())
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'
</code></pre>
<p>Here's an example where <code>y</code> should have precedence, but instead the value from <code>x</code> is retained due to the arbitrary order of sets:</p>
<pre class=""lang-py prettyprint-override""><code>&gt;&gt;&gt; x = {'a': 2}
&gt;&gt;&gt; y = {'a': 1}
&gt;&gt;&gt; dict(x.items() | y.items())
{'a': 2}
</code></pre>
<p>Another hack you should not use:</p>
<pre class=""lang-py prettyprint-override""><code>z = dict(x, **y)
</code></pre>
<p>This uses the <code>dict</code> constructor and is very fast and memory-efficient (even slightly more so than our two-step process) but unless you know precisely what is happening here (that is, the second dict is being passed as keyword arguments to the dict constructor), it's difficult to read, it's not the intended usage, and so it is not Pythonic.</p>
<p>Here's an example of the usage being <a href=""https://code.djangoproject.com/attachment/ticket/13357/django-pypy.2.diff"" rel=""noreferrer"">remediated in django</a>.</p>
<p>Dictionaries are intended to take hashable keys (e.g. <code>frozenset</code>s or tuples), but <strong>this method fails in Python 3 when keys are not strings.</strong></p>
<pre class=""lang-py prettyprint-override""><code>&gt;&gt;&gt; c = dict(a, **b)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: keyword arguments must be strings
</code></pre>
<p>From the <a href=""https://mail.python.org/pipermail/python-dev/2010-April/099459.html"" rel=""noreferrer"">mailing list</a>, Guido van Rossum, the creator of the language, wrote:</p>
<blockquote>
<p>I am fine with
declaring dict({}, **{1:3}) illegal, since after all it is abuse of
the ** mechanism.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>Apparently dict(x, **y) is going around as &quot;cool hack&quot; for &quot;call
x.update(y) and return x&quot;. Personally, I find it more despicable than
cool.</p>
</blockquote>
<p>It is my understanding (as well as the understanding of the <a href=""https://mail.python.org/pipermail/python-dev/2010-April/099485.html"" rel=""noreferrer"">creator of the language</a>) that the intended usage for <code>dict(**y)</code> is for creating dictionaries for readability purposes, e.g.:</p>
<pre class=""lang-py prettyprint-override""><code>dict(a=1, b=10, c=11)
</code></pre>
<p>instead of</p>
<pre class=""lang-py prettyprint-override""><code>{'a': 1, 'b': 10, 'c': 11}
</code></pre>
<h2>Response to comments</h2>
<blockquote>
<p>Despite what Guido says, <code>dict(x, **y)</code> is in line with the dict specification, which btw. works for both Python 2 and 3. The fact that this only works for string keys is a direct consequence of how keyword parameters work and not a short-coming of dict. Nor is using the ** operator in this place an abuse of the mechanism, in fact, ** was designed precisely to pass dictionaries as keywords.</p>
</blockquote>
<p>Again, it doesn't work for 3 when keys are not strings. The implicit calling contract is that namespaces take ordinary dictionaries, while users must only pass keyword arguments that are strings. All other callables enforced it. <code>dict</code> broke this consistency in Python 2:</p>
<pre><code>&gt;&gt;&gt; foo(**{('a', 'b'): None})
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: foo() keywords must be strings
&gt;&gt;&gt; dict(**{('a', 'b'): None})
{('a', 'b'): None}
</code></pre>
<p>This inconsistency was bad given other implementations of Python (PyPy, Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a breaking change.</p>
<p>I submit to you that it is malicious incompetence to intentionally write code that only works in one version of a language or that only works given certain arbitrary constraints.</p>
<p>More comments:</p>
<blockquote>
<p><code>dict(x.items() + y.items())</code> is still the most readable solution for Python 2. Readability counts.</p>
</blockquote>
<p>My response: <code>merge_two_dicts(x, y)</code> actually seems much clearer to me, if we're actually concerned about readability. And it is not forward compatible, as Python 2 is increasingly deprecated.</p>
<blockquote>
<p><code>{**x, **y}</code> does not seem to handle nested dictionaries. the contents of nested keys are simply overwritten, not merged [...] I ended up being burnt by these answers that do not merge recursively and I was surprised no one mentioned it. In my interpretation of the word &quot;merging&quot; these answers describe &quot;updating one dict with another&quot;, and not merging.</p>
</blockquote>
<p>Yes. I must refer you back to the question, which is asking for a <em>shallow</em> merge of <em><strong>two</strong></em> dictionaries, with the first's values being overwritten by the second's - in a single expression.</p>
<p>Assuming two dictionaries of dictionaries, one might recursively merge them in a single function, but you should be careful not to modify the dictionaries from either source, and the surest way to avoid that is to make a copy when assigning values. As keys must be hashable and are usually therefore immutable, it is pointless to copy them:</p>
<pre class=""lang-py prettyprint-override""><code>from copy import deepcopy

def dict_of_dicts_merge(x, y):
    z = {}
    overlapping_keys = x.keys() &amp; y.keys()
    for key in overlapping_keys:
        z[key] = dict_of_dicts_merge(x[key], y[key])
    for key in x.keys() - overlapping_keys:
        z[key] = deepcopy(x[key])
    for key in y.keys() - overlapping_keys:
        z[key] = deepcopy(y[key])
    return z
</code></pre>
<p>Usage:</p>
<pre class=""lang-py prettyprint-override""><code>&gt;&gt;&gt; x = {'a':{1:{}}, 'b': {2:{}}}
&gt;&gt;&gt; y = {'b':{10:{}}, 'c': {11:{}}}
&gt;&gt;&gt; dict_of_dicts_merge(x, y)
{'b': {2: {}, 10: {}}, 'a': {1: {}}, 'c': {11: {}}}
</code></pre>
<p>Coming up with contingencies for other value types is far beyond the scope of this question, so I will point you at <a href=""https://stackoverflow.com/a/24088493/541136"">my answer to the canonical question on a &quot;Dictionaries of dictionaries merge&quot;</a>.</p>
<h2>Less Performant But Correct Ad-hocs</h2>
<p>These approaches are less performant, but they will provide correct behavior.
They will be <em>much less</em> performant than <code>copy</code> and <code>update</code> or the new unpacking because they iterate through each key-value pair at a higher level of abstraction, but they <em>do</em> respect the order of precedence (latter dictionaries have precedence)</p>
<p>You can also chain the dictionaries manually inside a <a href=""https://www.python.org/dev/peps/pep-0274/"" rel=""noreferrer"">dict comprehension</a>:</p>
<pre class=""lang-py prettyprint-override""><code>{k: v for d in dicts for k, v in d.items()} # iteritems in Python 2.7
</code></pre>
<p>or in Python 2.6 (and perhaps as early as 2.4 when generator expressions were introduced):</p>
<pre class=""lang-py prettyprint-override""><code>dict((k, v) for d in dicts for k, v in d.items()) # iteritems in Python 2
</code></pre>
<p><code>itertools.chain</code> will chain the iterators over the key-value pairs in the correct order:</p>
<pre class=""lang-py prettyprint-override""><code>from itertools import chain
z = dict(chain(x.items(), y.items())) # iteritems in Python 2
</code></pre>
<h2>Performance Analysis</h2>
<p>I'm only going to do the performance analysis of the usages known to behave correctly. (Self-contained so you can copy and paste yourself.)</p>
<pre class=""lang-py prettyprint-override""><code>from timeit import repeat
from itertools import chain

x = dict.fromkeys('abcdefg')
y = dict.fromkeys('efghijk')

def merge_two_dicts(x, y):
    z = x.copy()
    z.update(y)
    return z

min(repeat(lambda: {**x, **y}))
min(repeat(lambda: merge_two_dicts(x, y)))
min(repeat(lambda: {k: v for d in (x, y) for k, v in d.items()}))
min(repeat(lambda: dict(chain(x.items(), y.items()))))
min(repeat(lambda: dict(item for d in (x, y) for item in d.items())))
</code></pre>
<p>In Python 3.8.1, NixOS:</p>
<pre class=""lang-py prettyprint-override""><code>&gt;&gt;&gt; min(repeat(lambda: {**x, **y}))
1.0804965235292912
&gt;&gt;&gt; min(repeat(lambda: merge_two_dicts(x, y)))
1.636518670246005
&gt;&gt;&gt; min(repeat(lambda: {k: v for d in (x, y) for k, v in d.items()}))
3.1779992282390594
&gt;&gt;&gt; min(repeat(lambda: dict(chain(x.items(), y.items()))))
2.740647904574871
&gt;&gt;&gt; min(repeat(lambda: dict(item for d in (x, y) for item in d.items())))
4.266070580109954
</code></pre>
<pre class=""lang-sh prettyprint-override""><code>$ uname -a
Linux nixos 4.19.113 #1-NixOS SMP Wed Mar 25 07:06:15 UTC 2020 x86_64 GNU/Linux
</code></pre>
<h2>Resources on Dictionaries</h2>
<ul>
<li><a href=""https://stackoverflow.com/questions/327311/how-are-pythons-built-in-dictionaries-implemented/44509302#44509302"">My explanation of Python's <strong>dictionary implementation</strong>, updated for 3.6.</a></li>
<li><a href=""https://stackoverflow.com/questions/1024847/add-new-keys-to-a-dictionary/27208535#27208535"">Answer on how to add new keys to a dictionary</a></li>
<li><a href=""https://stackoverflow.com/questions/209840/map-two-lists-into-a-dictionary-in-python/33737067#33737067"">Mapping two lists into a dictionary</a></li>
<li><a href=""https://docs.python.org/3/tutorial/datastructures.html#dictionaries"" rel=""noreferrer"">The official Python docs on dictionaries</a></li>
<li><a href=""https://www.youtube.com/watch?v=66P5FMkWoVU"" rel=""noreferrer"">The Dictionary Even Mightier</a> - talk by Brandon Rhodes at Pycon 2017</li>
<li><a href=""https://www.youtube.com/watch?v=npw4s1QTmPg"" rel=""noreferrer"">Modern Python Dictionaries, A Confluence of Great Ideas</a> - talk by Raymond Hettinger at Pycon 2017</li>
</ul>
"
493399,"<p>In Python 3, you can use the <code>sep=</code> and <code>end=</code> parameters of the <a href=""https://docs.python.org/library/functions.html#print"" rel=""noreferrer""><code>print</code></a> function:</p>

<p>To not add a newline to the end of the string:</p>

<pre><code>print('.', end='')
</code></pre>

<p>To not add a space between all the function arguments you want to print:</p>

<pre><code>print('a', 'b', 'c', sep='')
</code></pre>

<p>You can pass any string to either parameter, and you can use both parameters at the same time.</p>

<p>If you are having trouble with buffering, you can flush the output by adding <code>flush=True</code> keyword argument:</p>

<pre><code>print('.', end='', flush=True)
</code></pre>

<h2>Python 2.6 and 2.7</h2>

<p>From Python 2.6 you can either import the <code>print</code> function from Python 3 using the <a href=""https://docs.python.org/2/library/__future__.html"" rel=""noreferrer""><code>__future__</code> module</a>:</p>

<pre><code>from __future__ import print_function
</code></pre>

<p>which allows you to use the Python 3 solution above.</p>

<p>However, note that the <code>flush</code> keyword is not available in the version of the <code>print</code> function imported from <code>__future__</code> in Python 2; it only works in Python 3, more specifically 3.3 and later. In earlier versions you'll still need to flush manually with a call to <code>sys.stdout.flush()</code>. You'll also have to rewrite all other print statements in the file where you do this import.</p>

<p>Or you can use <a href=""https://docs.python.org/library/sys.html#sys.stdout"" rel=""noreferrer""><code>sys.stdout.write()</code></a></p>

<pre><code>import sys
sys.stdout.write('.')
</code></pre>

<p>You may also need to call</p>

<pre><code>sys.stdout.flush()
</code></pre>

<p>to ensure <code>stdout</code> is flushed immediately.</p>
"
,
,
2626364,"
<p><a href=""https://stackoverflow.com/users/95810/alex-martelli"">Alex</a> summarized well but, surprisingly, was too succinct.</p>
<p>First, let me reiterate the main points in <a href=""https://stackoverflow.com/a/1436756/3798217"">Alexâs post</a>:</p>
<ul>
<li>The default implementation is useless (itâs hard to think of one which wouldnât be, but yeah)</li>
<li><code>__repr__</code> goal is to be unambiguous</li>
<li><code>__str__</code> goal is to be readable</li>
<li>Containerâs <code>__str__</code> uses contained objectsâ <code>__repr__</code></li>
</ul>
<p><strong>Default implementation is useless</strong></p>
<p>This is mostly a surprise because Pythonâs defaults tend to be fairly useful. However, in this case, having a default for <code>__repr__</code> which would act like:</p>
<pre class=""lang-python prettyprint-override""><code>return &quot;%s(%r)&quot; % (self.__class__, self.__dict__)
</code></pre>
<p>would have been too dangerous (for example, too easy to get into infinite recursion if objects reference each other). So Python cops out. Note that there is one default which is true: if <code>__repr__</code> is defined, and <code>__str__</code> is not, the object will behave as though <code>__str__=__repr__</code>.</p>
<p>This means, in simple terms: almost every object you implement should have a functional <code>__repr__</code> thatâs usable for understanding the object. Implementing <code>__str__</code> is optional: do that if you need a âpretty printâ functionality (for example, used by a report generator).</p>
<p><strong>The goal of <code>__repr__</code> is to be unambiguous</strong></p>
<p>Let me come right out and say it â I do not believe in debuggers. I donât really know how to use any debugger, and have never used one seriously. Furthermore, I believe that the big fault in debuggers is their basic nature â most failures I debug happened a long long time ago, in a galaxy far far away. This means that I do believe, with religious fervor, in logging. Logging is the lifeblood of any decent fire-and-forget server system. Python makes it easy to log: with maybe some project specific wrappers, all you need is a</p>
<pre class=""lang-python prettyprint-override""><code>log(INFO, &quot;I am in the weird function and a is&quot;, a, &quot;and b is&quot;, b, &quot;but I got a null C â using default&quot;, default_c)
</code></pre>
<p>But you have to do the last step â make sure every object you implement has a useful repr, so code like that can just work. This is why the âevalâ thing comes up: if you have enough information so <code>eval(repr(c))==c</code>, that means you know everything there is to know about <code>c</code>. If thatâs easy enough, at least in a fuzzy way, do it. If not, make sure you have enough information about <code>c</code> anyway. I usually use an eval-like format: <code>&quot;MyClass(this=%r,that=%r)&quot; % (self.this,self.that)</code>. It does not mean that you can actually construct MyClass, or that those are the right constructor arguments â but it is a useful form to express âthis is everything you need to know about this instanceâ.</p>
<p>Note: I used <code>%r</code> above, not <code>%s</code>. You always want to use <code>repr()</code> [or <code>%r</code> formatting character, equivalently] inside <code>__repr__</code> implementation, or youâre defeating the goal of repr. You want to be able to differentiate <code>MyClass(3)</code> and <code>MyClass(&quot;3&quot;)</code>.</p>
<p><strong>The goal of <code>__str__</code> is to be readable</strong></p>
<p>Specifically, it is not intended to be unambiguous â notice that <code>str(3)==str(&quot;3&quot;)</code>. Likewise, if you implement an IP abstraction, having the str of it look like 192.168.1.1 is just fine. When implementing a date/time abstraction, the str can be &quot;2010/4/12 15:35:22&quot;, etc. The goal is to represent it in a way that a user, not a programmer, would want to read it. Chop off useless digits, pretend to be some other class â as long is it supports readability, it is an improvement.</p>
<p><strong>Containerâs <code>__str__</code> uses contained objectsâ <code>__repr__</code></strong></p>
<p>This seems surprising, doesnât it? It is a little, but how readable would it be if it used their <code>__str__</code>?</p>
<pre class=""lang-python prettyprint-override""><code>[moshe is, 3, hello
world, this is a list, oh I don't know, containing just 4 elements]
</code></pre>
<p>Not very. Specifically, the strings in a container would find it way too easy to disturb its string representation. In the face of ambiguity, remember, Python resists the temptation to guess. If you want the above behavior when youâre printing a list, just</p>
<pre class=""lang-python prettyprint-override""><code>print(&quot;[&quot; + &quot;, &quot;.join(l) + &quot;]&quot;)
</code></pre>
<p>(you can probably also figure out what to do about dictionaries).</p>
<p><strong>Summary</strong></p>
<p>Implement <code>__repr__</code> for any class you implement. This should be second nature. Implement <code>__str__</code> if you think it would be useful to have a string version which errs on the side of readability.</p>
"
20648053,"<p>In production, configure the HTTP server (Nginx, Apache, etc.) in front of your application to serve requests to <code>/static</code> from the static folder. A dedicated web server is very good at serving static files efficiently, although you probably won't notice a difference compared to Flask at low volumes.</p>
<p>Flask automatically creates a <code>/static/&lt;path:filename&gt;</code> route that will serve any <code>filename</code> under the <code>static</code> folder next to the Python module that defines your Flask app. Use <code>url_for</code> to link to static files: <code>url_for('static', filename='js/analytics.js')</code></p>
<p>You can also use <a href=""http://flask.palletsprojects.com/api/#flask.send_from_directory"" rel=""noreferrer""><code>send_from_directory</code></a> to serve files from a directory in your own route. This takes a base directory and a path, and ensures that the path is contained in the directory, which makes it safe to accept user-provided paths. This can be useful in cases where you want to check something before serving the file, such as if the logged in user has permission.</p>
<pre><code>from flask import send_from_directory

@app.route('/reports/&lt;path:path&gt;')
def send_report(path):
    return send_from_directory('reports', path)
</code></pre>
<p>Do <strong>not</strong> use <code>send_file</code> or <code>send_static_file</code> with a user-supplied path.  This will expose you to <a href=""https://en.m.wikipedia.org/wiki/Directory_traversal_attack"" rel=""noreferrer"">directory traversal attacks</a>.  <code>send_from_directory</code> was designed to safely handle user-supplied paths under a known directory, and will raise an error if the path attempts to escape the directory.</p>
<p>If you are generating a file in memory without writing it to the filesystem, you can pass a <code>BytesIO</code> object to <a href=""http://flask.palletsprojects.com/api/#flask.send_file"" rel=""noreferrer""><code>send_file</code></a> to serve it like a file. You'll need to pass other arguments to <code>send_file</code> in this case since it can't infer things like the file name or content type.</p>
"
1680555,"<p>You want this:</p>

<pre><code>class a:
    def __init__(self):
        self.list = []
</code></pre>

<p>Declaring the variables inside the class declaration makes them ""class"" members and not instance members. Declaring them inside the <code>__init__</code> method makes sure that a new instance of the members is created alongside every new instance of the object, which is the behavior you're looking for.</p>
"
466376,"<p><a href=""https://docs.python.org/3/library/datetime.html#datetime.datetime.strptime"" rel=""noreferrer""><code>datetime.strptime</code></a> parses an input string in the user-specified format into a <em>timezone-naive</em> <a href=""https://docs.python.org/3/library/datetime.html#datetime-objects"" rel=""noreferrer""><code>datetime</code></a> object:</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; datetime.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')
datetime.datetime(2005, 6, 1, 13, 33)
</code></pre>
<p>To obtain a <a href=""https://docs.python.org/3/library/datetime.html#date-objects"" rel=""noreferrer""><code>date</code></a> object using an existing <code>datetime</code> object, convert it using <code>.date()</code>:</p>
<pre><code>&gt;&gt;&gt; datetime.strptime('Jun 1 2005', '%b %d %Y').date()
date(2005, 6, 1)
</code></pre>
<hr />
<p><strong>Links:</strong></p>
<ul>
<li><p><code>strptime</code> docs: <a href=""https://docs.python.org/2/library/datetime.html#datetime.datetime.strptime"" rel=""noreferrer"" title=""datetime.datetime.strptime"">Python 2</a>, <a href=""https://docs.python.org/3/library/datetime.html#datetime.datetime.strptime"" rel=""noreferrer"">Python 3</a></p>
</li>
<li><p><code>strptime</code>/<code>strftime</code> format string docs: <a href=""https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior"" rel=""noreferrer"" title=""strftime-and-strptime-behavior"">Python 2</a>, <a href=""https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior"" rel=""noreferrer"">Python 3</a></p>
</li>
<li><p><a href=""http://strftime.org/"" rel=""noreferrer"">strftime.org</a> format string cheatsheet</p>
</li>
</ul>
<p><strong>Notes:</strong></p>
<ul>
<li><code>strptime</code> = &quot;string parse time&quot;</li>
<li><code>strftime</code> = &quot;string format time&quot;</li>
</ul>
"
16664376,"<p>The <a href=""https://flask.palletsprojects.com/api/#flask.Request"" rel=""noreferrer"">docs</a> describe the attributes available on the <code>request</code> object (<code>from flask import request</code>) during a request. In most common cases <code>request.data</code> will be empty because it's used as a fallback:</p>
<blockquote>
<p><code>request.data</code> Contains the incoming request data as string in case it came with a mimetype Flask does not handle.</p>
</blockquote>
<ul>
<li><a href=""https://flask.palletsprojects.com/api/#flask.Request.args"" rel=""noreferrer""><code>request.args</code></a>: the key/value pairs in the URL query string</li>
<li><a href=""https://flask.palletsprojects.com/api/#flask.Request.form"" rel=""noreferrer""><code>request.form</code></a>: the key/value pairs in the body, from a HTML post form, or JavaScript request that isn't JSON encoded</li>
<li><a href=""https://flask.palletsprojects.com/api/#flask.Request.files"" rel=""noreferrer""><code>request.files</code></a>: the files in the body, which Flask keeps separate from <code>form</code>. HTML forms must use <code>enctype=multipart/form-data</code> or files will not be uploaded.</li>
<li><a href=""https://flask.palletsprojects.com/api/#flask.Request.values"" rel=""noreferrer""><code>request.values</code></a>: combined <code>args</code> and <code>form</code>, preferring <code>args</code> if keys overlap</li>
<li><a href=""https://flask.palletsprojects.com/api/#flask.Request.json"" rel=""noreferrer""><code>request.json</code></a>: parsed JSON data. The request must have the <code>application/json</code> content type, or use <a href=""https://flask.palletsprojects.com/api/#flask.Request.get_json"" rel=""noreferrer""><code>request.get_json(force=True)</code></a> to ignore the content type.</li>
</ul>
<p>All of these are <a href=""https://werkzeug.palletsprojects.com/datastructures/#werkzeug.datastructures.MultiDict"" rel=""noreferrer""><code>MultiDict</code></a> instances (except for <code>json</code>). You can access values using:</p>
<ul>
<li><code>request.form['name']</code>: use indexing if you know the key exists</li>
<li><code>request.form.get('name')</code>: use <code>get</code> if the key might not exist</li>
<li><code>request.form.getlist('name')</code>: use <code>getlist</code> if the key is sent multiple times and you want a list of values. <code>get</code> only returns the first value.</li>
</ul>
"
2295368,"<blockquote>
<p>What do the closures capture exactly?</p>
</blockquote>
<p>Closures in Python use lexical scoping: they remember the name and scope of the closed-over variable <em>where</em> it is created. <strong>However</strong>, they are still <em>late binding</em>: the name is looked up <em>when</em> the code in the closure is used, not when the closure is created. Since all the functions in your example are created in the same scope and use the same variable name, they always refer to the same variable.</p>
<p>There are at least two ways to get early binding instead:</p>
<ol>
<li><p>The most concise, but not strictly equivalent way is the <a href=""https://stackoverflow.com/a/2295372/181765"">one recommended by Adrien Plisson</a>. Create a lambda with an extra argument, and set the extra argument's default value to the object you want preserved.</p>
</li>
<li><p>More verbosely but also more robustly, we can create a new scope for each created lambda:</p>
<pre><code>&gt;&gt;&gt; adders = [0,1,2,3]
&gt;&gt;&gt; for i in [0,1,2,3]:
...     adders[i] = (lambda b: lambda a: b + a)(i)
...     
&gt;&gt;&gt; adders[1](3)
4
&gt;&gt;&gt; adders[2](3)
5
</code></pre>
<p>The scope here is created using a new function (another lambda, for brevity), which binds its argument, and passing the value you want to bind as the argument. In real code, though, you most likely will have an ordinary function instead of the lambda to create the new scope:</p>
<pre><code>def createAdder(x):
    return lambda y: y + x
adders = [createAdder(i) for i in range(4)]
</code></pre>
</li>
</ol>
"
100146,"<p>A metaclass is the class of a class. A class defines how an instance of the class (i.e. an object) behaves while a metaclass defines how a class behaves. A class is an instance of a metaclass.</p>

<p>While in Python you can use arbitrary callables for metaclasses (like <a href=""https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python/100037#100037"">Jerub</a> shows), the better approach is to make it an actual class itself. <code>type</code> is the usual metaclass in Python. <code>type</code> is itself a class, and it is its own type. You won't be able to recreate something like <code>type</code> purely in Python, but Python cheats a little. To create your own metaclass in Python you really just want to subclass <code>type</code>.</p>

<p>A metaclass is most commonly used as a class-factory. When you create an object by calling the class, Python creates a new class (when it executes the 'class' statement) by calling the metaclass. Combined with the normal <code>__init__</code> and <code>__new__</code> methods, metaclasses therefore allow you to do 'extra things' when creating a class, like registering the new class with some registry or replace the class with something else entirely.</p>

<p>When the <code>class</code> statement is executed, Python first executes the body of the <code>class</code> statement as a normal block of code. The resulting namespace (a dict) holds the attributes of the class-to-be. The metaclass is determined by looking at the baseclasses of the class-to-be (metaclasses are inherited), at the <code>__metaclass__</code> attribute of the class-to-be (if any) or the <code>__metaclass__</code> global variable. The metaclass is then called with the name, bases and attributes of the class to instantiate it.</p>

<p>However, metaclasses actually define the <em>type</em> of a class, not just a factory for it, so you can do much more with them. You can, for instance, define normal methods on the metaclass. These metaclass-methods are like classmethods in that they can be called on the class without an instance, but they are also not like classmethods in that they cannot be called on an instance of the class. <code>type.__subclasses__()</code> is an example of a method on the <code>type</code> metaclass. You can also define the normal 'magic' methods, like <code>__add__</code>, <code>__iter__</code> and <code>__getattr__</code>, to implement or change how the class behaves.</p>

<p>Here's an aggregated example of the bits and pieces:</p>

<pre><code>def make_hook(f):
    """"""Decorator to turn 'foo' method into '__foo__'""""""
    f.is_hook = 1
    return f

class MyType(type):
    def __new__(mcls, name, bases, attrs):

        if name.startswith('None'):
            return None

        # Go over attributes and see if they should be renamed.
        newattrs = {}
        for attrname, attrvalue in attrs.iteritems():
            if getattr(attrvalue, 'is_hook', 0):
                newattrs['__%s__' % attrname] = attrvalue
            else:
                newattrs[attrname] = attrvalue

        return super(MyType, mcls).__new__(mcls, name, bases, newattrs)

    def __init__(self, name, bases, attrs):
        super(MyType, self).__init__(name, bases, attrs)

        # classregistry.register(self, self.interfaces)
        print ""Would register class %s now."" % self

    def __add__(self, other):
        class AutoClass(self, other):
            pass
        return AutoClass
        # Alternatively, to autogenerate the classname as well as the class:
        # return type(self.__name__ + other.__name__, (self, other), {})

    def unregister(self):
        # classregistry.unregister(self)
        print ""Would unregister class %s now."" % self

class MyObject:
    __metaclass__ = MyType


class NoneSample(MyObject):
    pass

# Will print ""NoneType None""
print type(NoneSample), repr(NoneSample)

class Example(MyObject):
    def __init__(self, value):
        self.value = value
    @make_hook
    def add(self, other):
        return self.__class__(self.value + other.value)

# Will unregister the class
Example.unregister()

inst = Example(10)
# Will fail with an AttributeError
#inst.unregister()

print inst + inst
class Sibling(MyObject):
    pass

ExampleSibling = Example + Sibling
# ExampleSibling is now a subclass of both Example and Sibling (with no
# content of its own) although it will believe it's called 'AutoClass'
print ExampleSibling
print ExampleSibling.__mro__
</code></pre>
"
,
39923012,"<p>Use <a href=""https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.core.groupby.GroupBy.sum.html"" rel=""noreferrer""><code>GroupBy.sum</code></a>:</p>
<pre><code>df.groupby(['Fruit','Name']).sum()

Out[31]: 
               Number
Fruit   Name         
Apples  Bob        16
        Mike        9
        Steve      10
Grapes  Bob        35
        Tom        87
        Tony       15
Oranges Bob        67
        Mike       57
        Tom        15
        Tony        1
</code></pre>
<p>To specify the column to sum, use this: <code>df.groupby(['Name', 'Fruit'])['Number'].sum()</code></p>
"
53218939,"<p>I know <code>object</code> dtype columns makes the data hard to convert with pandas functions. When I receive data like this, the first thing that came to mind was to &quot;flatten&quot; or unnest the columns.</p>
<p>I am using pandas and Python functions for this type of question. If you are worried about the speed of the above solutions, check out <a href=""https://stackoverflow.com/questions/53219045"">user3483203's answer</a>, since it's using numpy and most of the time numpy is faster. I recommend <a href=""https://cython.org/"" rel=""noreferrer"">Cython</a> or <a href=""http://numba.pydata.org/"" rel=""noreferrer"">numba</a> if speed matters.</p>
<hr />
<p><strong>Method 0 [pandas &gt;= 0.25]</strong>
Starting from <a href=""https://pandas.pydata.org/pandas-docs/version/0.25/user_guide/reshaping.html#exploding-a-list-like-column"" rel=""noreferrer"">pandas 0.25</a>, if you only need to explode <em>one</em> column, you can use the <a href=""https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.explode.html"" rel=""noreferrer""><code>pandas.DataFrame.explode</code></a> function:</p>
<pre><code>df.explode('B')

       A  B
    0  1  1
    1  1  2
    0  2  1
    1  2  2
</code></pre>
<p>Given a dataframe with an empty <code>list</code> or a <code>NaN</code> in the column. An empty list will not cause an issue, but a <code>NaN</code> will need to be filled with a <code>list</code></p>
<pre><code>df = pd.DataFrame({'A': [1, 2, 3, 4],'B': [[1, 2], [1, 2], [], np.nan]})
df.B = df.B.fillna({i: [] for i in df.index})  # replace NaN with []
df.explode('B')

   A    B
0  1    1
0  1    2
1  2    1
1  2    2
2  3  NaN
3  4  NaN
</code></pre>
<hr />
<p><strong>Method 1</strong>
<strong><code>apply + pd.Series</code></strong> (easy to understand but in terms of performance not recommended . )</p>
<pre><code>df.set_index('A').B.apply(pd.Series).stack().reset_index(level=0).rename(columns={0:'B'})
Out[463]:
   A  B
0  1  1
1  1  2
0  2  1
1  2  2
</code></pre>
<hr />
<p><strong>Method 2</strong>
Using <code>repeat</code> with <code>DataFrame</code> constructor , re-create your dataframe (good at performance, not good at multiple columns )</p>
<pre><code>df=pd.DataFrame({'A':df.A.repeat(df.B.str.len()),'B':np.concatenate(df.B.values)})
df
Out[465]:
   A  B
0  1  1
0  1  2
1  2  1
1  2  2
</code></pre>
<p><strong>Method 2.1</strong>
for example besides A we have A.1 .....A.n. If we still use the method(<strong>Method 2</strong>) above it is hard for us to re-create the columns one by one .</p>
<p>Solution : <code>join</code> or <code>merge</code> with the <code>index</code> after 'unnest' the single columns</p>
<pre><code>s=pd.DataFrame({'B':np.concatenate(df.B.values)},index=df.index.repeat(df.B.str.len()))
s.join(df.drop('B',1),how='left')
Out[477]:
   B  A
0  1  1
0  2  1
1  1  2
1  2  2
</code></pre>
<p>If you need the column order exactly the same as before, add <code>reindex</code> at the end.</p>
<pre><code>s.join(df.drop('B',1),how='left').reindex(columns=df.columns)
</code></pre>
<hr />
<p><strong>Method 3</strong>
recreate the <code>list</code></p>
<pre><code>pd.DataFrame([[x] + [z] for x, y in df.values for z in y],columns=df.columns)
Out[488]:
   A  B
0  1  1
1  1  2
2  2  1
3  2  2
</code></pre>
<p>If more than two columns, use</p>
<pre><code>s=pd.DataFrame([[x] + [z] for x, y in zip(df.index,df.B) for z in y])
s.merge(df,left_on=0,right_index=True)
Out[491]:
   0  1  A       B
0  0  1  1  [1, 2]
1  0  2  1  [1, 2]
2  1  1  2  [1, 2]
3  1  2  2  [1, 2]
</code></pre>
<hr />
<p><strong>Method 4</strong>
using <code>reindex</code>  or <code>loc</code></p>
<pre><code>df.reindex(df.index.repeat(df.B.str.len())).assign(B=np.concatenate(df.B.values))
Out[554]:
   A  B
0  1  1
0  1  2
1  2  1
1  2  2

#df.loc[df.index.repeat(df.B.str.len())].assign(B=np.concatenate(df.B.values))
</code></pre>
<hr />
<p><strong>Method 5</strong>
when the list only contains unique values:</p>
<pre><code>df=pd.DataFrame({'A':[1,2],'B':[[1,2],[3,4]]})
from collections import ChainMap
d = dict(ChainMap(*map(dict.fromkeys, df['B'], df['A'])))
pd.DataFrame(list(d.items()),columns=df.columns[::-1])
Out[574]:
   B  A
0  1  1
1  2  1
2  3  2
3  4  2
</code></pre>
<hr />
<p><strong>Method 6</strong>
using <code>numpy</code> for high performance:</p>
<pre><code>newvalues=np.dstack((np.repeat(df.A.values,list(map(len,df.B.values))),np.concatenate(df.B.values)))
pd.DataFrame(data=newvalues[0],columns=df.columns)
   A  B
0  1  1
1  1  2
2  2  1
3  2  2
</code></pre>
<hr />
<p><strong>Method 7</strong>
using base function <code>itertools</code> <code>cycle</code> and <code>chain</code>: Pure python solution just for fun</p>
<pre><code>from itertools import cycle,chain
l=df.values.tolist()
l1=[list(zip([x[0]], cycle(x[1])) if len([x[0]]) &gt; len(x[1]) else list(zip(cycle([x[0]]), x[1]))) for x in l]
pd.DataFrame(list(chain.from_iterable(l1)),columns=df.columns)
   A  B
0  1  1
1  1  2
2  2  1
3  2  2
</code></pre>
<hr />
<p><strong>Generalizing to multiple columns</strong></p>
<pre><code>df=pd.DataFrame({'A':[1,2],'B':[[1,2],[3,4]],'C':[[1,2],[3,4]]})
df
Out[592]:
   A       B       C
0  1  [1, 2]  [1, 2]
1  2  [3, 4]  [3, 4]
</code></pre>
<p>Self-def function:</p>
<pre><code>def unnesting(df, explode):
    idx = df.index.repeat(df[explode[0]].str.len())
    df1 = pd.concat([
        pd.DataFrame({x: np.concatenate(df[x].values)}) for x in explode], axis=1)
    df1.index = idx

    return df1.join(df.drop(explode, 1), how='left')


unnesting(df,['B','C'])
Out[609]:
   B  C  A
0  1  1  1
0  2  2  1
1  3  3  2
1  4  4  2
</code></pre>
<hr />
<h3><strong>Column-wise Unnesting</strong></h3>
<p>All above method is talking about the <em><strong>vertical</strong></em> unnesting and explode , If you do need expend the list <em><strong>horizontal</strong></em>, Check with <code>pd.DataFrame</code> constructor</p>
<pre><code>df.join(pd.DataFrame(df.B.tolist(),index=df.index).add_prefix('B_'))
Out[33]:
   A       B       C  B_0  B_1
0  1  [1, 2]  [1, 2]    1    2
1  2  [3, 4]  [3, 4]    3    4
</code></pre>
<p><strong>Updated function</strong></p>
<pre><code>def unnesting(df, explode, axis):
    if axis==1:
        idx = df.index.repeat(df[explode[0]].str.len())
        df1 = pd.concat([
            pd.DataFrame({x: np.concatenate(df[x].values)}) for x in explode], axis=1)
        df1.index = idx

        return df1.join(df.drop(explode, 1), how='left')
    else :
        df1 = pd.concat([
                         pd.DataFrame(df[x].tolist(), index=df.index).add_prefix(x) for x in explode], axis=1)
        return df1.join(df.drop(explode, 1), how='left')
</code></pre>
<p>Test Output</p>
<pre><code>unnesting(df, ['B','C'], axis=0)
Out[36]:
   B0  B1  C0  C1  A
0   1   2   1   2  1
1   3   4   3   4  2
</code></pre>
<blockquote>
<p>Update 2021-02-17 with original explode function</p>
</blockquote>
<pre><code>def unnesting(df, explode, axis):
    if axis==1:
        df1 = pd.concat([df[x].explode() for x in explode], axis=1)
        return df1.join(df.drop(explode, 1), how='left')
    else :
        df1 = pd.concat([
                         pd.DataFrame(df[x].tolist(), index=df.index).add_prefix(x) for x in explode], axis=1)
        return df1.join(df.drop(explode, 1), how='left')
</code></pre>
"
39980744,"<blockquote>
<p><strong>Are dictionaries ordered in Python 3.6+?</strong></p>
</blockquote>
<p>They are <strong>insertion ordered</strong><sup><strong>[1]</strong></sup>.</p>
<p><strong>As of Python 3.6</strong>, for the CPython implementation of Python, dictionaries <em>remember the order of items inserted</em>. <em>This is considered an implementation detail in Python 3.6</em>; you need to use <code>OrderedDict</code> if you want insertion ordering that's <em>guaranteed</em> across other implementations of Python (and other ordered behavior<sup><strong>[1]</strong></sup>).</p>
<p><strong>As of Python 3.7</strong>, this is a guaranteed language feature, not merely an implementation detail. <a href=""https://mail.python.org/pipermail/python-dev/2017-December/151283.html"" rel=""noreferrer"">From a python-dev message by GvR</a>:</p>
<blockquote>
<p>Make it so. &quot;Dict keeps insertion order&quot; is the ruling. Thanks!</p>
</blockquote>
<p>This simply means that <em>you can depend on it</em>. Other implementations of Python must also offer an insertion ordered dictionary if they wish to be a conforming implementation of Python 3.7.</p>
<hr />
<blockquote>
<p><strong>How does the Python <code>3.6</code> dictionary implementation perform better<sup>[2]</sup> than the older one while preserving element order?</strong></p>
</blockquote>
<p>Essentially, by <em>keeping two arrays</em>.</p>
<ul>
<li><p>The first array, <a href=""https://github.com/python/cpython/blob/474ef63e38726d4bcde14f6104984a742c6cb747/Objects/dictobject.c#L551"" rel=""noreferrer""><code>dk_entries</code></a>, holds the entries (<a href=""https://github.com/python/cpython/blob/c30098c8c6014f3340a369a31df9c74bdbacc269/Objects/dict-common.h#L4"" rel=""noreferrer"">of type <code> PyDictKeyEntry</code></a>) for the dictionary in the order that they were inserted. Preserving order is achieved by this being an append only array where new items are always inserted at the end (insertion order).</p>
</li>
<li><p>The second, <a href=""https://github.com/python/cpython/blob/c30098c8c6014f3340a369a31df9c74bdbacc269/Objects/dict-common.h#L70"" rel=""noreferrer""><code>dk_indices</code></a>, holds the indices for the <code>dk_entries</code> array (that is, values that indicate the position of the corresponding entry in <code>dk_entries</code>). This array acts as the hash table. When a key is hashed it leads to one of the indices stored in <code>dk_indices</code> and the corresponding entry is fetched by indexing <code>dk_entries</code>. Since only indices are kept, the type of this array depends on the overall size of the dictionary (ranging from type <a href=""https://github.com/python/cpython/blob/c30098c8c6014f3340a369a31df9c74bdbacc269/Objects/dict-common.h#L64"" rel=""noreferrer""><code>int8_t</code></a>(<code>1</code> byte) to <a href=""https://github.com/python/cpython/blob/c30098c8c6014f3340a369a31df9c74bdbacc269/Objects/dict-common.h#L66"" rel=""noreferrer""><code>int32_t</code></a>/<a href=""https://github.com/python/cpython/blob/c30098c8c6014f3340a369a31df9c74bdbacc269/Objects/dict-common.h#L68"" rel=""noreferrer""><code>int64_t</code></a> (<code>4</code>/<code>8</code> bytes) on <code>32</code>/<code>64</code> bit builds)</p>
</li>
</ul>
<p>In the previous implementation, a sparse array of type <code>PyDictKeyEntry</code> and size <code>dk_size</code> had to be allocated; unfortunately, it also resulted in a lot of empty space since that array was not allowed to be more than <code>2/3 * dk_size</code> full <a href=""https://github.com/python/cpython/blob/474ef63e38726d4bcde14f6104984a742c6cb747/Objects/dictobject.c#L375"" rel=""noreferrer"">for performance reasons</a>. (and the empty space <em>still</em> had <code>PyDictKeyEntry</code> size!).</p>
<p>This is not the case now since only the <em>required</em> entries are stored (those that have been inserted) and a sparse array of type <code>intX_t</code> (<code>X</code> depending on dict size) <code>2/3 * dk_size</code>s full is kept. The empty space changed from type <code>PyDictKeyEntry</code> to <code>intX_t</code>.</p>
<p>So, obviously, creating a sparse array of type <code>PyDictKeyEntry</code> is much more memory demanding than a sparse array for storing <code>int</code>s.</p>
<p>You can see the full conversation <a href=""https://mail.python.org/pipermail/python-dev/2016-September/146327.html"" rel=""noreferrer"">on Python-Dev</a> regarding this feature if interested, it is a good read.</p>
<hr />
<p><a href=""https://mail.python.org/pipermail/python-dev/2012-December/123028.html"" rel=""noreferrer"">In the original proposal made by Raymond Hettinger</a>, a visualization of the data structures used can be seen which captures the gist of the idea.</p>
<blockquote>
<p>For example, the dictionary:</p>
<pre><code>d = {'timmy': 'red', 'barry': 'green', 'guido': 'blue'}
</code></pre>
<p>is currently stored as [keyhash, key, value]:</p>
<pre><code>entries = [['--', '--', '--'],
           [-8522787127447073495, 'barry', 'green'],
           ['--', '--', '--'],
           ['--', '--', '--'],
           ['--', '--', '--'],
           [-9092791511155847987, 'timmy', 'red'],
           ['--', '--', '--'],
           [-6480567542315338377, 'guido', 'blue']]
</code></pre>
<p>Instead, the data should be organized as follows:</p>
<pre><code>indices =  [None, 1, None, None, None, 0, None, 2]
entries =  [[-9092791511155847987, 'timmy', 'red'],
            [-8522787127447073495, 'barry', 'green'],
            [-6480567542315338377, 'guido', 'blue']]
</code></pre>
</blockquote>
<p>As you can visually now see, in the original proposal, a lot of space is essentially empty to reduce collisions and make look-ups faster. With the new approach, you reduce the memory required by moving the sparseness where it's really required, in the indices.</p>
<hr />
<sub>
[1]: I say ""insertion ordered"" and not ""ordered"" since, with the existence of OrderedDict, ""ordered"" suggests further behavior that the `dict` object *doesn't provide*. OrderedDicts are reversible, provide order sensitive methods and, mainly, provide an order-sensive equality tests (`==`, `!=`). `dict`s currently don't offer any of those behaviors/methods.
</sub>
<hr />
<sub>
[2]: The new dictionary implementations performs better **memory wise** by being designed more compactly; that's the main benefit here. Speed wise, the difference isn't so drastic, there's places where the new dict might introduce slight regressions (<a href=""https://github.com/python/cpython/blob/474ef63e38726d4bcde14f6104984a742c6cb747/Objects/dictobject.c#L375"" rel=""noreferrer"">key-lookups, for example</a>) while in others (iteration and resizing come to mind) a performance boost should be present. 
</sub>
<sub>
Overall, the performance of the dictionary, especially in real-life situations, improves due to the compactness introduced.  
</sub>
"
325528,"<p>It is generally a bad pattern to kill a thread abruptly, in Python, and in any language. Think of the following cases:</p>
<ul>
<li>the thread is holding a critical resource that must be closed properly</li>
<li>the thread has created several other threads that must be killed as well.</li>
</ul>
<p>The nice way of handling this, if you can afford it (if you are managing your own threads), is to have an exit_request flag that each thread checks on a regular interval to see if it is time for it to exit.</p>
<p><strong>For example:</strong></p>
<pre><code>import threading

class StoppableThread(threading.Thread):
    &quot;&quot;&quot;Thread class with a stop() method. The thread itself has to check
    regularly for the stopped() condition.&quot;&quot;&quot;

    def __init__(self,  *args, **kwargs):
        super(StoppableThread, self).__init__(*args, **kwargs)
        self._stop_event = threading.Event()

    def stop(self):
        self._stop_event.set()

    def stopped(self):
        return self._stop_event.is_set()
</code></pre>
<p>In this code, you should call <code>stop()</code> on the thread when you want it to exit, and wait for the thread to exit properly using <code>join()</code>. The thread should check the stop flag at regular intervals.</p>
<p>There are cases, however, when you really need to kill a thread. An example is when you are wrapping an external library that is busy for long calls, and you want to interrupt it.</p>
<p>The following code allows (with some restrictions) to raise an Exception in a Python thread:</p>
<pre><code>def _async_raise(tid, exctype):
    '''Raises an exception in the threads with id tid'''
    if not inspect.isclass(exctype):
        raise TypeError(&quot;Only types can be raised (not instances)&quot;)
    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(ctypes.c_long(tid),
                                                     ctypes.py_object(exctype))
    if res == 0:
        raise ValueError(&quot;invalid thread id&quot;)
    elif res != 1:
        # &quot;if it returns a number greater than one, you're in trouble,
        # and you should call it again with exc=NULL to revert the effect&quot;
        ctypes.pythonapi.PyThreadState_SetAsyncExc(ctypes.c_long(tid), None)
        raise SystemError(&quot;PyThreadState_SetAsyncExc failed&quot;)

class ThreadWithExc(threading.Thread):
    '''A thread class that supports raising an exception in the thread from
       another thread.
    '''
    def _get_my_tid(self):
        &quot;&quot;&quot;determines this (self's) thread id

        CAREFUL: this function is executed in the context of the caller
        thread, to get the identity of the thread represented by this
        instance.
        &quot;&quot;&quot;
        if not self.isAlive():
            raise threading.ThreadError(&quot;the thread is not active&quot;)

        # do we have it cached?
        if hasattr(self, &quot;_thread_id&quot;):
            return self._thread_id

        # no, look for it in the _active dict
        for tid, tobj in threading._active.items():
            if tobj is self:
                self._thread_id = tid
                return tid

        # TODO: in python 2.6, there's a simpler way to do: self.ident

        raise AssertionError(&quot;could not determine the thread's id&quot;)

    def raiseExc(self, exctype):
        &quot;&quot;&quot;Raises the given exception type in the context of this thread.

        If the thread is busy in a system call (time.sleep(),
        socket.accept(), ...), the exception is simply ignored.

        If you are sure that your exception should terminate the thread,
        one way to ensure that it works is:

            t = ThreadWithExc( ... )
            ...
            t.raiseExc( SomeException )
            while t.isAlive():
                time.sleep( 0.1 )
                t.raiseExc( SomeException )

        If the exception is to be caught by the thread, you need a way to
        check that your thread has caught it.

        CAREFUL: this function is executed in the context of the
        caller thread, to raise an exception in the context of the
        thread represented by this instance.
        &quot;&quot;&quot;
        _async_raise( self._get_my_tid(), exctype )
</code></pre>
<p>(Based on <a href=""http://tomerfiliba.com/recipes/Thread2/"" rel=""noreferrer"">Killable Threads</a> by Tomer Filiba. The quote about the return value of <code>PyThreadState_SetAsyncExc</code> appears to be from an <a href=""https://svn.python.org/projects/stackless/Python-2.4.3/dev/Python/pystate.c"" rel=""noreferrer"">old version of Python</a>.)</p>
<p>As noted in the documentation, this is not a magic bullet because if the thread is busy outside the Python interpreter, it will not catch the interruption.</p>
<p>A good usage pattern of this code is to have the thread catch a specific exception and perform the cleanup. That way, you can interrupt a task and still have proper cleanup.</p>
"
480227,"<p>Here you have some alternatives: <a href=""http://www.peterbe.com/plog/uniqifiers-benchmark"" rel=""noreferrer"">http://www.peterbe.com/plog/uniqifiers-benchmark</a></p>

<p>Fastest one:</p>

<pre><code>def f7(seq):
    seen = set()
    seen_add = seen.add
    return [x for x in seq if not (x in seen or seen_add(x))]
</code></pre>

<p>Why assign <code>seen.add</code> to <code>seen_add</code> instead of just calling <code>seen.add</code>? Python is a dynamic language, and resolving <code>seen.add</code> each iteration is more costly than resolving a local variable. <code>seen.add</code> could have changed between iterations, and the runtime isn't smart enough to rule that out. To play it safe, it has to check the object each time.</p>

<p>If you plan on using this function a lot on the same dataset, perhaps you would be better off with an ordered set: <a href=""http://code.activestate.com/recipes/528878/"" rel=""noreferrer"">http://code.activestate.com/recipes/528878/</a></p>

<p><em>O</em>(1) insertion, deletion and member-check per operation.</p>

<p>(Small additional note: <code>seen.add()</code> always returns <code>None</code>, so the <em><code>or</code></em> above is there only as a way to attempt a set update, and not as an integral part of the logical test.)</p>
"
34835952,"<p><a href=""https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions"" rel=""noreferrer"">From <strong>the documentation</strong>:</a></p>

<blockquote>
  <p>List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition.</p>
</blockquote>

<hr>

<p>About your question, the list comprehension does the same thing as the following ""plain"" Python code:</p>

<pre><code>&gt;&gt;&gt; l = [] 
&gt;&gt;&gt; for x in range(10):
...     l.append(x**2)
&gt;&gt;&gt; l
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>

<p>How do you write it in one line? Hmm...we can...probably...use <a href=""https://docs.python.org/3/library/functions.html#map"" rel=""noreferrer""><code>map()</code></a> with <a href=""https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions"" rel=""noreferrer""><code>lambda</code></a>:</p>

<pre><code>&gt;&gt;&gt; list(map(lambda x: x**2, range(10)))
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>

<p>But isn't it clearer and simpler to just use a list comprehension?</p>

<pre><code>&gt;&gt;&gt; [x**2 for x in range(10)]
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>

<hr>

<p>Basically, we can do anything with <code>x</code>. Not only <code>x**2</code>. For example, run a method of <code>x</code>:</p>

<pre><code>&gt;&gt;&gt; [x.strip() for x in ('foo\n', 'bar\n', 'baz\n')]
['foo', 'bar', 'baz']
</code></pre>

<p>Or use <code>x</code> as another function's argument:</p>

<pre><code>&gt;&gt;&gt; [int(x) for x in ('1', '2', '3')]
[1, 2, 3]
</code></pre>

<p>We can also, for example, use <code>x</code> as the key of a <code>dict</code> object. Let's see:</p>

<pre><code>&gt;&gt;&gt; d = {'foo': '10', 'bar': '20', 'baz': '30'}
&gt;&gt;&gt; [d[x] for x in ['foo', 'baz']]
['10', '30']
</code></pre>

<p>How about a combination?  </p>

<pre><code>&gt;&gt;&gt; d = {'foo': '10', 'bar': '20', 'baz': '30'}
&gt;&gt;&gt; [int(d[x].rstrip('0')) for x in ['foo', 'baz']]
[1, 3]
</code></pre>

<p>And so on.</p>

<hr>

<p>You can also use <code>if</code> or <code>if...else</code> in a list comprehension. For example, you only want odd numbers in <code>range(10)</code>. You can do:</p>

<pre><code>&gt;&gt;&gt; l = []
&gt;&gt;&gt; for x in range(10):
...     if x%2:
...         l.append(x)
&gt;&gt;&gt; l
[1, 3, 5, 7, 9]
</code></pre>

<p>Ah that's too complex. What about the following version?</p>

<pre><code>&gt;&gt;&gt; [x for x in range(10) if x%2]
[1, 3, 5, 7, 9]
</code></pre>

<p>To use an <code>if...else</code> ternary expression, you need put the <code>if ... else ...</code> after <code>x</code>, <strong>not</strong> after <code>range(10)</code>:</p>

<pre><code>&gt;&gt;&gt; [i if i%2 != 0 else None for i in range(10)]
[None, 1, None, 3, None, 5, None, 7, None, 9]
</code></pre>

<hr>

<p>Have you heard about <a href=""https://docs.python.org/3/tutorial/datastructures.html#nested-list-comprehensions"" rel=""noreferrer""><strong>nested list comprehension</strong></a>? You can put <em>two or more <code>for</code>s in one list comprehension</em>. For example:</p>

<pre><code>&gt;&gt;&gt; [i for x in [[1, 2, 3], [4, 5, 6]] for i in x]
[1, 2, 3, 4, 5, 6]

&gt;&gt;&gt; [j for x in [[[1, 2], [3]], [[4, 5], [6]]] for i in x for j in i]
[1, 2, 3, 4, 5, 6]
</code></pre>

<p>Let's talk about the first part, <code>for x in [[1, 2, 3], [4, 5, 6]]</code> which gives <code>[1, 2, 3]</code> and <code>[4, 5, 6]</code>. Then, <code>for i in x</code> gives <code>1</code>, <code>2</code>, <code>3</code> and <code>4</code>, <code>5</code>, <code>6</code>. </p>

<p><strong>Warning:</strong> You always need put <code>for x in [[1, 2, 3], [4, 5, 6]]</code> <strong>before</strong> <code>for i in x</code>:</p>

<pre><code>&gt;&gt;&gt; [j for j in x for x in [[1, 2, 3], [4, 5, 6]]]
Traceback (most recent call last):
  File ""&lt;input&gt;"", line 1, in &lt;module&gt;
NameError: name 'x' is not defined
</code></pre>

<hr>

<p>We also have <em>set comprehensions</em>, <em>dict comprehensions</em>, and <em>generator expressions</em>.</p>

<p><strong>set comprehensions</strong> and list comprehensions are basically the same, but the former returns a <em>set</em> instead of a <em>list</em>:</p>

<pre><code>&gt;&gt;&gt; {x for x in [1, 1, 2, 3, 3, 1]}
{1, 2, 3}
</code></pre>

<p>It's the same as:</p>

<pre><code>&gt;&gt;&gt; set([i for i in [1, 1, 2, 3, 3, 1]])
{1, 2, 3}
</code></pre>

<p>A <a href=""https://www.python.org/dev/peps/pep-0274/"" rel=""noreferrer""><strong>dict comprehension</strong></a> <em>looks like</em> a set comprehension, but it uses <code>{key: value for key, value in ...}</code> or <code>{i: i for i in ...}</code> instead of  <code>{i for i in ...}</code>.</p>

<p>For example:</p>

<pre><code>&gt;&gt;&gt; {i: i**2 for i in range(5)}
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
</code></pre>

<p>And it equals:</p>

<pre><code>&gt;&gt;&gt; d = {}
&gt;&gt;&gt; for i in range(5):
...     d[i] = i**2
&gt;&gt;&gt; d
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
</code></pre>

<p>Does <code>(i for i in range(5))</code> give a <em>tuple</em>? No!, it's a <a href=""https://www.python.org/dev/peps/pep-0289/"" rel=""noreferrer""><strong>generator expression</strong></a>. Which returns a <strong>generator</strong>:</p>

<pre><code>&gt;&gt;&gt; (i for i in range(5))
&lt;generator object &lt;genexpr&gt; at 0x7f52703fbca8&gt;
</code></pre>

<p>It's the same as:</p>

<pre><code>&gt;&gt;&gt; def gen():
...     for i in range(5):
...         yield i
&gt;&gt;&gt; gen()
&lt;generator object gen at 0x7f5270380db0&gt;
</code></pre>

<p>And you can use it as a generator:</p>

<pre><code>&gt;&gt;&gt; gen = (i for i in range(5))
&gt;&gt;&gt; next(gen)
0
&gt;&gt;&gt; next(gen)
1
&gt;&gt;&gt; list(gen)
[2, 3, 4]
&gt;&gt;&gt; next(gen)
Traceback (most recent call last):
  File ""&lt;input&gt;"", line 1, in &lt;module&gt;
StopIteration
</code></pre>

<p><strong>Note:</strong> If you use a list comprehension <em>inside a function</em>, you don't need the <code>[]</code> if that function could loop over a generator. For example, <a href=""https://docs.python.org/3/library/functions.html#sum"" rel=""noreferrer""><code>sum()</code></a>:</p>

<pre><code>&gt;&gt;&gt; sum(i**2 for i in range(5))
30
</code></pre>

<p><strong>Related</strong> (about generators): <a href=""https://stackoverflow.com/questions/1756096/understanding-generators-in-python"">Understanding Generators in Python</a>.</p>
"
3431699,"<p>You're running into a problem with <em>late binding</em> -- each function looks up <code>i</code> as late as possible (thus, when called after the end of the loop, <code>i</code> will be set to <code>2</code>).  </p>

<p>Easily fixed by forcing early binding: change <code>def f():</code> to <code>def f(i=i):</code> like this:</p>

<pre><code>def f(i=i):
    return i
</code></pre>

<p>Default values (the right-hand <code>i</code> in <code>i=i</code> is a default value for argument name <code>i</code>, which is the left-hand <code>i</code> in <code>i=i</code>) are looked up at <code>def</code> time, not at <code>call</code> time, so essentially they're a way to specifically looking for early binding.</p>

<p>If you're worried about <code>f</code> getting an extra argument (and thus potentially being called erroneously), there's a more sophisticated way which involved using a closure as a ""function factory"":</p>

<pre><code>def make_f(i):
    def f():
        return i
    return f
</code></pre>

<p>and in your loop use <code>f = make_f(i)</code> instead of the <code>def</code> statement.</p>
"
2600208,"<p>If you only want a single item's count, use the <code>count</code> method:</p>
<pre><code>&gt;&gt;&gt; [1, 2, 3, 4, 1, 4, 1].count(1)
3
</code></pre>
<hr />
<h4><strong>Important: this is very slow if you are counting <em>multiple</em> different items</strong></h4>
<p>Each <code>count</code> call goes over the entire list of <code>n</code> elements. Calling <code>count</code> in a loop <code>n</code> times means <code>n * n</code> total checks, which can be catastrophic for performance.</p>
<p>If you want to count multiple items, use <a href=""https://stackoverflow.com/a/5829377/365102""><code>Counter</code></a>, which only does <code>n</code> total checks.</p>
"
15705958,"<p>Firstly, we can get the max count for each group like this:</p>
<pre><code>In [1]: df
Out[1]:
    Sp  Mt Value  count
0  MM1  S1     a      3
1  MM1  S1     n      2
2  MM1  S3    cb      5
3  MM2  S3    mk      8
4  MM2  S4    bg     10
5  MM2  S4   dgd      1
6  MM4  S2    rd      2
7  MM4  S2    cb      2
8  MM4  S2   uyi      7

In [2]: df.groupby(['Sp', 'Mt'])['count'].max()
Out[2]:
Sp   Mt
MM1  S1     3
     S3     5
MM2  S3     8
     S4    10
MM4  S2     7
Name: count, dtype: int64
</code></pre>
<p>To get the indices of the original DF you can do:</p>
<pre><code>In [3]: idx = df.groupby(['Sp', 'Mt'])['count'].transform(max) == df['count']

In [4]: df[idx]
Out[4]:
    Sp  Mt Value  count
0  MM1  S1     a      3
2  MM1  S3    cb      5
3  MM2  S3    mk      8
4  MM2  S4    bg     10
8  MM4  S2   uyi      7
</code></pre>
<p>Note that if you have multiple max values per group, all will be returned.</p>
<hr />
<p><strong>Update</strong></p>
<p>On a Hail Mary chance that this is what the OP is requesting:</p>
<pre><code>In [5]: df['count_max'] = df.groupby(['Sp', 'Mt'])['count'].transform(max)

In [6]: df
Out[6]:
    Sp  Mt Value  count  count_max
0  MM1  S1     a      3          3
1  MM1  S1     n      2          3
2  MM1  S3    cb      5          5
3  MM2  S3    mk      8          8
4  MM2  S4    bg     10         10
5  MM2  S4   dgd      1         10
6  MM4  S2    rd      2          7
7  MM4  S2    cb      2          7
8  MM4  S2   uyi      7          7
</code></pre>
"
2953843,"<p>you can use always:</p>

<pre><code>'C:/mydir'
</code></pre>

<p>this works both in linux and windows.
Other posibility is</p>

<pre><code>'C:\\mydir'
</code></pre>

<p>if you have problems with some names you can also try raw string literals:</p>

<pre><code>r'C:\mydir'
</code></pre>

<p>however best practice is to use the <code>os.path</code> module functions that always select the correct configuration for your OS:</p>

<pre><code>os.path.join(mydir, myfile)
</code></pre>

<p>From python 3.4 you can also use the <a href=""https://docs.python.org/3/library/pathlib.html#operators"" rel=""noreferrer"">pathlib</a> module. This is equivelent to the above:</p>

<pre><code>pathlib.Path(mydir, myfile)
</code></pre>

<p>or</p>

<pre><code>pathlib.Path(mydir) / myfile
</code></pre>
"
902417,"<pre><code>cursor.execute(&quot;INSERT INTO table VALUES (%s, %s, %s)&quot;, (var1, var2, var3))
</code></pre>
<p>Note that the parameters are passed as a tuple, <code>(a, b, c)</code>. If you're passing a single parameter, the tuple needs to end with a comma, <code>(a,)</code>.</p>
<p>The database API does proper escaping and quoting of variables. Be careful not to use the string formatting operator (<code>%</code>), because</p>
<ol>
<li>It does not do any escaping or quoting.</li>
<li>It is prone to uncontrolled string format attacks e.g. <a href=""http://en.wikipedia.org/wiki/SQL_injection"" rel=""nofollow noreferrer"">SQL injection</a>.</li>
</ol>
"
133024,"<p><code>is</code> will return <code>True</code> if two variables point to the same object (in memory), <code>==</code> if the objects referred to by the variables are equal.</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; b is a 
True
&gt;&gt;&gt; b == a
True

# Make a new copy of list `a` via the slice operator, 
# and assign it to variable `b`
&gt;&gt;&gt; b = a[:] 
&gt;&gt;&gt; b is a
False
&gt;&gt;&gt; b == a
True
</code></pre>
<p>In your case, the second test only works because Python caches small integer objects, which is an implementation detail. For larger integers, this does not work:</p>
<pre><code>&gt;&gt;&gt; 1000 is 10**3
False
&gt;&gt;&gt; 1000 == 10**3
True
</code></pre>
<p>The same holds true for string literals:</p>
<pre><code>&gt;&gt;&gt; &quot;a&quot; is &quot;a&quot;
True
&gt;&gt;&gt; &quot;aa&quot; is &quot;a&quot; * 2
True
&gt;&gt;&gt; x = &quot;a&quot;
&gt;&gt;&gt; &quot;aa&quot; is x * 2
False
&gt;&gt;&gt; &quot;aa&quot; is intern(x*2)
True
</code></pre>
<p>Please see <a href=""https://stackoverflow.com/questions/26595/is-there-any-difference-between-foo-is-none-and-foo-none"">this question</a> as well.</p>
"
,
1301369,"<h2>Single Underscore</h2>
<p>In a class, names with a leading underscore indicate to other programmers that the attribute or method is intended to be be used inside that class. However, privacy is not <em>enforced</em> in any way.
Using leading underscores for functions in a module indicates it should not be imported from somewhere else.</p>
<p>From the <a href=""http://www.python.org/dev/peps/pep-0008/"" rel=""noreferrer"">PEP-8</a> style guide:</p>
<blockquote>
<p><code>_single_leading_underscore</code>: weak &quot;internal use&quot; indicator. E.g. <code>from M import *</code> does not import objects whose name starts with an underscore.</p>
</blockquote>
<h2>Double Underscore (Name Mangling)</h2>
<p>From <a href=""https://docs.python.org/3/tutorial/classes.html#private-variables"" rel=""noreferrer"">the Python docs</a>:</p>
<blockquote>
<p>Any identifier of the form <code>__spam</code> (at least two leading underscores, at most one trailing underscore) is textually replaced with <code>_classname__spam</code>, where <code>classname</code> is the current class name with leading underscore(s) stripped. This mangling is done without regard to the syntactic position of the identifier, so it can be used to define class-private instance and class variables, methods, variables stored in globals, and even variables stored in instances. private to this class on instances of other classes.</p>
</blockquote>
<p>And a warning from the same page:</p>
<blockquote>
<p>Name mangling is intended to give classes an easy way to define âprivateâ instance variables and methods, without having to worry about instance variables defined by derived classes, or mucking with instance variables by code outside the class. Note that the mangling rules are designed mostly to avoid accidents; <em>it still is possible for a determined soul to access or modify a variable that is considered private.</em></p>
</blockquote>
<h2>Example</h2>
<pre><code>&gt;&gt;&gt; class MyClass():
...     def __init__(self):
...             self.__superprivate = &quot;Hello&quot;
...             self._semiprivate = &quot;, world!&quot;
...
&gt;&gt;&gt; mc = MyClass()
&gt;&gt;&gt; print mc.__superprivate
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: myClass instance has no attribute '__superprivate'
&gt;&gt;&gt; print mc._semiprivate
, world!
&gt;&gt;&gt; print mc.__dict__
{'_MyClass__superprivate': 'Hello', '_semiprivate': ', world!'}
</code></pre>
"
18415320,"<p>There is a third party library for this on PyPI called <a href=""https://github.com/SethMMorton/natsort"" rel=""nofollow noreferrer"">natsort</a> (full disclosure, I am the package's author).  For your case, you can do either of the following:</p>
<pre><code>&gt;&gt;&gt; from natsort import natsorted, ns
&gt;&gt;&gt; x = ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']
&gt;&gt;&gt; natsorted(x, key=lambda y: y.lower())
['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']
&gt;&gt;&gt; natsorted(x, alg=ns.IGNORECASE)  # or alg=ns.IC
['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']
</code></pre>
<p>You should note that <code>natsort</code> uses a general algorithm so it should work for just about any input that you throw at it. If you want more details on why you might choose a library to do this rather than rolling your own function, check out the <code>natsort</code> documentation's <a href=""http://natsort.readthedocs.io/en/stable/howitworks.html"" rel=""nofollow noreferrer"">How It Works</a> page, in particular the <a href=""http://natsort.readthedocs.io/en/stable/howitworks.html#special-cases-everywhere"" rel=""nofollow noreferrer"">Special Cases Everywhere!</a> section.</p>
<hr />
<p>If you need a sorting key instead of a sorting function, use either of the below formulas.</p>
<pre><code>&gt;&gt;&gt; from natsort import natsort_keygen, ns
&gt;&gt;&gt; l1 = ['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']
&gt;&gt;&gt; l2 = l1[:]
&gt;&gt;&gt; natsort_key1 = natsort_keygen(key=lambda y: y.lower())
&gt;&gt;&gt; l1.sort(key=natsort_key1)
&gt;&gt;&gt; l1
['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']
&gt;&gt;&gt; natsort_key2 = natsort_keygen(alg=ns.IGNORECASE)
&gt;&gt;&gt; l2.sort(key=natsort_key2)
&gt;&gt;&gt; l2
['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']
</code></pre>
<hr />
<p><strong>Update November 2020</strong></p>
<p>Given that a popular request/question is &quot;how to sort like Windows Explorer?&quot; (or whatever is your operating system's file system browser), as of <code>natsort</code> version 7.1.0 there is a function called <a href=""https://natsort.readthedocs.io/en/stable/api.html#natsort.os_sorted"" rel=""nofollow noreferrer""><code>os_sorted</code></a> to do exactly this. On Windows, it will sort in the same order as Windows Explorer, and on other operating systems it should sort like whatever is the local file system browser.</p>
<pre class=""lang-py prettyprint-override""><code>&gt;&gt;&gt; from natsort import os_sorted
&gt;&gt;&gt; os_sorted(list_of_paths)
# your paths sorted like your file system browser
</code></pre>
<p>For those needing a sort key, you can use <code>os_sort_keygen</code> (or <code>os_sort_key</code> if you just need the defaults).</p>
<p><em>Caveat</em> - Please read the API documentation for this function before you use to understand the limitations and how to get best results.</p>
"
7961390,"<p>The common approach to get a unique collection of items is to use a <a href=""http://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset"" rel=""noreferrer""><code>set</code></a>. Sets are <em>unordered</em> collections of <em>distinct</em> objects. To create a set from any iterable, you can simply pass it to the built-in <a href=""http://docs.python.org/3/library/functions.html#func-set"" rel=""noreferrer""><code>set()</code></a> function. If you later need a real list again, you can similarly pass the set to the <a href=""http://docs.python.org/3/library/functions.html#func-list"" rel=""noreferrer""><code>list()</code></a> function.</p>
<p>The following example should cover whatever you are trying to do:</p>
<pre><code>&gt;&gt;&gt; t = [1, 2, 3, 1, 2, 3, 5, 6, 7, 8]
&gt;&gt;&gt; list(set(t))
[1, 2, 3, 5, 6, 7, 8]
&gt;&gt;&gt; s = [1, 2, 3]
&gt;&gt;&gt; list(set(t) - set(s))
[8, 5, 6, 7]
</code></pre>
<p>As you can see from the example result, <em>the original order is not maintained</em>. As mentioned above, sets themselves are unordered collections, so the order is lost. When converting a set back to a list, an arbitrary order is created.</p>
<h3>Maintaining order</h3>
<p>If order is important to you, then you will have to use a different mechanism. A very common solution for this is to rely on <a href=""https://docs.python.org/3/library/collections.html#collections.OrderedDict"" rel=""noreferrer""><code>OrderedDict</code></a> to keep the order of keys during insertion:</p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; list(OrderedDict.fromkeys(t))
[1, 2, 3, 5, 6, 7, 8]
</code></pre>
<p><a href=""https://mail.python.org/pipermail/python-dev/2017-December/151283.html"" rel=""noreferrer"">Starting with Python 3.7</a>, the built-in dictionary is guaranteed to maintain the insertion order as well, so you can also use that directly if you are on Python 3.7 or later (or CPython 3.6):</p>
<pre><code>&gt;&gt;&gt; list(dict.fromkeys(t))
[1, 2, 3, 5, 6, 7, 8]
</code></pre>
<p>Note that this may have some overhead of creating a dictionary first, and then creating a list from it. If you donât actually need to preserve the order, youâre often better off using a set, especially because it gives you a lot more operations to work with. Check out <a href=""https://stackoverflow.com/q/480214/216074"">this question</a> for more details and alternative ways to preserve the order when removing duplicates.</p>
<hr />
<p>Finally note that both the <code>set</code> as well as the <code>OrderedDict</code>/<code>dict</code> solutions require your items to be <em>hashable</em>. This usually means that they have to be immutable. If you have to deal with items that are not hashable (e.g. list objects), then you will have to use a slow approach in which you will basically have to compare every item with every other item in a nested loop.</p>
"
32825482,"<p>You can't use global variables to hold this sort of data. Not only is it not thread safe, it's not <em>process</em> safe, and WSGI servers in production spawn multiple processes. Not only would your counts be wrong if you were using threads to handle requests, they would also vary depending on which process handled the request.</p>

<p>Use a data source outside of Flask to hold global data. A database, memcached, or redis are all appropriate separate storage areas, depending on your needs. If you need to load and access Python data, consider <a href=""https://stackoverflow.com/a/28426819""><code>multiprocessing.Manager</code></a>. You could also use the session for simple data that is per-user.</p>

<hr>

<p>The development server may run in single thread and process. You won't see the behavior you describe since each request will be handled synchronously. Enable threads or processes and you will see it. <code>app.run(threaded=True)</code> or <code>app.run(processes=10)</code>. (In 1.0 the server is threaded by default.)</p>

<hr>

<p>Some WSGI servers may support gevent or another async worker. Global variables are still not thread safe because there's still no protection against most race conditions. You can still have a scenario where one worker gets a value, yields, another modifies it, yields, then the first worker also modifies it.</p>

<hr>

<p>If you need to store some global data <em>during</em> a request, you may use Flask's <a href=""http://flask.pocoo.org/docs/1.0/api/#flask.g"" rel=""noreferrer""><code>g</code> object</a>. Another common case is some top-level object that manages database connections. The distinction for this type of ""global"" is that it's unique to each request, not used <em>between</em> requests, and there's something managing the set up and teardown of the resource.</p>
"
67692,"<p>For Python 3.5+ use (<a href=""https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly"" rel=""noreferrer"">docs</a>):</p>
<pre><code>import importlib.util
import sys
spec = importlib.util.spec_from_file_location(&quot;module.name&quot;, &quot;/path/to/file.py&quot;)
foo = importlib.util.module_from_spec(spec)
sys.modules[&quot;module.name&quot;] = foo
spec.loader.exec_module(foo)
foo.MyClass()
</code></pre>
<p>For Python 3.3 and 3.4 use:</p>
<pre><code>from importlib.machinery import SourceFileLoader

foo = SourceFileLoader(&quot;module.name&quot;, &quot;/path/to/file.py&quot;).load_module()
foo.MyClass()
</code></pre>
<p>(Although this has been deprecated in Python 3.4.)</p>
<p>For Python 2 use:</p>
<pre><code>import imp

foo = imp.load_source('module.name', '/path/to/file.py')
foo.MyClass()
</code></pre>
<p>There are equivalent convenience functions for compiled Python files and DLLs.</p>
<p>See also <a href=""http://bugs.python.org/issue21436"" rel=""noreferrer"">http://bugs.python.org/issue21436</a>.</p>
"
,
19158418,"<p>This has nothing to do with Python; global variables are bad in any programming language.</p>

<p><strong>However, global constants</strong> are not conceptually the same as <strong>global variables</strong>; global constants are perfectly harmless. In Python the distinction between the two is purely by convention: <code>CONSTANTS_ARE_CAPITALIZED</code> and <code>globals_are_not</code>.</p>

<p>The reason global variables are bad is that they enable functions to have hidden (non-obvious, surprising, hard to detect, hard to diagnose) side effects, leading to an increase in complexity, potentially leading to <a href=""https://en.wikipedia.org/wiki/Spaghetti_code"" rel=""noreferrer"">Spaghetti code</a>.</p>

<p>However, sane use of global state is acceptable (as is local state and mutability) even in functional programming, either for algorithm optimization, reduced complexity, caching and memoization, or the practicality of porting structures originating in a predominantly imperative codebase.</p>

<p>All in all, your question can be answered in many ways, so your best bet is to just google ""why are global variables bad"". Some examples:</p>

<ul>
<li><a href=""http://c2.com/cgi/wiki?GlobalVariablesAreBad"" rel=""noreferrer"">Global Variables Are Bad - Wiki Wiki Web</a></li>
<li><a href=""https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil"">Why is Global State so Evil? - Software Engineering Stack Exchange</a></li>
<li><a href=""https://stackoverflow.com/questions/484635/are-global-variables-bad"">Are global variables bad?</a></li>
</ul>

<p>If you want to go deeper and find out why side effects are all about, and many other enlightening things, you should learn Functional Programming:</p>

<ul>
<li><a href=""https://en.wikipedia.org/wiki/Side_effect_(computer_science)"" rel=""noreferrer"">Side effect (computer science) - Wikipedia</a></li>
<li><a href=""https://softwareengineering.stackexchange.com/questions/15269/why-are-side-effects-considered-evil-in-functional-programming"">Why are side-effects considered evil in functional programming? - Software Engineering Stack Exchange</a></li>
<li><a href=""https://en.wikipedia.org/wiki/Functional_programming"" rel=""noreferrer"">Functional programming - Wikipedia</a></li>
</ul>
"
739665,"<p>Check out <a href=""http://docs.python.org/reference/compound_stmts.html#function"" rel=""noreferrer"">the documentation</a> to see how decorators work. Here is what you asked for:</p>
<pre><code>from functools import wraps

def makebold(fn):
    @wraps(fn)
    def wrapper(*args, **kwargs):
        return &quot;&lt;b&gt;&quot; + fn(*args, **kwargs) + &quot;&lt;/b&gt;&quot;
    return wrapper

def makeitalic(fn):
    @wraps(fn)
    def wrapper(*args, **kwargs):
        return &quot;&lt;i&gt;&quot; + fn(*args, **kwargs) + &quot;&lt;/i&gt;&quot;
    return wrapper

@makebold
@makeitalic
def hello():
    return &quot;hello world&quot;

@makebold
@makeitalic
def log(s):
    return s

print hello()        # returns &quot;&lt;b&gt;&lt;i&gt;hello world&lt;/i&gt;&lt;/b&gt;&quot;
print hello.__name__ # with functools.wraps() this returns &quot;hello&quot;
print log('hello')   # returns &quot;&lt;b&gt;&lt;i&gt;hello&lt;/i&gt;&lt;/b&gt;&quot;
</code></pre>
"
464882,"<p>Have a look at <a href=""http://docs.python.org/library/itertools.html#itertools.combinations"" rel=""noreferrer"">itertools.combinations</a>:</p>

<blockquote>
<pre><code>itertools.combinations(iterable, r)
</code></pre>
  
  <p>Return r length subsequences of elements from
  the input iterable.</p>
  
  <p>Combinations are emitted in lexicographic sort order. So, if the
  input iterable is sorted, the
  combination tuples will be produced in
  sorted order.</p>
</blockquote>

<p>Since 2.6, batteries are included!</p>
"
3294899,"<p><code>key</code> is just a variable name.  </p>

<pre><code>for key in d:
</code></pre>

<p>will simply loop over the keys in the dictionary, rather than the keys and values.  To loop over both key and value you can use the following:</p>

<p>For Python 3.x:</p>

<pre><code>for key, value in d.items():
</code></pre>

<p>For Python 2.x:</p>

<pre><code>for key, value in d.iteritems():
</code></pre>

<p>To test for yourself, change the word <code>key</code> to <code>poop</code>.</p>

<p>In Python 3.x, <code>iteritems()</code> was replaced with simply <code>items()</code>, which returns a set-like view backed by the dict, like <code>iteritems()</code> but even better. 
This is also available in 2.7 as <code>viewitems()</code>. </p>

<p>The operation <code>items()</code> will work for both 2 and 3, but in 2 it will return a list of the dictionary's <code>(key, value)</code> pairs, which will not reflect changes to the dict that happen after the <code>items()</code> call. If you want the 2.x behavior in 3.x, you can call <code>list(d.items())</code>.</p>
"
,
8949265,"<p>NoneType means that instead of an instance of whatever Class or Object you think you're working with, you've actually got <code>None</code>.  That usually means that an assignment or function call up above failed or returned an unexpected result.</p>
"
47995294,"<h2>NoSuchElementException</h2>

<p><em>selenium.common.exceptions.NoSuchElementException</em> popularly known as <code>NoSuchElementException</code> is defined as :</p>

<pre><code>exception selenium.common.exceptions.NoSuchElementException(msg=None, screen=None, stacktrace=None)
</code></pre>

<p><code>NoSuchElementException</code> is basically thrown in 2 cases as follows :</p>

<ul>
<li><p>When using :</p>

<pre><code>webdriver.find_element_by_*(""expression"")
//example : my_element = driver.find_element_by_xpath(""xpath_expression"")
</code></pre></li>
<li><p>When using :</p>

<pre><code>element.find_element_by_*(""expression"")
//example : my_element = element.find_element_by_*(""expression"")
</code></pre></li>
</ul>

<p>As per the API Docs just like any other <code>selenium.common.exceptions</code>, <code>NoSuchElementException</code> should contain the following parameters :</p>

<ul>
<li><p>msg, screen, stacktrace</p>

<pre><code>    raise exception_class(message, screen, stacktrace)
selenium.common.exceptions.NoSuchElementException: Message: no such element: Unable to locate element: {""method"":""xpath"",""selector"":"".//*[@id='create-portal-popup']/div[4]/div[1]/button[3]""}
  (Session info: chrome=61.0.3163.100)
  (Driver info: chromedriver=2.32.498550 (9dec58e66c31bcc53a9ce3c7226f0c1c5810906a),platform=Windows NT 10.0.10240 x86_64)
</code></pre></li>
</ul>

<hr>

<h2>Reason</h2>

<p>The reason for <em>NoSuchElementException</em> can be either of the following :</p>

<ul>
<li>The <em>Locator Strategy</em> you have adopted doesn't identifies any element in the <a href=""https://www.w3schools.com/js/js_htmldom.asp"" rel=""noreferrer""><strong>HTML DOM</strong></a>.</li>
<li>The <em>Locator Strategy</em> you have adopted is unable to identify the element as it is not within the browser's <a href=""https://www.w3schools.com/css/css_rwd_viewport.asp"" rel=""noreferrer"">Viewport</a>.</li>
<li>The <em>Locator Strategy</em> you have adopted identifies the element but is invisible due to presence of the attribute <strong>style=""display: none;""</strong>.</li>
<li>The <em>Locator Strategy</em> you have adopted doesn't <strong>uniquely</strong> identifies the desired element in the <em>HTML DOM</em> and currently finds some other <em>hidden</em> / <em>invisible</em> element.</li>
<li>The <em>WebElement</em> you are trying to locate is within an <code>&lt;iframe&gt;</code> tag.</li>
<li>The <em>WebDriver</em> instance is looking out for the <em>WebElement</em> even before the element is present/visibile within the <em>HTML DOM</em>.</li>
</ul>

<hr>

<h2>Solution</h2>

<p>The solution to address <em>NoSuchElementException</em> can be either of the following :</p>

<ul>
<li><p>Adopt a <a href=""https://stackoverflow.com/questions/48369043/official-locator-strategies-for-the-webdriver/48376890#48376890"">Locator Strategy</a> which uniquely identifies the desired <em>WebElement</em>. You can take help of the <em>Developer Tools</em> (<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>I</kbd> or <kbd>F12</kbd>) and use <em>Element Inspector</em>. </p>

<p>Here you will find a detailed discussion on <a href=""https://stackoverflow.com/questions/46700764/how-to-inspect-element-in-selenium3-6-as-firebug-is-not-an-option-any-more-for-f/46702281#46702281"">how to inspect element in selenium3.6 as firebug is not an option any more for FF 56?</a></p></li>
<li><p>Use <a href=""https://seleniumhq.github.io/selenium/docs/api/py/webdriver_remote/selenium.webdriver.remote.webdriver.html#selenium.webdriver.remote.webdriver.WebDriver.execute_script"" rel=""noreferrer""><strong><code>execute_script()</code></strong></a> method to scroll the element in to view as follows :</p>

<pre><code>elem = driver.find_element_by_xpath(""element_xpath"")
driver.execute_script(""arguments[0].scrollIntoView();"", elem)
</code></pre>

<p>Here you will find a detailed discussion on <a href=""https://stackoverflow.com/questions/45576958/scrolling-to-top-of-the-page-in-python-using-selenium/45581830#45581830"">Scrolling to top of the page in Python using Selenium</a></p></li>
<li><p>Incase element is having the attribute <strong>style=""display: none;""</strong>, remove the attribute  through <code>executeScript()</code> method as follows :</p>

<pre><code>elem = driver.find_element_by_xpath(""element_xpath"")
driver.execute_script(""arguments[0].removeAttribute('style')"", elem)
elem.send_keys(""text_to_send"")
</code></pre></li>
<li><p>To check if the element is within an <code>&lt;iframe&gt;</code> traverse up the <em>HTML</em> to locate the respective <code>&lt;iframe&gt;</code> tag and <code>switchTo()</code> the desired <em>iframe</em> through either of the following methods :</p>

<pre><code>driver.switch_to.frame(""iframe_name"")
driver.switch_to.frame(""iframe_id"")
driver.switch_to.frame(1) // 1 represents frame index
</code></pre>

<p>Here you can find a detailed discussion on <a href=""https://stackoverflow.com/questions/47770144/how-can-i-select-a-html-element-no-matter-what-frame-it-is-in-in-selenium/47771879#47771879"">How can I select a html element no matter what frame it is in in selenium?</a>.</p></li>
<li><p>If the element is not <em>present</em>/<em>visible</em> in the <em>HTML DOM</em> immediately, induce <a href=""https://seleniumhq.github.io/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.wait.html#module-selenium.webdriver.support.wait"" rel=""noreferrer"">WebDriverWait</a> with <a href=""https://seleniumhq.github.io/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html#module-selenium.webdriver.support.expected_conditions"" rel=""noreferrer"">expected_conditions</a> set to proper method as follows :</p>

<ul>
<li><p>To wait for <a href=""https://seleniumhq.github.io/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html#selenium.webdriver.support.expected_conditions.presence_of_element_located"" rel=""noreferrer""><strong>presence_of_element_located</strong></a> :</p>

<pre><code>element = WebDriverWait(driver, 20).until(expected_conditions.presence_of_element_located((By.XPATH, ""element_xpath']"")))
</code></pre></li>
<li><p>To wait for <a href=""https://seleniumhq.github.io/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html#selenium.webdriver.support.expected_conditions.visibility_of_element_located"" rel=""noreferrer""><strong>visibility_of_element_located</strong></a> :</p>

<pre><code>element = WebDriverWait(driver, 20).until(expected_conditions.visibility_of_element_located((By.CSS_SELECTOR, ""element_css"")
</code></pre></li>
<li><p>To wait for <a href=""https://seleniumhq.github.io/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html#selenium.webdriver.support.expected_conditions.element_to_be_clickable"" rel=""noreferrer""><strong>element_to_be_clickable</strong></a> :</p>

<pre><code>element = WebDriverWait(driver, 20).until(expected_conditions.element_to_be_clickable((By.LINK_TEXT, ""element_link_text"")))
</code></pre></li>
</ul></li>
</ul>

<hr>

<h2>This Usecase</h2>

<p>You are seeing <code>NoSuchElementException</code> because the <em>id</em> locator doesn't identifies the <strong>canvas</strong> uniquely. To identify the canvas and <code>click()</code> on it you have to wait for the <strong>canvas</strong> to be <code>clickable</code> and to achieve that you can use the following code block :</p>

<pre><code>WebDriverWait(driver, 20).until(EC.element_to_be_clickable((By.XPATH, ""//canvas[@id='window1']""))).click()
</code></pre>

<hr>

<h2>Reference</h2>

<p>You can find <a href=""https://stackoverflow.com/questions/54459701/what-is-selenium-and-what-is-webdriver/54482491#54482491"">Selenium</a>'s <a href=""/questions/tagged/java"" class=""post-tag"" title=""show questions tagged &#39;java&#39;"" rel=""tag"">java</a> client based relevant discussion in:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/48471321/nosuchelementexception-selenium-unable-to-locate-element/48472940#48472940"">NoSuchElementException, Selenium unable to locate element</a></li>
</ul>
"
522578,"<p>Use the built-in function <a href=""https://docs.python.org/3/library/functions.html#enumerate"" rel=""noreferrer"" title=""enumerate""><code>enumerate()</code></a>:</p>
<pre><code>for idx, x in enumerate(xs):
    print(idx, x)
</code></pre>
<p>It is <em><a href=""https://stackoverflow.com/questions/25011078/what-does-pythonic-mean"">non-pythonic</a></em> to manually index via <code>for i in range(len(xs)): x = xs[i]</code> or manually manage an additional state variable.</p>
<p>Check out <a href=""https://www.python.org/dev/peps/pep-0279/"" rel=""noreferrer"" title=""PEP 279"">PEP 279</a> for more.</p>
"
3172488,"<p>The benefit of not calling via the shell is that you are not invoking a 'mystery program.'  On POSIX, the environment variable <code>SHELL</code> controls which binary is invoked as the ""shell.""  On Windows, there is no bourne shell descendent, only cmd.exe.</p>

<p>So invoking the shell invokes a program of the user's choosing and is platform-dependent.  Generally speaking, avoid invocations via the shell.</p>

<p>Invoking via the shell does allow you to expand environment variables and file globs according to the shell's usual mechanism.  On POSIX systems, the shell expands file globs to a list of files.  On Windows, a file glob (e.g., ""*.*"") is not expanded by the shell, anyway (but environment variables on a command line <em>are</em> expanded by cmd.exe).</p>

<p>If you think you want environment variable expansions and file globs, research the <code>ILS</code> attacks of 1992-ish on network services which performed subprogram invocations via the shell.  Examples include the various <code>sendmail</code> backdoors involving <code>ILS</code>.</p>

<p>In summary, use <code>shell=False</code>.</p>
"
39983806,"<p>As the comments described, it just refers to values which are evaluated to True or False.</p>

<p>For instance, to see if a list is not empty, instead of checking like this:</p>

<pre><code>if len(my_list) != 0:
   print(""Not empty!"")
</code></pre>

<p>You can simply do this:</p>

<pre><code>if my_list:
   print(""Not empty!"")
</code></pre>

<p>This is because some values, such as empty lists, are considered False when evaluated for a boolean value. Non-empty lists are True.</p>

<p>Similarly for the integer 0, the empty string """", and so on, for False, and non-zero integers, non-empty strings, and so on, for True.</p>

<p>The idea of terms like ""truthy"" and ""falsy"" simply refer to those values which are considered True in cases like those described above, and those which are considered False.</p>

<p>For example, an empty list (<code>[]</code>) is considered ""falsy"", and a non-empty list (for example, <code>[1]</code>) is considered ""truthy"".</p>

<p>See also <a href=""https://docs.python.org/3/library/stdtypes.html#truth-value-testing"" rel=""noreferrer"">this section of the documentation</a>.</p>
"
582337,"<p>Python includes a profiler called <a href=""https://docs.python.org/3/library/profile.html#module-cProfile"" rel=""noreferrer"">cProfile</a>. It not only gives the total running time, but also times each function separately, and tells you how many times each function was called, making it easy to determine where you should make optimizations.</p>

<p>You can call it from within your code, or from the interpreter, like this:</p>

<pre><code>import cProfile
cProfile.run('foo()')
</code></pre>

<p>Even more usefully, you can invoke the cProfile when running a script:</p>

<pre><code>python -m cProfile myscript.py
</code></pre>

<p>To make it even easier, I made a little batch file called 'profile.bat':</p>

<pre><code>python -m cProfile %1
</code></pre>

<p>So all I have to do is run:</p>

<pre><code>profile euler048.py
</code></pre>

<p>And I get this:</p>

<pre class=""lang-none prettyprint-override""><code>1007 function calls in 0.061 CPU seconds

Ordered by: standard name
ncalls  tottime  percall  cumtime  percall filename:lineno(function)
    1    0.000    0.000    0.061    0.061 &lt;string&gt;:1(&lt;module&gt;)
 1000    0.051    0.000    0.051    0.000 euler048.py:2(&lt;lambda&gt;)
    1    0.005    0.005    0.061    0.061 euler048.py:2(&lt;module&gt;)
    1    0.000    0.000    0.061    0.061 {execfile}
    1    0.002    0.002    0.053    0.053 {map}
    1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler objects}
    1    0.000    0.000    0.000    0.000 {range}
    1    0.003    0.003    0.003    0.003 {sum}
</code></pre>

<p>EDIT: Updated link to a good video resource from PyCon 2013 titled 
<a href=""https://web.archive.org/web/20170318204046/http://lanyrd.com/2013/pycon/scdywg/"" rel=""noreferrer""><strong><em>Python Profiling</em></strong></a><br>
<a href=""https://www.youtube.com/watch?v=QJwVYlDzAXs"" rel=""noreferrer"">Also via YouTube</a>.</p>
"
448279,"<p>It used to be a required part of a package (<a href=""https://docs.python.org/3/reference/import.html#regular-packages"" rel=""noreferrer"">old, pre-3.3 ""regular package""</a>, not <a href=""https://docs.python.org/3/reference/import.html#namespace-packages"" rel=""noreferrer"">newer 3.3+ ""namespace package""</a>).</p>

<p><a href=""https://docs.python.org/3/reference/import.html#regular-packages"" rel=""noreferrer"">Here's the documentation.</a></p>

<blockquote>
  <p>Python defines two types of packages, regular packages and namespace packages. Regular packages are traditional packages as they existed in Python 3.2 and earlier. A regular package is typically implemented as a directory containing an <code>__init__.py</code> file. When a regular package is imported, this <code>__init__.py</code> file is implicitly executed, and the objects it defines are bound to names in the packageâs namespace. The <code>__init__.py</code> file can contain the same Python code that any other module can contain, and Python will add some additional attributes to the module when it is imported.</p>
</blockquote>

<p>But just click the link, it contains an example, more information, and an explanation of namespace packages, the kind of packages without <code>__init__.py</code>.</p>
"
379910,"<pre><code>&gt;&gt;&gt; a = ""545.2222""
&gt;&gt;&gt; float(a)
545.22220000000004
&gt;&gt;&gt; int(float(a))
545
</code></pre>
"
3071,"<p>Given a module <code>foo</code> with method <code>bar</code>:</p>
<pre><code>import foo
bar = getattr(foo, 'bar')
result = bar()
</code></pre>
<p><a href=""https://docs.python.org/library/functions.html#getattr"" rel=""noreferrer""><code>getattr</code></a> can similarly be used on class instance bound methods, module-level methods, class methods... the list goes on.</p>
"
28654127,"<p><strong>UPDATE</strong><br />
From v0.20, <a href=""https://pandas.pydata.org/docs/reference/api/pandas.melt.html"" rel=""noreferrer""><code>melt</code></a> is a first order function, you can now use</p>
<pre><code>df.melt(id_vars=[&quot;location&quot;, &quot;name&quot;], 
        var_name=&quot;Date&quot;, 
        value_name=&quot;Value&quot;)

  location    name        Date  Value
0        A  &quot;test&quot;    Jan-2010     12
1        B   &quot;foo&quot;    Jan-2010     18
2        A  &quot;test&quot;    Feb-2010     20
3        B   &quot;foo&quot;    Feb-2010     20
4        A  &quot;test&quot;  March-2010     30
5        B   &quot;foo&quot;  March-2010     25
</code></pre>
<hr />
<p><strong>OLD(ER) VERSIONS: &lt;0.20</strong></p>
<p>You can use <a href=""http://pandas.pydata.org/pandas-docs/stable/generated/pandas.melt.html"" rel=""noreferrer""><code>pd.melt</code></a> to get most of the way there, and then sort:</p>
<pre><code>&gt;&gt;&gt; df
  location  name  Jan-2010  Feb-2010  March-2010
0        A  test        12        20          30
1        B   foo        18        20          25
&gt;&gt;&gt; df2 = pd.melt(df, id_vars=[&quot;location&quot;, &quot;name&quot;], 
                  var_name=&quot;Date&quot;, value_name=&quot;Value&quot;)
&gt;&gt;&gt; df2
  location  name        Date  Value
0        A  test    Jan-2010     12
1        B   foo    Jan-2010     18
2        A  test    Feb-2010     20
3        B   foo    Feb-2010     20
4        A  test  March-2010     30
5        B   foo  March-2010     25
&gt;&gt;&gt; df2 = df2.sort([&quot;location&quot;, &quot;name&quot;])
&gt;&gt;&gt; df2
  location  name        Date  Value
0        A  test    Jan-2010     12
2        A  test    Feb-2010     20
4        A  test  March-2010     30
1        B   foo    Jan-2010     18
3        B   foo    Feb-2010     20
5        B   foo  March-2010     25
</code></pre>
<p>(Might want to throw in a <code>.reset_index(drop=True)</code>, just to keep the output clean.)</p>
<p><strong>Note</strong>: <code>pd.DataFrame.sort</code> <a href=""https://stackoverflow.com/questions/44123874/dataframe-object-has-no-attribute-sort"">has been deprecated</a> in favour of <a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.sort_values.html"" rel=""noreferrer""><code>pd.DataFrame.sort_values</code></a>.</p>
"
104436,"<p>Use <a href=""https://docs.python.org/3/library/itertools.html#itertools.permutations"" rel=""noreferrer""><code>itertools.permutations</code></a> from the <strong>standard library</strong>:</p>
<pre><code>import itertools
list(itertools.permutations([1, 2, 3]))
</code></pre>
<hr />
<p>Adapted from <a href=""http://code.activestate.com/recipes/252178/"" rel=""noreferrer"">here</a> is a demonstration of how <code>itertools.permutations</code> might be implemented:</p>
<pre><code>def permutations(elements):
    if len(elements) &lt;= 1:
        yield elements
        return
    for perm in permutations(elements[1:]):
        for i in range(len(elements)):
            # nb elements[0:1] works in both string and list contexts
            yield perm[:i] + elements[0:1] + perm[i:]
</code></pre>
<p>A couple of alternative approaches are listed in the documentation of <code>itertools.permutations</code>. Here's one:</p>
<pre><code>def permutations(iterable, r=None):
    # permutations('ABCD', 2) --&gt; AB AC AD BA BC BD CA CB CD DA DB DC
    # permutations(range(3)) --&gt; 012 021 102 120 201 210
    pool = tuple(iterable)
    n = len(pool)
    r = n if r is None else r
    if r &gt; n:
        return
    indices = range(n)
    cycles = range(n, n-r, -1)
    yield tuple(pool[i] for i in indices[:r])
    while n:
        for i in reversed(range(r)):
            cycles[i] -= 1
            if cycles[i] == 0:
                indices[i:] = indices[i+1:] + indices[i:i+1]
                cycles[i] = n - i
            else:
                j = cycles[i]
                indices[i], indices[-j] = indices[-j], indices[i]
                yield tuple(pool[i] for i in indices[:r])
                break
        else:
            return
</code></pre>
<p>And another, based on <code>itertools.product</code>:</p>
<pre><code>def permutations(iterable, r=None):
    pool = tuple(iterable)
    n = len(pool)
    r = n if r is None else r
    for indices in product(range(n), repeat=r):
        if len(set(indices)) == r:
            yield tuple(pool[i] for i in indices)
</code></pre>
"
,
,
31915155,"<pre><code>s = r'abc123d, hello 3.1415926, this is my book'
print re.findall(r'-?[0-9]+(?:\.[0-9]*)?|-?\.[0-9]+',s)
</code></pre>

<p>You dont need to <strong>escape</strong> twice when you are using <strong>raw mode</strong>.</p>

<p>Output:<code>['123', '3.1415926']</code></p>

<p>Also the return type will be a list of <strong>strings</strong>. If you want return type as <strong>integers</strong> and <strong>floats</strong> use <code>map</code></p>

<pre><code>import re,ast
s = r'abc123d, hello 3.1415926, this is my book'
print map(ast.literal_eval,re.findall(r'-?[0-9]+(?:\.[0-9]*)?|-?\.[0-9]+',s))
</code></pre>

<p>Output: <code>[123, 3.1415926]</code></p>
"
45621723,"<h2>Why does indentation matter?</h2>
<p>In Python, indentation is used to delimit <a href=""https://en.wikipedia.org/wiki/Block_(programming)"" rel=""nofollow noreferrer"">blocks of code</a>. This is different from many other languages that use curly braces <code>{}</code> to delimit blocks such as Java, Javascript, and C. Because of this, Python users must pay close attention to when and how they indent their code because whitespace matters.</p>
<p>When Python encounters a problem with the indentation of your program, it either raises an exception called <a href=""https://docs.python.org/3/library/exceptions.html#IndentationError"" rel=""nofollow noreferrer""><code>IndentationError</code></a> or <a href=""https://docs.python.org/3/library/exceptions.html#TabError"" rel=""nofollow noreferrer""><code>TabError</code></a>.</p>
<p><strong>A little history</strong></p>
<p>The historical reasons for why Python uses indentation vs the arguably more commonly accepted curly braces <code>{}</code> is outlined in <a href=""http://python-history.blogspot.com/2009/02/early-language-design-and-development.html"" rel=""nofollow noreferrer"">an article of the history of Python by Guido van Rossum</a> - the creator of Python:</p>
<blockquote>
<p>Pythonâs use of indentation comes directly from ABC, but this idea didnât originate with ABC--it had already been promoted by Donald Knuth and was a well-known concept of programming style. (The occam programming language also used it.) However, ABCâs authors did invent the use of the colon that separates the lead-in clause from the indented block. After early user testing without the colon, it was discovered that the meaning of the indentation was unclear to beginners being taught the first steps of programming. The addition of the colon clarified it significantly: the colon somehow draws attention to what follows and ties the phrases before and after it together in just the right way.</p>
</blockquote>
<h2>How do I indent my code?</h2>
<p>The basic rule for indenting Python code (considering that you treat the entire program as a &quot;basic block&quot;) is: The first statement in a basic block, and each subsequent statement after it must be indented by the same amount.</p>
<p>So technically the following Python program is correct:</p>
<pre><code>def perm(l):
        # Compute the list of all permutations of l
    if len(l) &lt;= 1:
                  return [l]
    r = []
    for i in range(len(l)):
             s = l[:i] + l[i+1:]
             p = perm(s)
             for x in p:
              r.append(l[i:i+1] + x)
    return r
</code></pre>
<p>However, as you can probably tell from above, randomly indenting your code makes is extremely hard to read and follow the flow of the program. It's better to be consistent and follow a style.</p>
<p><a href=""https://www.python.org/dev/peps/pep-0008/#indentation"" rel=""nofollow noreferrer"">PEP 8 -- the Python style guide -- says</a>:</p>
<blockquote>
<p>Use 4 spaces per indentation level.</p>
</blockquote>
<p>That is, <strong>each statement that is starting a new block and each subsequent statement in the new block, should be indented four spaces from the current indentation level</strong>. Here is the above program indented according to the PEP8 style guide:</p>
<pre><code>def perm(l):
    # Compute the list of all permutations of l
    if len(l) &lt;= 1:
        return [l]
    r = []
    for i in range(len(l)):
        s = l[:i] + l[i+1:]
        p = perm(s)
        for x in p:
            r.append(l[i:i+1] + x)
    return r
</code></pre>
<h2>Can I still use tabs?</h2>
<p>Python realizes that some people still prefer tabs over spaces and that legacy code may use tabs rather than spaces, so it allows the use of tabs as indentation. <a href=""https://www.python.org/dev/peps/pep-0008/#tabs-or-spaces"" rel=""nofollow noreferrer"">PEP8 touches on this topic</a>:</p>
<blockquote>
<p>Spaces are the preferred indentation method.</p>
<p>Tabs should be used solely to remain consistent with code that is already indented with tabs.</p>
</blockquote>
<p>Note however the one big caveat is <strong>not to use both tabs <em>and</em> spaces for indentation</strong>. Doing so can cause all kinds of strange hard to debug indentation errors. Python <a href=""https://stackoverflow.com/questions/2034517"">expands tabs to the next 8th column</a>, but if your editor is set to a tab size of 4 columns, or you you use spaces as well as tabs, you can easily produce indented code that <em>looks</em> fine  in your editor, but Python will refuse to run. The Python 3 compiler <em>explicitly</em> rejects any program containing an ambiguous mixture of tabs and spaces, usually by raising a <code>TabError</code>. However, by default, mixing tabs and spaces is still allowed in Python 2, but it is highly recommended not to use this &quot;feature&quot;. Use the <code>-t</code> and <code>-tt</code> command line flags to force Python 2 to raise a warning or (preferably) an error respectively. <a href=""https://www.python.org/dev/peps/pep-0008/#tabs-or-spaces"" rel=""nofollow noreferrer"">PEP8 also discusses this topic</a>:</p>
<blockquote>
<p>Python 3 disallows mixing the use of tabs and spaces for indentation.</p>
<p>Python 2 code indented with a mixture of tabs and spaces should be converted to using spaces exclusively.</p>
<p>When invoking the Python 2 command line interpreter with the -t option, it issues warnings about code that illegally mixes tabs and spaces. When using -tt these warnings become errors. These options are highly recommended!</p>
</blockquote>
<h2>What does &quot;IndentationError: unexpected indent&quot; mean?</h2>
<p><strong>Problem</strong></p>
<p>This error occurs when a statement is unnecessarily indented or its indentation does not match the indentation of former statements in the same block. For example, the first statement in the program below is unnecessarily indented:</p>
<pre><code>&gt;&gt;&gt;  print('Hello') # this is indented 
  File &quot;&lt;stdin&gt;&quot;, line 1
    print('Hello') # this is indented 
    ^
IndentationError: unexpected indent
</code></pre>
<p>In this example, the <code>can_drive = True</code> line in the <code>if</code> block does not match the indentation of any former statement:</p>
<pre><code>&gt;&gt;&gt; age = 10
&gt;&gt;&gt; can_drive = None
&gt;&gt;&gt; 
&gt;&gt;&gt; if age &gt;= 18:
...     print('You can drive')
...      can_drive = True # incorrectly indented
  File &quot;&lt;stdin&gt;&quot;, line 3
    can_drive = True # incorrectly indented
    ^
IndentationError: unexpected indent
</code></pre>
<p><strong>Fix</strong></p>
<p>The fix for this error is to first make sure the problematic line even needs to be indented. For example, the above example using <code>print</code> can be fixed simply be unindenting the line:</p>
<pre><code>&gt;&gt;&gt; print('Hello') # simply unindent the line
Hello
</code></pre>
<p>However, if you are sure the line does need to be indented, the indentation needs to match that of a former statement in the same block. In the second example above using <code>if</code>, we can fix the error by making sure the line with <code>can_drive = True</code> is indented at the same level as the former statements in the <code>if</code> body:</p>
<pre><code>&gt;&gt;&gt; age = 10
&gt;&gt;&gt; can_drive = None
&gt;&gt;&gt; 
&gt;&gt;&gt; if age &gt;= 18:
...     print('You can drive')
...     can_drive = True # indent this line at the same level.
... 
</code></pre>
<h2>What does &quot;IndentationError: expected an indented block&quot; mean?</h2>
<p>(This might also occur as <code>SyntaxError: unexpected EOF while parsing</code> in Python 3.8 or lower.)</p>
<p><strong>Problem</strong></p>
<p>This error occurs when Python sees the 'header' for a compound statement, such as <code>if &lt;condition&gt;:</code> or <code>while &lt;condition&gt;:</code> but the compound statement's body or <strong><em>block</em></strong> is never defined. For example in the code below we began an <code>if</code> statement, but we never define a body for the statement:</p>
<pre><code>&gt;&gt;&gt; if True:
... 
  File &quot;&lt;stdin&gt;&quot;, line 2
    
    ^
IndentationError: expected an indented block
</code></pre>
<p>In this second example, we began writing a <code>for</code> loop, but we forget to indent the <code>for</code> loop body. So Python still expects an indented block for the <code>for</code> loop body:</p>
<pre><code>&gt;&gt;&gt; names = ['sarah', 'lucy', 'michael']
&gt;&gt;&gt; for name in names:
... print(name)
  File &quot;&lt;stdin&gt;&quot;, line 2
    print(name)
        ^
IndentationError: expected an indented block
</code></pre>
<p>Comments don't count as bodies:</p>
<pre><code>&gt;&gt;&gt; if True:
...     # TODO
...
  File &quot;&lt;stdin&gt;&quot;, line 3

    ^
IndentationError: expected an indented block
</code></pre>
<p><strong>Fix</strong></p>
<p>The fix for this error is to simply include a body for the compound statement.</p>
<p>As shown above, a common mistake by new users is that they forget to indent the body. If this is the case, make sure each statement meant to be included in the compound statement's body is indented at the same level under the compound statement's beginning. Here is the above example fixed:</p>
<pre><code>&gt;&gt;&gt; names = ['sarah', 'lucy', 'michael']
&gt;&gt;&gt; for name in names:
...     print(name) # The for loop body is now correctly indented.
... 
sarah
lucy
michael
</code></pre>
<p>Another common case is that, for some reason, a user may not want to define an actual body for the compound statement, or the body may be commented out. In this case, the <a href=""https://docs.python.org/3/reference/simple_stmts.html#grammar-token-pass_stmt"" rel=""nofollow noreferrer""><code>pass</code></a> statement can be used. The <code>pass</code> statement can be used anywhere Python expects one or more statements as a placeholder. <a href=""https://docs.python.org/3/reference/simple_stmts.html#the-pass-statement"" rel=""nofollow noreferrer"">From the documentation for <code>pass</code></a>:</p>
<blockquote>
<p>pass is a null operation â when it is executed, nothing happens. It is useful as a placeholder when a statement is required syntactically, but no code needs to be executed, for example:</p>
<pre><code>def f(arg): pass    # a function that does nothing (yet)

class C: pass       # a class with no methods (yet)
</code></pre>
</blockquote>
<p>Here is the above example with the <code>if</code> statement fixed by using the <code>pass</code> keyword:</p>
<pre><code>&gt;&gt;&gt; if True:
...     pass # We don't want to define a body.
... 
&gt;&gt;&gt; 
</code></pre>
<h2>What does &quot;IndentationError: unindent does not match any outer indentation level&quot; mean?</h2>
<p><strong>Problem</strong></p>
<p>This error occurs when you unindent a statement, but now the indentation level of that statement does not match that of any former statement. For example, in the below code we unindent the second call to <code>print</code>. However, the indentation level does not match that of any former statement:</p>
<pre><code>&gt;&gt;&gt; if True:
...     if True:
...         print('yes')
...    print()
  File &quot;&lt;stdin&gt;&quot;, line 4
    print()
          ^
IndentationError: unindent does not match any outer indentation level
</code></pre>
<p>This error is especially hard to catch because even one space will cause your code to fail.</p>
<p><strong>Fix</strong></p>
<p>The fix is to ensure that when you unindent a statement, the indentation level matches that of a former statement. Consider the above example once again. In the example, I want the second call to print to be in the first <code>if</code> statements body. So I need to make sure that that line's indentation level matches that of the former statements in the first <code>if</code> statement's body:</p>
<pre><code>&gt;&gt;&gt; if True:
...     if True:
...         print('yes')
...     print() # indentation level now matches former statement's level.
... 
yes

&gt;&gt;&gt; 
</code></pre>
<h2>I'm still getting an IndentationError but my program appears to be correctly indented. What do I do?</h2>
<p>If your program visually appears to have correct indentation, but your still getting an <code>IndentationError</code> you have most likely <strong>mixed tabs with spaces</strong>. This will sometimes cause Python to raises strange errors. See the subsection <strong><em>Special cases</em></strong> under <strong><em>What does &quot;TabError: inconsistent use of tabs and spaces in indentation&quot; mean?</em></strong> for an more in-depth explanation of the problem.</p>
<h2>What does &quot;TabError: inconsistent use of tabs and spaces in indentation&quot; mean?</h2>
<p><strong>Problem</strong></p>
<p>This error only occurs when you attempt to mix tabs and spaces as indentation characters. As said above, Python will not allow your program to contain a mix of tabs and spaces, and will raise the specific exception <code>TabError</code> if it finds you have. For example, in the program below, a mix of tabs and spaces is used for indentation:</p>
<pre><code>&gt;&gt;&gt; if True:
...     if True:
...         print()
...     print()
...     print()
  File &quot;&lt;stdin&gt;&quot;, line 5
    print()
          ^
TabError: inconsistent use of tabs and spaces in indentation
</code></pre>
<p>Here is a picture which visually shows the whitespace in the above program. Gray dots are spaces, and gray arrows are tabs:</p>
<p><a href=""https://i.stack.imgur.com/pFV48.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/pFV48.png"" alt=""enter image description here"" /></a></p>
<p>We can see we have indeed mixed spaces and tabs for indentation.</p>
<p><strong>Special cases</strong></p>
<p>Note Python <strong><em>will not</em></strong> <em>always</em> raise a <code>TabError</code> if you mix tabs and spaces into your program. If the program indentation is unambiguous, Python will allow tabs and spaces to be mixed. For example:</p>
<pre><code>&gt;&gt;&gt; if True:
...     if True: # tab
...         pass # tab, then 4 spaces
... 
&gt;&gt;&gt; 
</code></pre>
<p>And sometimes Python simply chokes on the mixture of tabs and spaces and erroneously raises an <code>IndentationError</code> exception when a <code>TabError</code> would be more appropriate. Another example:</p>
<pre><code>&gt;&gt;&gt; if True:
...     pass # tab
...     pass # 4 spaces
  File &quot;&lt;stdin&gt;&quot;, line 3
    pass # 4 spaces
                ^
IndentationError: unindent does not match any outer indentation level
</code></pre>
<p>As you can see, running your code this way can create mysterious errors. Even though the program <em>visually</em> appears to be fine, Python became confused trying to parse the tabs and spaces used for indention and errored out.</p>
<p>These are excellent examples that demonstrate why to never mix tabs and spaces and make use of the <code>-t</code> and <code>-tt</code> interpreter flags when using Python 2.</p>
<p><strong>Fix</strong></p>
<p>If your program is short, probably the easiest and quickest fix is to simply re-indent the program. Make sure each statement is indented by four spaces per indention level (see <strong><em>How do I indent my code?</em></strong>).</p>
<p>However, if you already have a large program that you've mixed tabs and spaces into, there are automated tools that can be used to convert all of your indentation to just spaces.</p>
<p>Many editors such as <a href=""https://www.jetbrains.com/pycharm/"" rel=""nofollow noreferrer"">PyCharm</a> and <a href=""https://www.sublimetext.com/"" rel=""nofollow noreferrer"">SublimeText</a> have options to automatically convert tabs to spaces. There are also several on-line tools such as <a href=""http://tabstospaces.com/"" rel=""nofollow noreferrer"">Tabs To Spaces</a> or <a href=""https://www.browserling.com/tools/tabs-to-spaces"" rel=""nofollow noreferrer"">Browserling</a> that allow you to quickly re-indent your code. There are also tools written in Python. <a href=""https://github.com/hhatto/autopep8"" rel=""nofollow noreferrer"">autopep8</a> for example can automatically re-indent your code and fix other indentation errors as well.</p>
<p>Even the best tools though will sometimes not be able to fix all of your indentation errors and you'll have to fix them manually. That's why it's important to always properly indent your code from the start.</p>
<h2>A note about &quot;SyntaxError&quot; related indentation problems</h2>
<p>Although not often, sometimes certain <code>SyntaxError</code> exceptions are raised due to incorrect indentation.  For example, look at the code below:</p>
<pre><code>if True:
    pass
pass # oops! this statement should be indented!.
else:
    pass
</code></pre>
<p>When the above code is run, a <code>SyntaxError</code> is raised:</p>
<pre><code>Traceback (most recent call last):
  File &quot;python&quot;, line 4
    else:
       ^
SyntaxError: invalid syntax
</code></pre>
<p>Although Python raises a <code>SyntaxError</code>, the <em>real</em> problem with the above code is that the second <code>pass</code> statement should be indented. Because the second <code>pass</code> isn't indented, Python doesn't realize that the previous <code>if</code> statement and the <code>else</code> statement are meant to be connected.</p>
<p>The fix for this type of error is to simply correctly re-indent your code. To see how to properly indent your code, see the section <em><strong>How do I indent my code?</strong></em>.</p>
<h2>I'm still having a hard time with Python's indentation syntax. What do I do?</h2>
<p>Don't get discouraged if you're still struggling. It can take time to get use to
Python's whitespace syntax rules. Here are some tips to help:</p>
<ul>
<li>Get an editor that will tell you when you have an indentation error. Some goods ones are as said above are, <a href=""https://www.jetbrains.com/pycharm/"" rel=""nofollow noreferrer"">PyCharm</a>, <a href=""https://www.sublimetext.com/"" rel=""nofollow noreferrer"">SublimeText</a>, and <a href=""https://github.com/jupyter/notebook"" rel=""nofollow noreferrer"">Jupyter Notebook</a>.</li>
<li>When you indent your code, count out loud to yourself how many times you press the space-bar (or tab key). For example, if you needed to indent a line by four spaces, you would say out loud &quot;<em>one</em>, <em>two</em>, <em>three</em>, <em>four</em>&quot; while simultaneously pressing the space-bar each time. It sounds silly, but it helps train your brain to think about how deep you're indenting your code.</li>
<li>If you have an editor, see if it has an option to automatically convert tabs to spaces.</li>
<li>View others' code. Browse <a href=""https://github.com/"" rel=""nofollow noreferrer"">github</a> or <a href=""https://stackoverflow.com/"">Stackoverflow</a> and see examples of Python code.</li>
<li>Just write code. That's the single best way to get better. The more you write Python code, the better you'll get.</li>
</ul>
<h2>Resources used</h2>
<ul>
<li><a href=""https://en.wikipedia.org/"" rel=""nofollow noreferrer"">https://en.wikipedia.org/</a></li>
<li><a href=""https://docs.python.org/3/"" rel=""nofollow noreferrer"">https://docs.python.org/3/</a></li>
<li><a href=""http://python-history.blogspot.com/2009/02/early-language-design-and-development.html"" rel=""nofollow noreferrer"">http://python-history.blogspot.com/2009/02/early-language-design-and-development.html</a></li>
<li><a href=""https://www.python.org/dev/peps/pep-0008/"" rel=""nofollow noreferrer"">https://www.python.org/dev/peps/pep-0008/</a></li>
</ul>
"
9189193,"<p>This is because <strong>strings are immutable in Python</strong>.</p>

<p>Which means that <code>X.replace(""hello"",""goodbye"")</code> returns <strong>a copy of <code>X</code> with replacements made</strong>. Because of that you need replace this line:</p>

<pre><code>X.replace(""hello"", ""goodbye"")
</code></pre>

<p>with this line:</p>

<pre><code>X = X.replace(""hello"", ""goodbye"")
</code></pre>

<p>More broadly, <strong>this is true for all Python string methods that change a string's content ""in-place""</strong>, e.g. <code>replace</code>,<code>strip</code>,<code>translate</code>,<code>lower</code>/<code>upper</code>,<code>join</code>,...</p>

<p><strong>You must assign their output to something if you want to use it</strong> and not throw it away, e.g.</p>

<pre><code>X  = X.strip(' \t')
X2 = X.translate(...)
Y  = X.lower()
Z  = X.upper()
A  = X.join(':')
B  = X.capitalize()
C  = X.casefold()
</code></pre>

<p>and so on.</p>
"
7557028,"<p>One way is to stack the frames on top of each other, then you can simply raise one above the other in the stacking order. The one on top will be the one that is visible. This works best if all the frames are the same size, but with a little work you can get it to work with any sized frames.</p>
<p><strong>Note</strong>: for this to work, all of the widgets for a page must have that page (ie: <code>self</code>) or a descendant as a parent (or master, depending on the terminology you prefer).</p>
<p>Here's a bit of a contrived example to show you the general concept:</p>
<pre><code>try:
    import tkinter as tk                # python 3
    from tkinter import font as tkfont  # python 3
except ImportError:
    import Tkinter as tk     # python 2
    import tkFont as tkfont  # python 2

class SampleApp(tk.Tk):

    def __init__(self, *args, **kwargs):
        tk.Tk.__init__(self, *args, **kwargs)

        self.title_font = tkfont.Font(family='Helvetica', size=18, weight=&quot;bold&quot;, slant=&quot;italic&quot;)

        # the container is where we'll stack a bunch of frames
        # on top of each other, then the one we want visible
        # will be raised above the others
        container = tk.Frame(self)
        container.pack(side=&quot;top&quot;, fill=&quot;both&quot;, expand=True)
        container.grid_rowconfigure(0, weight=1)
        container.grid_columnconfigure(0, weight=1)

        self.frames = {}
        for F in (StartPage, PageOne, PageTwo):
            page_name = F.__name__
            frame = F(parent=container, controller=self)
            self.frames[page_name] = frame

            # put all of the pages in the same location;
            # the one on the top of the stacking order
            # will be the one that is visible.
            frame.grid(row=0, column=0, sticky=&quot;nsew&quot;)

        self.show_frame(&quot;StartPage&quot;)

    def show_frame(self, page_name):
        '''Show a frame for the given page name'''
        frame = self.frames[page_name]
        frame.tkraise()


class StartPage(tk.Frame):

    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)
        self.controller = controller
        label = tk.Label(self, text=&quot;This is the start page&quot;, font=controller.title_font)
        label.pack(side=&quot;top&quot;, fill=&quot;x&quot;, pady=10)

        button1 = tk.Button(self, text=&quot;Go to Page One&quot;,
                            command=lambda: controller.show_frame(&quot;PageOne&quot;))
        button2 = tk.Button(self, text=&quot;Go to Page Two&quot;,
                            command=lambda: controller.show_frame(&quot;PageTwo&quot;))
        button1.pack()
        button2.pack()


class PageOne(tk.Frame):

    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)
        self.controller = controller
        label = tk.Label(self, text=&quot;This is page 1&quot;, font=controller.title_font)
        label.pack(side=&quot;top&quot;, fill=&quot;x&quot;, pady=10)
        button = tk.Button(self, text=&quot;Go to the start page&quot;,
                           command=lambda: controller.show_frame(&quot;StartPage&quot;))
        button.pack()


class PageTwo(tk.Frame):

    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)
        self.controller = controller
        label = tk.Label(self, text=&quot;This is page 2&quot;, font=controller.title_font)
        label.pack(side=&quot;top&quot;, fill=&quot;x&quot;, pady=10)
        button = tk.Button(self, text=&quot;Go to the start page&quot;,
                           command=lambda: controller.show_frame(&quot;StartPage&quot;))
        button.pack()


if __name__ == &quot;__main__&quot;:
    app = SampleApp()
    app.mainloop()
</code></pre>
<p><a href=""https://i.stack.imgur.com/w1sVH.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/w1sVH.png"" alt=""start page"" /></a> <a href=""https://i.stack.imgur.com/xH5w5.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/xH5w5.png"" alt=""page 1"" /></a> <a href=""https://i.stack.imgur.com/339hd.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/339hd.png"" alt=""page 2"" /></a></p>
<p>If you find the concept of creating instance in a class confusing, or if different pages need different arguments during construction, you can explicitly call each class separately. The loop serves mainly to illustrate the point that each class is identical.</p>
<p>For example, to create the classes individually you can remove the loop (<code>for F in (StartPage, ...)</code> with this:</p>
<pre><code>self.frames[&quot;StartPage&quot;] = StartPage(parent=container, controller=self)
self.frames[&quot;PageOne&quot;] = PageOne(parent=container, controller=self)
self.frames[&quot;PageTwo&quot;] = PageTwo(parent=container, controller=self)

self.frames[&quot;StartPage&quot;].grid(row=0, column=0, sticky=&quot;nsew&quot;)
self.frames[&quot;PageOne&quot;].grid(row=0, column=0, sticky=&quot;nsew&quot;)
self.frames[&quot;PageTwo&quot;].grid(row=0, column=0, sticky=&quot;nsew&quot;)
</code></pre>
<hr />
<p>Over time people have asked other questions using this code (or an online tutorial that copied this code) as a starting point. You might want to read the answers to these questions:</p>
<ul>
<li><a href=""https://stackoverflow.com/q/32864610/7432"">Understanding parent and controller in Tkinter __init__</a></li>
<li><a href=""https://stackoverflow.com/q/34301300/7432"">Tkinter! Understanding how to switch frames</a></li>
<li><a href=""https://stackoverflow.com/q/32212408/7432"">How to get variable data from a class</a></li>
<li><a href=""https://stackoverflow.com/q/48731097/7432"">Calling functions from a Tkinter Frame to another</a></li>
<li><a href=""https://stackoverflow.com/q/33646605/7432"">How to access variables from different classes in tkinter?</a></li>
<li><a href=""https://stackoverflow.com/q/35029188/7432"">How would I make a method which is run every time a frame is shown in tkinter</a></li>
<li><a href=""https://stackoverflow.com/q/35991126/7432"">Tkinter Frame Resize</a></li>
<li><a href=""https://stackoverflow.com/q/39530107/7432"">Tkinter have code for pages in separate files</a></li>
<li><a href=""https://stackoverflow.com/q/45064732/7432"">Refresh a tkinter frame on button press</a></li>
</ul>
"
4855685,"<p>You know what has worked for me really well on windows.</p>

<p><code>My Computer &gt; Properties &gt; Advanced System Settings &gt; Environment Variables &gt;</code> </p>

<p>Just add the path as C:\Python27 (or wherever you installed python)</p>

<p>OR</p>

<p>Then under system variables I create a new Variable called <code>PythonPath</code>. In this variable I have <code>C:\Python27\Lib;C:\Python27\DLLs;C:\Python27\Lib\lib-tk;C:\other-folders-on-the-path</code></p>

<p><img src=""https://i.stack.imgur.com/ZGp36.png"" alt=""enter image description here""></p>

<p>This is the best way that has worked for me which I hadn't found in any of the docs offered.</p>

<p><strong>EDIT:</strong> For those who are not able to get it,
Please add </p>

<blockquote>
  <p>C:\Python27;</p>
</blockquote>

<p>along with it. Else it will <em>never work</em>.</p>
"
16044380,"<p>You can get the events from pygame and then watch out for the <code>KEYDOWN</code> event, instead of looking at the keys returned by <code>get_pressed()</code>(which gives you keys that are currently pressed down, whereas the <code>KEYDOWN</code> event shows you which keys were pressed down on <em>that frame</em>).</p>
<p>What's happening with your code right now is that if your game is rendering at 30fps, and you hold down the left arrow key for half a second, you're updating the location 15 times.</p>
<pre class=""lang-py prettyprint-override""><code>events = pygame.event.get()
for event in events:
    if event.type == pygame.KEYDOWN:
        if event.key == pygame.K_LEFT:
            location -= 1
        if event.key == pygame.K_RIGHT:
            location += 1
</code></pre>
<p>To support continuous movement while a key is being held down, you would have to establish some sort of limitation, either based on a forced maximum frame rate of the game loop or by a counter which only allows you to move every so many ticks of the loop.</p>
<pre class=""lang-py prettyprint-override""><code>move_ticker = 0
keys=pygame.key.get_pressed()
if keys[K_LEFT]:
    if move_ticker == 0:
        move_ticker = 10
        location -= 1
        if location == -1:
            location = 0
if keys[K_RIGHT]:
    if move_ticker == 0:   
        move_ticker = 10     
        location+=1
        if location == 5:
            location = 4
</code></pre>
<p>Then somewhere during the game loop you would do something like this:</p>
<pre class=""lang-py prettyprint-override""><code>if move_ticker &gt; 0:
    move_ticker -= 1
</code></pre>
<p>This would only let you move once every 10 frames (so if you move, the ticker gets set to 10, and after 10 frames it will allow you to move again)</p>
"
4706520,"<p>Set the mode in <a href=""https://docs.python.org/3/library/functions.html#open"" rel=""noreferrer""><code>open()</code></a> to <code>&quot;a&quot;</code> (append) instead of <code>&quot;w&quot;</code> (write):</p>
<pre class=""lang-py prettyprint-override""><code>with open(&quot;test.txt&quot;, &quot;a&quot;) as myfile:
    myfile.write(&quot;appended text&quot;)
</code></pre>
<p>The <a href=""https://docs.python.org/3/library/functions.html#open"" rel=""noreferrer"">documentation</a> lists all the available modes.</p>
"
2371789,"<p><a href=""https://github.com/pyparsing/pyparsing"" rel=""noreferrer"">Pyparsing</a> can be used to parse mathematical expressions. In particular, <a href=""https://github.com/pyparsing/pyparsing/blob/master/examples/fourFn.py"" rel=""noreferrer"">fourFn.py</a>
shows how to parse basic arithmetic expressions. Below, I've rewrapped fourFn into a numeric parser class for easier reuse. </p>

<pre><code>from __future__ import division
from pyparsing import (Literal, CaselessLiteral, Word, Combine, Group, Optional,
                       ZeroOrMore, Forward, nums, alphas, oneOf)
import math
import operator

__author__ = 'Paul McGuire'
__version__ = '$Revision: 0.0 $'
__date__ = '$Date: 2009-03-20 $'
__source__ = '''http://pyparsing.wikispaces.com/file/view/fourFn.py
http://pyparsing.wikispaces.com/message/view/home/15549426
'''
__note__ = '''
All I've done is rewrap Paul McGuire's fourFn.py as a class, so I can use it
more easily in other places.
'''


class NumericStringParser(object):
    '''
    Most of this code comes from the fourFn.py pyparsing example

    '''

    def pushFirst(self, strg, loc, toks):
        self.exprStack.append(toks[0])

    def pushUMinus(self, strg, loc, toks):
        if toks and toks[0] == '-':
            self.exprStack.append('unary -')

    def __init__(self):
        """"""
        expop   :: '^'
        multop  :: '*' | '/'
        addop   :: '+' | '-'
        integer :: ['+' | '-'] '0'..'9'+
        atom    :: PI | E | real | fn '(' expr ')' | '(' expr ')'
        factor  :: atom [ expop factor ]*
        term    :: factor [ multop factor ]*
        expr    :: term [ addop term ]*
        """"""
        point = Literal(""."")
        e = CaselessLiteral(""E"")
        fnumber = Combine(Word(""+-"" + nums, nums) +
                          Optional(point + Optional(Word(nums))) +
                          Optional(e + Word(""+-"" + nums, nums)))
        ident = Word(alphas, alphas + nums + ""_$"")
        plus = Literal(""+"")
        minus = Literal(""-"")
        mult = Literal(""*"")
        div = Literal(""/"")
        lpar = Literal(""("").suppress()
        rpar = Literal("")"").suppress()
        addop = plus | minus
        multop = mult | div
        expop = Literal(""^"")
        pi = CaselessLiteral(""PI"")
        expr = Forward()
        atom = ((Optional(oneOf(""- +"")) +
                 (ident + lpar + expr + rpar | pi | e | fnumber).setParseAction(self.pushFirst))
                | Optional(oneOf(""- +"")) + Group(lpar + expr + rpar)
                ).setParseAction(self.pushUMinus)
        # by defining exponentiation as ""atom [ ^ factor ]..."" instead of
        # ""atom [ ^ atom ]..."", we get right-to-left exponents, instead of left-to-right
        # that is, 2^3^2 = 2^(3^2), not (2^3)^2.
        factor = Forward()
        factor &lt;&lt; atom + \
            ZeroOrMore((expop + factor).setParseAction(self.pushFirst))
        term = factor + \
            ZeroOrMore((multop + factor).setParseAction(self.pushFirst))
        expr &lt;&lt; term + \
            ZeroOrMore((addop + term).setParseAction(self.pushFirst))
        # addop_term = ( addop + term ).setParseAction( self.pushFirst )
        # general_term = term + ZeroOrMore( addop_term ) | OneOrMore( addop_term)
        # expr &lt;&lt;  general_term
        self.bnf = expr
        # map operator symbols to corresponding arithmetic operations
        epsilon = 1e-12
        self.opn = {""+"": operator.add,
                    ""-"": operator.sub,
                    ""*"": operator.mul,
                    ""/"": operator.truediv,
                    ""^"": operator.pow}
        self.fn = {""sin"": math.sin,
                   ""cos"": math.cos,
                   ""tan"": math.tan,
                   ""exp"": math.exp,
                   ""abs"": abs,
                   ""trunc"": lambda a: int(a),
                   ""round"": round,
                   ""sgn"": lambda a: abs(a) &gt; epsilon and cmp(a, 0) or 0}

    def evaluateStack(self, s):
        op = s.pop()
        if op == 'unary -':
            return -self.evaluateStack(s)
        if op in ""+-*/^"":
            op2 = self.evaluateStack(s)
            op1 = self.evaluateStack(s)
            return self.opn[op](op1, op2)
        elif op == ""PI"":
            return math.pi  # 3.1415926535
        elif op == ""E"":
            return math.e  # 2.718281828
        elif op in self.fn:
            return self.fn[op](self.evaluateStack(s))
        elif op[0].isalpha():
            return 0
        else:
            return float(op)

    def eval(self, num_string, parseAll=True):
        self.exprStack = []
        results = self.bnf.parseString(num_string, parseAll)
        val = self.evaluateStack(self.exprStack[:])
        return val
</code></pre>

<p>You can use it like this</p>

<pre><code>nsp = NumericStringParser()
result = nsp.eval('2^4')
print(result)
# 16.0

result = nsp.eval('exp(2^4)')
print(result)
# 8886110.520507872
</code></pre>
"
434411,"<p>Modified from the <a href=""https://docs.python.org/library/itertools.html#itertools-recipes"" rel=""noreferrer"">Recipes</a> section of Python's <a href=""http://docs.python.org/library/itertools.html"" rel=""noreferrer""><code>itertools</code></a> docs:</p>
<pre><code>from itertools import zip_longest

def grouper(iterable, n, fillvalue=None):
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)
</code></pre>
<p><strong>Example</strong></p>
<pre><code>grouper('ABCDEFG', 3, 'x')  # --&gt; 'ABC' 'DEF' 'Gxx'
</code></pre>
<p><strong>Note:</strong> on Python 2 use <code>izip_longest</code> instead of <code>zip_longest</code>.</p>
"
15479974,"<blockquote>
  <p><strong>Note:</strong> This answer was written before the implementation of the <code>dict</code> type changed, in Python 3.6. Most of the implementation details in this answer still apply, but the listing order of keys in <em>dictionaries</em> is no longer determined by hash values. The set implementation remains unchanged.</p>
</blockquote>

<p>The order is not arbitrary, but depends on the insertion and deletion history of the dictionary or set, as well as on the specific Python implementation. For the remainder of this answer, for 'dictionary', you can also read 'set'; sets are implemented as dictionaries with just keys and no values.</p>

<p>Keys are hashed, and hash values are assigned to slots in a dynamic table (it can grow or shrink based on needs). And that mapping process can lead to collisions, meaning that a key will have to be slotted in a <em>next</em> slot based on what is already there.</p>

<p>Listing the contents loops over the slots, and so keys are listed in the order they <em>currently</em> reside in the table.</p>

<p>Take the keys <code>'foo'</code> and <code>'bar'</code>, for example, and lets assume the table size is 8 slots. In Python 2.7, <code>hash('foo')</code> is <code>-4177197833195190597</code>, <code>hash('bar')</code> is <code>327024216814240868</code>. Modulo 8, that means these two keys are slotted in slots 3 and 4 then:</p>

<pre><code>&gt;&gt;&gt; hash('foo')
-4177197833195190597
&gt;&gt;&gt; hash('foo') % 8
3
&gt;&gt;&gt; hash('bar')
327024216814240868
&gt;&gt;&gt; hash('bar') % 8
4
</code></pre>

<p>This informs their listing order:</p>

<pre><code>&gt;&gt;&gt; {'bar': None, 'foo': None}
{'foo': None, 'bar': None}
</code></pre>

<p>All slots except 3 and 4 are empty, looping over the table first lists slot 3, then slot 4, so <code>'foo'</code> is listed before <code>'bar'</code>.</p>

<p><code>bar</code> and <code>baz</code>, however, have hash values that are exactly 8 apart and thus map to the exact same slot, <code>4</code>:</p>

<pre><code>&gt;&gt;&gt; hash('bar')
327024216814240868
&gt;&gt;&gt; hash('baz')
327024216814240876
&gt;&gt;&gt; hash('bar') % 8
4
&gt;&gt;&gt; hash('baz') % 8
4
</code></pre>

<p>Their order now depends on which key was slotted first; the second key will have to be moved to a next slot:</p>

<pre><code>&gt;&gt;&gt; {'baz': None, 'bar': None}
{'bar': None, 'baz': None}
&gt;&gt;&gt; {'bar': None, 'baz': None}
{'baz': None, 'bar': None}
</code></pre>

<p>The table order differs here, because one or the other key was slotted first.</p>

<p>The technical name for the underlying structure used by CPython (the most commonly used Python implemenation) is a <a href=""http://en.wikipedia.org/wiki/hash_table"" rel=""noreferrer"">hash table</a>, one that uses open addressing. If you are curious, and understand C well enough, take a look at the <a href=""http://hg.python.org/cpython/file/tip/Objects/dictobject.c"" rel=""noreferrer"">C implementation</a> for all the (well documented) details. You could also watch this <a href=""http://pyvideo.org/video/276/the-mighty-dictionary-55"" rel=""noreferrer"">Pycon 2010 presentation by Brandon Rhodes</a> about how CPython <code>dict</code> works, or pick up a copy of <a href=""http://shop.oreilly.com/product/9780596510046.do"" rel=""noreferrer"">Beautiful Code</a>, which includes a chapter on the implementation written by Andrew Kuchling.</p>

<p>Note that as of Python 3.3, a random hash seed is used as well, making hash collisions unpredictable to prevent certain types of denial of service (where an attacker renders a Python server unresponsive by causing mass hash collisions). This means that the order of a given dictionary or set is then <em>also</em> dependent on the random hash seed for the current Python invocation.</p>

<p>Other implementations are free to use a different structure for dictionaries, as long as they satisfy the documented Python interface for them, but I believe that all implementations so far use a variation of the hash table.</p>

<p>CPython 3.6 introduces a <em>new</em> <code>dict</code> implementation that maintains insertion order, and is faster and more memory efficient to boot. Rather than keep a large sparse table where each row references the stored hash value, and the key and value objects, the new implementation adds a smaller hash <em>array</em> that only references indices in a separate 'dense' table (one that only contains as many rows as there are actual key-value pairs), and it is the dense table that happens to list the contained items in order. See the <a href=""https://mail.python.org/pipermail/python-dev/2012-December/123028.html"" rel=""noreferrer"">proposal to Python-Dev for more details</a>. Note that in Python 3.6 this is considered an <em>implementation detail</em>, Python-the-language does not specify that other implementations have to retain order. This changed in Python 3.7, where this detail was <a href=""https://mail.python.org/pipermail/python-dev/2017-December/151283.html"" rel=""noreferrer"">elevated to be a <em>language specification</em></a>; for any implementation to be properly compatible with Python 3.7 or newer it <strong>must</strong> copy this order-preserving behaviour. And to be explicit: this change doesn't apply to sets, as sets already have a 'small' hash structure.</p>

<p>Python 2.7 and newer also provides an <a href=""https://docs.python.org/2/library/collections.html#collections.OrderedDict"" rel=""noreferrer""><code>OrderedDict</code> class</a>, a subclass of <code>dict</code> that adds an additional data structure to record key order. At the price of some speed and extra memory, this class remembers in what order you inserted keys; listing keys, values or items will then do so in that order. It uses a doubly-linked list stored in an additional dictionary to keep the order up-to-date efficiently. See the <a href=""https://mail.python.org/pipermail/python-dev/2012-December/123028.html"" rel=""noreferrer"">post by Raymond Hettinger outlining the idea</a>. <code>OrderedDict</code> objects have other advantages, such as being <em>re-orderable</em>.</p>

<p>If you wanted an ordered set, you can install the <a href=""https://pypi.python.org/pypi/oset"" rel=""noreferrer""><code>oset</code> package</a>; it works on Python 2.5 and up.</p>
"
180993,"<p><code>re.match</code> is anchored at the beginning of the string. That has nothing to do with newlines, so it is not the same as using <code>^</code> in the pattern.</p>

<p>As the <a href=""http://docs.python.org/2/library/re.html#re.match"" rel=""noreferrer"">re.match documentation</a> says:</p>

<blockquote>
  <p>If zero or more characters at the
  <strong>beginning of string</strong> match the regular expression pattern, return a
  corresponding <code>MatchObject</code> instance.
  Return <code>None</code> if the string does not
  match the pattern; note that this is
  different from a zero-length match.</p>
  
  <p>Note: If you want to locate a match
  anywhere in string, use <code>search()</code>
  instead.</p>
</blockquote>

<p><code>re.search</code> searches the entire string, as <a href=""http://docs.python.org/2/library/re.html#re.search"" rel=""noreferrer"">the documentation says</a>:</p>

<blockquote>
  <p><strong>Scan through string</strong> looking for a
  location where the regular expression
  pattern produces a match, and return a
  corresponding <code>MatchObject</code> instance.
  Return <code>None</code> if no position in the
  string matches the pattern; note that
  this is different from finding a
  zero-length match at some point in the
  string.</p>
</blockquote>

<p>So if you need to match at the beginning of the string, or to match the entire string use <code>match</code>. It is faster. Otherwise use <code>search</code>.</p>

<p>The documentation has a <a href=""http://docs.python.org/2/library/re.html#search-vs-match"" rel=""noreferrer"">specific section for <code>match</code> vs. <code>search</code></a> that also covers multiline strings:</p>

<blockquote>
  <p>Python offers two different primitive
  operations based on regular
  expressions: <code>match</code> checks for a match
  <strong>only at the beginning</strong> of the string,
  while <code>search</code> checks for a match
  <strong>anywhere</strong> in the string (this is what
  Perl does by default).</p>
  
  <p>Note that <code>match</code> may differ from <code>search</code>
  even when using a regular expression
  beginning with <code>'^'</code>: <code>'^'</code> matches only
  at the start of the string, or in
  <code>MULTILINE</code> mode also immediately
  following a newline. The â<code>match</code>â
  operation succeeds <em>only if the pattern
  matches at the <strong>start</strong> of the string</em>
  regardless of mode, or at the starting
  position given by the optional <code>pos</code>
  argument regardless of whether a
  newline precedes it.</p>
</blockquote>

<p>Now, enough talk. Time to see some example code:</p>

<pre><code># example code:
string_with_newlines = """"""something
someotherthing""""""

import re

print re.match('some', string_with_newlines) # matches
print re.match('someother', 
               string_with_newlines) # won't match
print re.match('^someother', string_with_newlines, 
               re.MULTILINE) # also won't match
print re.search('someother', 
                string_with_newlines) # finds something
print re.search('^someother', string_with_newlines, 
                re.MULTILINE) # also finds something

m = re.compile('thing$', re.MULTILINE)

print m.match(string_with_newlines) # no match
print m.match(string_with_newlines, pos=4) # matches
print m.search(string_with_newlines, 
               re.MULTILINE) # also matches
</code></pre>
"
12681217,"<p>How about something like this:</p>

<pre><code>In [55]: pd.concat([Series(row['var2'], row['var1'].split(','))              
                    for _, row in a.iterrows()]).reset_index()
Out[55]: 
  index  0
0     a  1
1     b  1
2     c  1
3     d  2
4     e  2
5     f  2
</code></pre>

<p>Then you just have to rename the columns</p>
"
9961598,"<p>You can use <a href=""http://www.pygame.org/docs/ref/key.html#pygame.key.get_pressed"" rel=""noreferrer"">pygame.key.get_pressed</a> to do that.</p>

<p>example:</p>

<pre><code>while running:
    keys = pygame.key.get_pressed()  #checking pressed keys
    if keys[pygame.K_UP]:
        y1 -= 1
    if keys[pygame.K_DOWN]:
        y1 += 1
</code></pre>
"
4760517,"<p>In all officially maintained versions of Python, the simplest approach is to use the <a href=""https://docs.python.org/3/library/subprocess.html#subprocess.check_output"" rel=""noreferrer""><code>subprocess.check_output</code></a> function:</p>
<pre><code>&gt;&gt;&gt; subprocess.check_output(['ls', '-l'])
b'total 0\n-rw-r--r--  1 memyself  staff  0 Mar 14 11:04 files\n'
</code></pre>
<p><code>check_output</code> runs a single program that takes only arguments as input.<sup>1</sup> It returns the result exactly as printed to <code>stdout</code>. If you need to write input to <code>stdin</code>, skip ahead to the <code>run</code> or <code>Popen</code> sections. If you want to execute complex shell commands, see the note on <code>shell=True</code> at the end of this answer.</p>
<p>The <code>check_output</code> function works in all officially maintained versions of Python. But for more recent versions, a more flexible approach is available.</p>
<h3>Modern versions of Python (3.5 or higher): <code>run</code></h3>
<p>If you're using <strong>Python 3.5+</strong>, and <strong>do not need backwards compatibility</strong>, the new <a href=""https://docs.python.org/3/library/subprocess.html#using-the-subprocess-module"" rel=""noreferrer""><code>run</code></a> function is recommended by the official documentation for most tasks. It provides a very general, high-level API for the <a href=""https://docs.python.org/3/library/subprocess.html"" rel=""noreferrer""><code>subprocess</code></a> module. To capture the output of a program, pass the <code>subprocess.PIPE</code> flag to the <code>stdout</code> keyword argument. Then access the <code>stdout</code> attribute of the returned <a href=""https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess"" rel=""noreferrer""><code>CompletedProcess</code></a> object:</p>
<pre><code>&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; result = subprocess.run(['ls', '-l'], stdout=subprocess.PIPE)
&gt;&gt;&gt; result.stdout
b'total 0\n-rw-r--r--  1 memyself  staff  0 Mar 14 11:04 files\n'
</code></pre>
<p>The return value is a <code>bytes</code> object, so if you want a proper string, you'll need to <code>decode</code> it. Assuming the called process returns a UTF-8-encoded string:</p>
<pre><code>&gt;&gt;&gt; result.stdout.decode('utf-8')
'total 0\n-rw-r--r--  1 memyself  staff  0 Mar 14 11:04 files\n'
</code></pre>
<p>This can all be compressed to a one-liner if desired:</p>
<pre><code>&gt;&gt;&gt; subprocess.run(['ls', '-l'], stdout=subprocess.PIPE).stdout.decode('utf-8')
'total 0\n-rw-r--r--  1 memyself  staff  0 Mar 14 11:04 files\n'
</code></pre>
<p>If you want to pass input to the process's <code>stdin</code>, you can pass a <code>bytes</code> object to the <code>input</code> keyword argument:</p>
<pre><code>&gt;&gt;&gt; cmd = ['awk', 'length($0) &gt; 5']
&gt;&gt;&gt; ip = 'foo\nfoofoo\n'.encode('utf-8')
&gt;&gt;&gt; result = subprocess.run(cmd, stdout=subprocess.PIPE, input=ip)
&gt;&gt;&gt; result.stdout.decode('utf-8')
'foofoo\n'
</code></pre>
<p>You can capture errors by passing <code>stderr=subprocess.PIPE</code> (capture to <code>result.stderr</code>) or <code>stderr=subprocess.STDOUT</code> (capture to <code>result.stdout</code> along with regular output). If you want <code>run</code> to throw an exception when the process returns a nonzero exit code, you can pass <code>check=True</code>. (Or you can check the <code>returncode</code> attribute of <code>result</code> above.) When security is not a concern, you can also run more complex shell commands by passing <code>shell=True</code> as described at the end of this answer.</p>
<p>Later versions of Python streamline the above further. In Python 3.7+, the above one-liner can be spelled like this:</p>
<pre><code>&gt;&gt;&gt; subprocess.run(['ls', '-l'], capture_output=True, text=True).stdout
'total 0\n-rw-r--r--  1 memyself  staff  0 Mar 14 11:04 files\n'
</code></pre>
<p>Using <code>run</code> this way adds just a bit of complexity, compared to the old way of doing things. But now you can do almost anything you need to do with the <code>run</code> function alone.</p>
<h3>Older versions of Python (3-3.4): more about <code>check_output</code></h3>
<p>If you are using an older version of Python, or need modest backwards compatibility, you can use the <code>check_output</code> function as briefly described above. It has been available since Python 2.7.</p>
<pre><code>subprocess.check_output(*popenargs, **kwargs)  
</code></pre>
<p>It takes takes the same arguments as <code>Popen</code> (see below), and returns a string containing the program's output. The beginning of this answer has a more detailed usage example. In Python 3.5+, <code>check_output</code> is equivalent to executing <code>run</code> with <code>check=True</code> and <code>stdout=PIPE</code>, and returning just the <code>stdout</code> attribute.</p>
<p>You can pass <code>stderr=subprocess.STDOUT</code> to ensure that error messages are included in the returned output. When security is not a concern, you can also run more complex shell commands by passing <code>shell=True</code> as described at the end of this answer.</p>
<p>If you need to pipe from <code>stderr</code> or pass input to the process, <code>check_output</code> won't be up to the task. See the <code>Popen</code> examples below in that case.</p>
<h3>Complex applications and legacy versions of Python (2.6 and below): <code>Popen</code></h3>
<p>If you need deep backwards compatibility, or if you need more sophisticated functionality than <code>check_output</code> or <code>run</code> provide, you'll have to work directly with <code>Popen</code> objects, which encapsulate the low-level API for subprocesses.</p>
<p>The <code>Popen</code> constructor accepts either <strong>a single command</strong> without arguments, or <strong>a list</strong> containing a command as its first item, followed by any number of arguments, each as a separate item in the list. <a href=""https://docs.python.org/3/library/shlex.html"" rel=""noreferrer""><code>shlex.split</code></a> can help parse strings into appropriately formatted lists. <code>Popen</code> objects also accept a <a href=""https://docs.python.org/3/library/subprocess.html#subprocess.Popen"" rel=""noreferrer"">host of different arguments</a> for process IO management and low-level configuration.</p>
<p>To send input and capture output, <code>communicate</code> is almost always the preferred method. As in:</p>
<pre><code>output = subprocess.Popen([&quot;mycmd&quot;, &quot;myarg&quot;], 
                          stdout=subprocess.PIPE).communicate()[0]
</code></pre>
<p>Or</p>
<pre><code>&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; p = subprocess.Popen(['ls', '-a'], stdout=subprocess.PIPE, 
...                                    stderr=subprocess.PIPE)
&gt;&gt;&gt; out, err = p.communicate()
&gt;&gt;&gt; print out
.
..
foo
</code></pre>
<p>If you set <code>stdin=PIPE</code>, <code>communicate</code> also allows you to pass data to the process via <code>stdin</code>:</p>
<pre><code>&gt;&gt;&gt; cmd = ['awk', 'length($0) &gt; 5']
&gt;&gt;&gt; p = subprocess.Popen(cmd, stdout=subprocess.PIPE,
...                           stderr=subprocess.PIPE,
...                           stdin=subprocess.PIPE)
&gt;&gt;&gt; out, err = p.communicate('foo\nfoofoo\n')
&gt;&gt;&gt; print out
foofoo
</code></pre>
<p>Note <a href=""https://stackoverflow.com/a/21867841/577088"">Aaron Hall's answer</a>, which indicates that on some systems, you may need to set <code>stdout</code>, <code>stderr</code>, and <code>stdin</code> all to <code>PIPE</code> (or <code>DEVNULL</code>) to get <code>communicate</code> to work at all.</p>
<p>In some rare cases, you may need complex, real-time output capturing. <a href=""https://stackoverflow.com/a/4760274/577088"">Vartec</a>'s answer suggests a way forward, but methods other than <code>communicate</code> are prone to deadlocks if not used carefully.</p>
<p>As with all the above functions, when security is not a concern, you can run more complex shell commands by passing <code>shell=True</code>.</p>
<h3>Notes</h3>
<p><strong>1. Running shell commands: the <code>shell=True</code> argument</strong></p>
<p>Normally, each call to <code>run</code>, <code>check_output</code>, or the <code>Popen</code> constructor executes a <em>single program</em>. That means no fancy bash-style pipes. If you want to run complex shell commands, you can pass <code>shell=True</code>, which all three functions support. For example:</p>
<pre><code>&gt;&gt;&gt; subprocess.check_output('cat books/* | wc', shell=True, text=True)
' 1299377 17005208 101299376\n'
</code></pre>
<p>However, doing this raises <a href=""https://docs.python.org/3/library/subprocess.html#security-considerations"" rel=""noreferrer"">security concerns</a>. If you're doing anything more than light scripting, you might be better off calling each process separately, and passing the output from each as an input to the next, via</p>
<pre><code>run(cmd, [stdout=etc...], input=other_output)
</code></pre>
<p>Or</p>
<pre><code>Popen(cmd, [stdout=etc...]).communicate(other_output)
</code></pre>
<p>The temptation to directly connect pipes is strong; resist it. Otherwise, you'll likely see deadlocks or have to do hacky things like <a href=""https://stackoverflow.com/questions/6341451/piping-together-several-subprocesses"">this</a>.</p>
"
2960791,"<pre><code>plot.savefig('hanning(%d).pdf' % num)
</code></pre>
<p>The <code>%</code> operator, when following a string, allows you to insert values into that string via format codes (the <code>%d</code> in this case). For more details, see the Python documentation:</p>
<p><a href=""https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting"" rel=""nofollow noreferrer""><code>printf</code>-style String Formatting</a></p>
"
3906148,"<p>Calling <code>read()</code> reads through the entire file and leaves the read cursor at the end of the file (with nothing more to read). If you are looking to read a certain number of lines at a time you could use  <code>readline()</code>, <code>readlines()</code> or iterate through lines with <code>for line in handle:</code>.</p>
<p>To answer your question directly, once a file has been read, with <code>read()</code> you can use <code>seek(0)</code> to return the read cursor to the start of the file (docs are <a href=""http://docs.python.org/2.4/lib/bltin-file-objects.html"" rel=""noreferrer"">here</a>). If you know the file isn't going to be too large, you can also save the <code>read()</code> output to a variable, using it in your <code>findall</code> expressions.</p>
<p>Ps. Don't forget to close the file after you are done with it.</p>
"
2081708,"<p>There's not really any ""raw <em>string</em>""; there are raw <em>string literals</em>, which are exactly the string literals marked by an <code>'r'</code> before the opening quote.</p>

<p>A ""raw string literal"" is a slightly different syntax for a string literal, in which a backslash, <code>\</code>, is taken as meaning ""just a backslash"" (except when it comes right before a quote that would otherwise terminate the literal) -- no ""escape sequences"" to represent newlines, tabs, backspaces, form-feeds, and so on.  In normal string literals, each backslash must be doubled up to avoid being taken as the start of an escape sequence.</p>

<p>This syntax variant exists mostly because the syntax of regular expression patterns is heavy with backslashes (but never at the end, so the ""except"" clause above doesn't matter) and it looks a bit better when you avoid doubling up each of them -- that's all.  It also gained some popularity to express native Windows file paths (with backslashes instead of regular slashes like on other platforms), but that's very rarely needed (since normal slashes mostly work fine on Windows too) and imperfect (due to the ""except"" clause above).</p>

<p><code>r'...'</code> is a byte string (in Python 2.*), <code>ur'...'</code> is a Unicode string (again, in Python 2.*), and any of the other three kinds of quoting also produces exactly the same types of strings (so for example <code>r'...'</code>, <code>r'''...'''</code>, <code>r""...""</code>, <code>r""""""...""""""</code> are all byte strings, and so on).</p>

<p>Not sure what you mean by ""going <em>back</em>"" - there is no intrinsically back and forward directions, because there's no raw string <strong>type</strong>, it's just an alternative syntax to express perfectly normal string objects, byte or unicode as they may be.</p>

<p>And yes, in Python 2.*, <code>u'...'</code> <strong>is</strong> of course always distinct from just <code>'...'</code> -- the former is a unicode string, the latter is a byte string. What encoding the literal might be expressed in is a completely orthogonal issue.</p>

<p>E.g., consider (Python 2.6):</p>

<pre><code>&gt;&gt;&gt; sys.getsizeof('ciao')
28
&gt;&gt;&gt; sys.getsizeof(u'ciao')
34
</code></pre>

<p>The Unicode object of course takes more memory space (very small difference for a very short string, obviously ;-).</p>
"
826957,"<p>In Python 3, <code>print</code> <a href=""http://docs.python.org/3.0/whatsnew/3.0.html#print-is-a-function"" rel=""noreferrer"">became a function</a>. This means that you need to include parenthesis now like mentioned below:</p>

<pre><code>print(""Hello World"")
</code></pre>
"
,
60211,"<p>Python 3.10 (2021) introduced the <a href=""https://www.python.org/dev/peps/pep-0634/"" rel=""noreferrer""><code>match</code>-<code>case</code></a> statement which provides a first-class implementation of a &quot;switch&quot; for Python. For example:</p>
<pre><code>def f(x):
    match x:
        case 'a':
            return 1
        case 'b':
            return 2
        case _:
            return 0   # 0 is the default case if x is not found
</code></pre>
<p>The <code>match</code>-<code>case</code> statement is considerably more powerful than this simple example.</p>
<hr />
<p>The original answer below was written in 2008, before <code>match</code>-<code>case</code> was available:</p>
<p>You could use a dictionary:</p>
<pre><code>def f(x):
    return {
        'a': 1,
        'b': 2,
    }[x]
</code></pre>
"
25336738,"<p>An iterator can only be consumed once. For example:</p>
<pre><code>lst = [1, 2, 3]
it = iter(lst)

next(it)
# =&gt; 1
next(it)
# =&gt; 2
next(it)
# =&gt; 3
next(it)
# =&gt; StopIteration
</code></pre>
<p>When the iterator is supplied to a <code>for</code> loop instead, that last <code>StopIteration</code> will cause it to exit the first time. Trying to use the same iterator in another for loop will cause <code>StopIteration</code> again immediately, because the iterator has already been consumed.</p>
<p>A simple way to work around this is to save all the elements to a list, which can be traversed as many times as needed. For example:</p>
<pre><code>data = list(data)
</code></pre>
<p>If the iterator would iterate over many elements, however, it's a better idea to create independent iterators using <a href=""https://docs.python.org/library/itertools.html#itertools.tee"" rel=""noreferrer""><code>tee()</code></a>:</p>
<pre><code>import itertools
it1, it2 = itertools.tee(data, 2) # create as many as needed
</code></pre>
<p>Now each one can be iterated over in turn:</p>
<pre><code>for e in it1:
    print(&quot;first loop&quot;)

for e in it2:
    print(&quot;second loop&quot;)
</code></pre>
"
7053664,"<p>It's the return value of the function, which you print out. If there is no return statement (or <a href=""http://docs.python.org/reference/simple_stmts.html#return"" rel=""noreferrer"">just a <code>return</code> without an argument</a>), an implicit <code>return None</code> is added to the end of a function.</p>

<p>You probably want to return the values in the function instead of printing them:</p>

<pre><code>def jiskya(x, y):
    if x &gt; y:
        return y
    else:
        return x

print(jiskya(2, 3))
</code></pre>
"
1504742,"<p><code>is</code> is identity testing, and <code>==</code> is equality testing. What happens in your code would be emulated in the interpreter like this:</p>
<pre><code>&gt;&gt;&gt; a = 'pub'
&gt;&gt;&gt; b = ''.join(['p', 'u', 'b'])
&gt;&gt;&gt; a == b
True
&gt;&gt;&gt; a is b
False
</code></pre>
<p>So, no wonder they're not the same, right?</p>
<p>In other words: <code>a is b</code> is the equivalent of <code>id(a) == id(b)</code></p>
"
5036775,"<p>Unless there is an overwhelming need to create a mess of variable names, I would just use a dictionary, where you can dynamically create the key names and associate a value to each.</p>
<pre><code>a = {}
k = 0
while k &lt; 10:
    # dynamically create key
    key = ...
    # calculate value
    value = ...
    a[key] = value 
    k += 1
</code></pre>
<p>There are also some interesting data structures in the <a href=""https://docs.python.org/library/collections.html"" rel=""noreferrer""><code>collections</code> module</a> that might be applicable.</p>
"
73050,"<p>The <a href=""https://docs.python.org/library/functions.html#sorted"" rel=""noreferrer""><code>sorted()</code></a> function takes a <code>key=</code> parameter</p>
<pre><code>newlist = sorted(list_to_be_sorted, key=lambda d: d['name']) 
</code></pre>
<p>Alternatively, you can use <a href=""https://docs.python.org/library/operator.html#operator.itemgetter"" rel=""noreferrer""><code>operator.itemgetter</code></a> instead of defining the function yourself</p>
<pre><code>from operator import itemgetter
newlist = sorted(list_to_be_sorted, key=itemgetter('name')) 
</code></pre>
<p>For completeness, add <code>reverse=True</code> to sort in descending order</p>
<pre><code>newlist = sorted(list_to_be_sorted, key=itemgetter('name'), reverse=True)
</code></pre>
"
12453584,"<p>Use <a href=""https://docs.python.org/library/stdtypes.html#str.join"" rel=""noreferrer""><code>str.join</code></a>:</p>
<pre><code>&gt;&gt;&gt; words = ['this', 'is', 'a', 'sentence']
&gt;&gt;&gt; '-'.join(words)
'this-is-a-sentence'
&gt;&gt;&gt; ' '.join(words)
'this is a sentence'
</code></pre>
"
5893946,"<p><code>_</code> has 3 main conventional uses in Python:</p>
<ol>
<li><p>To hold the result of the last executed expression in an interactive
interpreter session (see <a href=""https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers"" rel=""noreferrer"">docs</a>). This precedent was set by the standard CPython
interpreter, and other interpreters have followed suit</p>
</li>
<li><p>For translation lookup in i18n (see the
<a href=""https://docs.python.org/3/library/gettext.html#localizing-your-module"" rel=""noreferrer"">gettext</a>
documentation for example), as in code like</p>
<pre><code>raise forms.ValidationError(_(&quot;Please enter a correct username&quot;))
</code></pre>
</li>
<li><p>As a general purpose &quot;throwaway&quot; variable name:</p>
<ol>
<li><p>To indicate that part
of a function result is being deliberately ignored (Conceptually, it is being discarded.), as in code like:</p>
<pre><code>label, has_label, _ = text.partition(':')
</code></pre>
</li>
<li><p>As part of a function definition (using either <code>def</code> or <code>lambda</code>), where
the signature is fixed (e.g. by a callback or parent class API), but
this particular function implementation doesn't need all of the
parameters, as in code like:</p>
<pre><code>def callback(_):
    return True
</code></pre>
<p>[For a long time this answer didn't list this use case, but it came up often enough, as noted <a href=""https://stackoverflow.com/questions/5893163/what-is-the-purpose-of-the-single-underscore-variable-in-python/5893946?noredirect=1#comment100906549_5893946"">here</a>, to be worth listing explicitly.]</p>
</li>
</ol>
<p>This use case can conflict with the translation lookup use case, so it is necessary to avoid using <code>_</code> as a throwaway variable in any code block that also uses it for i18n translation (many folks prefer a double-underscore, <code>__</code>, as their throwaway variable for exactly this reason).</p>
<p>Linters often recognize this use case. For example <code>year, month, day = date()</code> will raise a lint warning if <code>day</code> is not used later in the code. The fix, if <code>day</code> is truly not needed, is to write <code>year, month, _ = date()</code>. Same with lambda functions, <code>lambda arg: 1.0</code> creates a function requiring one argument but not using it, which will be caught by lint. The fix is to write <code>lambda _: 1.0</code>. An unused variable is often hiding a bug/typo (e.g. set <code>day</code> but use <code>dya</code> in the next line).</p>
<p>The pattern matching feature added in Python 3.10 elevated this usage from &quot;convention&quot; to &quot;language syntax&quot; where <code>match</code> statements are concerned: in match cases, <code>_</code> is a <a href=""https://docs.python.org/3/reference/compound_stmts.html#wildcard-patterns"" rel=""noreferrer"">wildcard pattern</a>, and the runtime doesn't even bind a value to the symbol in that case.</p>
<p>For other use cases, remember that <code>_</code> is still a valid variable name, and hence will still keep objects alive. In cases where this is undesirable (e.g. to release memory or external resources) an explicit <code>del name</code> call will both satisfy linters that the name is being used, <em>and</em> promptly clear the reference to the object.</p>
</li>
</ol>
"
28648923,"<p>You have four main options for converting types in pandas:</p>
<ol>
<li><p><a href=""https://pandas.pydata.org/docs/reference/api/pandas.to_numeric.html"" rel=""noreferrer""><code>to_numeric()</code></a> - provides functionality to safely convert non-numeric types (e.g. strings) to a suitable numeric type. (See also <a href=""https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html"" rel=""noreferrer""><code>to_datetime()</code></a> and <a href=""https://pandas.pydata.org/docs/reference/api/pandas.to_timedelta.html"" rel=""noreferrer""><code>to_timedelta()</code></a>.)</p>
</li>
<li><p><a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.astype.html"" rel=""noreferrer""><code>astype()</code></a> - convert (almost) any type to (almost) any other type (even if it's not necessarily sensible to do so). Also allows you to convert to <a href=""https://pandas.pydata.org/docs/user_guide/categorical.html"" rel=""noreferrer"">categorial</a> types (very useful).</p>
</li>
<li><p><a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.infer_objects.html"" rel=""noreferrer""><code>infer_objects()</code></a> - a utility method to convert object columns holding Python objects to a pandas type if possible.</p>
</li>
<li><p><a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.convert_dtypes.html"" rel=""noreferrer""><code>convert_dtypes()</code></a> - convert DataFrame columns to the &quot;best possible&quot;  dtype that supports <code>pd.NA</code> (pandas' object to indicate a missing value).</p>
</li>
</ol>
<p>Read on for more detailed explanations and usage of each of these methods.</p>
<hr />
<h1>1. <code>to_numeric()</code></h1>
<p>The best way to convert one or more columns of a DataFrame to numeric values is to use <a href=""https://pandas.pydata.org/docs/reference/api/pandas.to_numeric.html"" rel=""noreferrer""><code>pandas.to_numeric()</code></a>.</p>
<p>This function will try to change non-numeric objects (such as strings) into integers or floating-point numbers as appropriate.</p>
<h2>Basic usage</h2>
<p>The input to <a href=""https://pandas.pydata.org/docs/reference/api/pandas.to_numeric.html"" rel=""noreferrer""><code>to_numeric()</code></a> is a Series or a single column of a DataFrame.</p>
<pre><code>&gt;&gt;&gt; s = pd.Series([&quot;8&quot;, 6, &quot;7.5&quot;, 3, &quot;0.9&quot;]) # mixed string and numeric values
&gt;&gt;&gt; s
0      8
1      6
2    7.5
3      3
4    0.9
dtype: object

&gt;&gt;&gt; pd.to_numeric(s) # convert everything to float values
0    8.0
1    6.0
2    7.5
3    3.0
4    0.9
dtype: float64
</code></pre>
<p>As you can see, a new Series is returned. Remember to assign this output to a variable or column name to continue using it:</p>
<pre><code># convert Series
my_series = pd.to_numeric(my_series)

# convert column &quot;a&quot; of a DataFrame
df[&quot;a&quot;] = pd.to_numeric(df[&quot;a&quot;])
</code></pre>
<p>You can also use it to convert multiple columns of a DataFrame via the <a href=""https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html"" rel=""noreferrer""><code>apply()</code></a> method:</p>
<pre><code># convert all columns of DataFrame
df = df.apply(pd.to_numeric) # convert all columns of DataFrame

# convert just columns &quot;a&quot; and &quot;b&quot;
df[[&quot;a&quot;, &quot;b&quot;]] = df[[&quot;a&quot;, &quot;b&quot;]].apply(pd.to_numeric)
</code></pre>
<p>As long as your values can all be converted, that's probably all you need.</p>
<h2>Error handling</h2>
<p>But what if some values can't be converted to a numeric type?</p>
<p><a href=""https://pandas.pydata.org/docs/reference/api/pandas.to_numeric.html"" rel=""noreferrer""><code>to_numeric()</code></a> also takes an <code>errors</code> keyword argument that allows you to force non-numeric values to be <code>NaN</code>, or simply ignore columns containing these values.</p>
<p>Here's an example using a Series of strings <code>s</code> which has the object dtype:</p>
<pre><code>&gt;&gt;&gt; s = pd.Series(['1', '2', '4.7', 'pandas', '10'])
&gt;&gt;&gt; s
0         1
1         2
2       4.7
3    pandas
4        10
dtype: object
</code></pre>
<p>The default behaviour is to raise if it can't convert a value. In this case, it can't cope with the string 'pandas':</p>
<pre><code>&gt;&gt;&gt; pd.to_numeric(s) # or pd.to_numeric(s, errors='raise')
ValueError: Unable to parse string
</code></pre>
<p>Rather than fail, we might want 'pandas' to be considered a missing/bad numeric value. We can coerce invalid values to <code>NaN</code> as follows using the <code>errors</code> keyword argument:</p>
<pre><code>&gt;&gt;&gt; pd.to_numeric(s, errors='coerce')
0     1.0
1     2.0
2     4.7
3     NaN
4    10.0
dtype: float64
</code></pre>
<p>The third option for <code>errors</code> is just to ignore the operation if an invalid value is encountered:</p>
<pre><code>&gt;&gt;&gt; pd.to_numeric(s, errors='ignore')
# the original Series is returned untouched
</code></pre>
<p>This last option is particularly useful for converting your entire DataFrame, but don't know which of our columns can be converted reliably to a numeric type. In that case, just write:</p>
<pre><code>df.apply(pd.to_numeric, errors='ignore')
</code></pre>
<p>The function will be applied to each column of the DataFrame. Columns that can be converted to a numeric type will be converted, while columns that cannot (e.g. they contain non-digit strings or dates) will be left alone.</p>
<h2>Downcasting</h2>
<p>By default, conversion with <a href=""https://pandas.pydata.org/docs/reference/api/pandas.to_numeric.html"" rel=""noreferrer""><code>to_numeric()</code></a> will give you either an <code>int64</code> or <code>float64</code> dtype (or whatever integer width is native to your platform).</p>
<p>That's usually what you want, but what if you wanted to save some memory and use a more compact dtype, like <code>float32</code>, or <code>int8</code>?</p>
<p><a href=""https://pandas.pydata.org/docs/reference/api/pandas.to_numeric.html"" rel=""noreferrer""><code>to_numeric()</code></a> gives you the option to downcast to either <code>'integer'</code>, <code>'signed'</code>, <code>'unsigned'</code>, <code>'float'</code>. Here's an example for a simple series <code>s</code> of integer type:</p>
<pre><code>&gt;&gt;&gt; s = pd.Series([1, 2, -7])
&gt;&gt;&gt; s
0    1
1    2
2   -7
dtype: int64
</code></pre>
<p>Downcasting to <code>'integer'</code> uses the smallest possible integer that can hold the values:</p>
<pre><code>&gt;&gt;&gt; pd.to_numeric(s, downcast='integer')
0    1
1    2
2   -7
dtype: int8
</code></pre>
<p>Downcasting to <code>'float'</code> similarly picks a smaller than normal floating type:</p>
<pre><code>&gt;&gt;&gt; pd.to_numeric(s, downcast='float')
0    1.0
1    2.0
2   -7.0
dtype: float32
</code></pre>
<hr />
<h1>2. <code>astype()</code></h1>
<p>The <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.astype.html"" rel=""noreferrer""><code>astype()</code></a> method enables you to be explicit about the dtype you want your DataFrame or Series to have. It's very versatile in that you can try and go from one type to any other.</p>
<h2>Basic usage</h2>
<p>Just pick a type: you can use a NumPy dtype (e.g. <code>np.int16</code>), some Python types (e.g. bool), or pandas-specific types (like the categorical dtype).</p>
<p>Call the method on the object you want to convert and <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.astype.html"" rel=""noreferrer""><code>astype()</code></a> will try and convert it for you:</p>
<pre><code># convert all DataFrame columns to the int64 dtype
df = df.astype(int)

# convert column &quot;a&quot; to int64 dtype and &quot;b&quot; to complex type
df = df.astype({&quot;a&quot;: int, &quot;b&quot;: complex})

# convert Series to float16 type
s = s.astype(np.float16)

# convert Series to Python strings
s = s.astype(str)

# convert Series to categorical type - see docs for more details
s = s.astype('category')
</code></pre>
<p>Notice I said &quot;try&quot; - if <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.astype.html"" rel=""noreferrer""><code>astype()</code></a> does not know how to convert a value in the Series or DataFrame, it will raise an error. For example, if you have a <code>NaN</code> or <code>inf</code> value you'll get an error trying to convert it to an integer.</p>
<p>As of pandas 0.20.0, this error can be suppressed by passing <code>errors='ignore'</code>. Your original object will be returned untouched.</p>
<h2>Be careful</h2>
<p><a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.astype.html"" rel=""noreferrer""><code>astype()</code></a> is powerful, but it will sometimes convert values &quot;incorrectly&quot;. For example:</p>
<pre><code>&gt;&gt;&gt; s = pd.Series([1, 2, -7])
&gt;&gt;&gt; s
0    1
1    2
2   -7
dtype: int64
</code></pre>
<p>These are small integers, so how about converting to an unsigned 8-bit type to save memory?</p>
<pre><code>&gt;&gt;&gt; s.astype(np.uint8)
0      1
1      2
2    249
dtype: uint8
</code></pre>
<p>The conversion worked, but the -7 was wrapped round to become 249 (i.e. 2<sup>8</sup> - 7)!</p>
<p>Trying to downcast using <code>pd.to_numeric(s, downcast='unsigned')</code> instead could help prevent this error.</p>
<hr />
<h1>3. <code>infer_objects()</code></h1>
<p>Version 0.21.0 of pandas introduced the method <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.infer_objects.html"" rel=""noreferrer""><code>infer_objects()</code></a> for converting columns of a DataFrame that have an object datatype to a more specific type (soft conversions).</p>
<p>For example, here's a DataFrame with two columns of object type. One holds actual integers and the other holds strings representing integers:</p>
<pre><code>&gt;&gt;&gt; df = pd.DataFrame({'a': [7, 1, 5], 'b': ['3','2','1']}, dtype='object')
&gt;&gt;&gt; df.dtypes
a    object
b    object
dtype: object
</code></pre>
<p>Using <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.infer_objects.html"" rel=""noreferrer""><code>infer_objects()</code></a>, you can change the type of column 'a' to int64:</p>
<pre><code>&gt;&gt;&gt; df = df.infer_objects()
&gt;&gt;&gt; df.dtypes
a     int64
b    object
dtype: object
</code></pre>
<p>Column 'b' has been left alone since its values were strings, not integers. If you wanted to force both columns to an integer type, you could use <code>df.astype(int)</code> instead.</p>
<hr />
<h1>4. <code>convert_dtypes()</code></h1>
<p>Version 1.0 and above includes a method <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.convert_dtypes.html"" rel=""noreferrer""><code>convert_dtypes()</code></a> to convert Series and DataFrame columns to the best possible dtype that supports the <code>pd.NA</code> missing value.</p>
<p>Here &quot;best possible&quot; means the type most suited to hold the values. For example, this a pandas integer type, if all of the values are integers (or missing values): an object column of Python integer objects are converted to <code>Int64</code>, a column of NumPy <code>int32</code> values, will become the pandas dtype <code>Int32</code>.</p>
<p>With our <code>object</code> DataFrame <code>df</code>, we get the following result:</p>
<pre><code>&gt;&gt;&gt; df.convert_dtypes().dtypes                                             
a     Int64
b    string
dtype: object
</code></pre>
<p>Since column 'a' held integer values, it was converted to the <code>Int64</code> type (which is capable of holding missing values, unlike <code>int64</code>).</p>
<p>Column 'b' contained string objects, so was changed to pandas' <code>string</code> dtype.</p>
<p>By default, this method will infer the type from object values in each column. We can change this by passing <code>infer_objects=False</code>:</p>
<pre><code>&gt;&gt;&gt; df.convert_dtypes(infer_objects=False).dtypes                          
a    object
b    string
dtype: object
</code></pre>
<p>Now column 'a' remained an object column: pandas knows it can be described as an 'integer' column (internally it ran <a href=""https://github.com/pandas-dev/pandas/blob/6b2d0260c818e62052eaf535767f3a8c4b446c69/pandas/_libs/lib.pyx#L1188-L1434"" rel=""noreferrer""><code>infer_dtype</code></a>) but didn't infer exactly what dtype of integer it should have so did not convert it. Column 'b' was again converted to 'string' dtype as it was recognised as holding 'string' values.</p>
"
209854,"<p>Like this:</p>
<pre><code>keys = ['a', 'b', 'c']
values = [1, 2, 3]
dictionary = dict(zip(keys, values))
print(dictionary) # {'a': 1, 'b': 2, 'c': 3}
</code></pre>
<p>Voila :-)  The pairwise <a href=""https://docs.python.org/3/library/functions.html#func-dict"" rel=""noreferrer""><code>dict</code></a> constructor and <a href=""https://docs.python.org/3/library/functions.html#zip"" rel=""noreferrer""><code>zip</code></a> function are awesomely useful.</p>
"
252711,"<p><a href=""https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types"" rel=""noreferrer""><code>append</code></a> appends a specified object at the end of the list:</p>
<pre><code>&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; x.append([4, 5])
&gt;&gt;&gt; print(x)
[1, 2, 3, [4, 5]]
</code></pre>
<p><a href=""https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types"" rel=""noreferrer""><code>extend</code></a> extends the list by appending elements from the specified iterable:</p>
<pre><code>&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; x.extend([4, 5])
&gt;&gt;&gt; print(x)
[1, 2, 3, 4, 5]
</code></pre>
"
,
52413247,"<h1>First: Do not post images of data, text only please</h1>
<h3>Second: Do not paste data in the comments section or as an answer, edit your question instead</h3>
<hr />
<h2>How to quickly provide sample data from a pandas DataFrame</h2>
<ul>
<li>There is more than one way to answer this question.  However, this answer isn't meant as an exhaustive solution.  It provides the simplest method possible.</li>
<li>For the curious, there are other more verbose solutions provided on Stack Overflow.</li>
</ul>
<ol>
<li>Provide a link to a shareable dataset (maybe on GitHub or a shared file on Google). This is particularly useful if it's a large dataset and the objective is to optimize some method.  The drawback is that the data may no longer be available in the future, which reduces the benefit of the post.
<ul>
<li>Data must be provided in the question, but can be accompanied by a link to a more extensive dataset.</li>
<li>Do not post only a link or an image of the data.</li>
</ul>
</li>
<li><strong>Provide the output of <code>df.head(10).to_clipboard(sep=',', index=True)</code></strong></li>
</ol>
<h2>Code:</h2>
<p><strong>Provide the output of <code>pandas.DataFrame.to_clipboard</code></strong></p>
<pre class=""lang-py prettyprint-override""><code>df.head(10).to_clipboard(sep=',', index=True)
</code></pre>
<ul>
<li>If you have a multi-index DataFrame add a note, telling which columns are the indices.</li>
<li><strong>Note</strong>: when the previous line of code is executed, no output will appear.
<ul>
<li>The result of the code is now on the clipboard.</li>
</ul>
</li>
<li>Paste the clipboard into a <code>code block</code> in your Stack Overflow question</li>
</ul>
<pre class=""lang-py prettyprint-override""><code>,a,b
2020-07-30,2,4
2020-07-31,1,5
2020-08-01,2,2
2020-08-02,9,8
2020-08-03,4,0
2020-08-04,3,3
2020-08-05,7,7
2020-08-06,7,0
2020-08-07,8,4
2020-08-08,3,2
</code></pre>
<ul>
<li>This can be copied to the clipboard by someone trying to answer your question, and followed by:</li>
</ul>
<pre class=""lang-py prettyprint-override""><code>df = pd.read_clipboard(sep=',')
</code></pre>
<h2>Locations of the dataframe other the <code>.head(10)</code></h2>
<ul>
<li>Specify a section of the dataframe with the <a href=""https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html"" rel=""nofollow noreferrer""><code>.iloc</code></a> property</li>
<li>The following example selects rows 3 - 11 and all the columns</li>
</ul>
<pre class=""lang-py prettyprint-override""><code>df.iloc[3:12, :].to_clipboard(sep=',')
</code></pre>
<h2>Additional References for <code>pd.read_clipboard</code></h2>
<ul>
<li><a href=""https://stackoverflow.com/questions/45800520"">Specify Multi-Level columns using pd.read_clipboard?</a></li>
<li><a href=""https://stackoverflow.com/questions/45528198"">How do you handle column names having spaces in them when using pd.read_clipboard?</a></li>
<li><a href=""https://stackoverflow.com/questions/45725500"">How to handle custom named index when copying a dataframe using pd.read_clipboard?</a></li>
</ul>
<h2>Google Colab Users</h2>
<ul>
<li><code>.to_clipboard()</code> won't work</li>
<li>Use <a href=""https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_dict.html"" rel=""nofollow noreferrer""><code>.to_dict()</code></a> to copy your dataframe</li>
</ul>
<pre class=""lang-py prettyprint-override""><code># if you have a datetime column, convert it to a str
df['date'] = df['date'].astype('str')

# if you have a datetime index, convert it to a str
df.index = df.index.astype('str')

# output to a dict
df.head(10).to_dict(orient='index')

# which will look like
{'2020-07-30': {'a': 2, 'b': 4},
 '2020-07-31': {'a': 1, 'b': 5},
 '2020-08-01': {'a': 2, 'b': 2},
 '2020-08-02': {'a': 9, 'b': 8},
 '2020-08-03': {'a': 4, 'b': 0},
 '2020-08-04': {'a': 3, 'b': 3},
 '2020-08-05': {'a': 7, 'b': 7},
 '2020-08-06': {'a': 7, 'b': 0},
 '2020-08-07': {'a': 8, 'b': 4},
 '2020-08-08': {'a': 3, 'b': 2}}

# copy the previous dict and paste into a code block on SO
# the dict can be converted to a dataframe with 
# df = pd.DataFrame.from_dict(d, orient='index')  # d is the name of the dict
# convert datatime column or index back to datetime
</code></pre>
<ul>
<li>For a more thorough answer using <code>.to_dict()</code>
<ul>
<li><a href=""https://stackoverflow.com/questions/63163254"">How to easily share a sample dataframe using df.to_dict()</a></li>
<li><a href=""https://stackoverflow.com/questions/32536193"">How to make good reproducible pandas examples</a></li>
</ul>
</li>
</ul>
"
3323013,"<p>It is a guard against a stack overflow, yes. Python (or rather, the CPython implementation) doesn't optimize tail recursion, and unbridled recursion causes stack overflows. You can check the recursion limit with <a href=""https://docs.python.org/library/sys.html#sys.getrecursionlimit"" rel=""noreferrer""><code>sys.getrecursionlimit</code></a>:</p>
<pre><code>import sys
print(sys.getrecursionlimit())
</code></pre>
<p>and change the recursion limit with <a href=""https://docs.python.org/library/sys.html#sys.setrecursionlimit"" rel=""noreferrer""><code>sys.setrecursionlimit</code></a>:</p>
<pre><code>sys.setrecursionlimit(1500)
</code></pre>
<p>but doing so is dangerous -- the standard limit is a little conservative, but Python stackframes can be quite big.</p>
<p>Python isn't a functional language and tail recursion is not a particularly efficient technique. Rewriting the algorithm iteratively, if possible, is generally a better idea.</p>
"
,
5082482,"<p>To answer your first question... <code>.format</code> just seems more sophisticated in many ways. An annoying thing about <code>%</code> is also how it can either take a variable or a tuple. You'd think the following would always work:</p>
<pre><code>&quot;Hello %s&quot; % name
</code></pre>
<p>yet, if <code>name</code> happens to be <code>(1, 2, 3)</code>, it will throw a <code>TypeError</code>. To guarantee that it always prints, you'd need to do</p>
<pre><code>&quot;Hello %s&quot; % (name,)   # supply the single argument as a single-item tuple
</code></pre>
<p>which is just ugly. <code>.format</code> doesn't have those issues. Also in the second example you gave, the <code>.format</code> example is much cleaner looking.</p>
<p>Only use it for backwards compatibility with Python 2.5.</p>
<hr />
<p>To answer your second question, string formatting happens at the same time as any other operation - when the string formatting expression is evaluated. And Python, not being a lazy language, evaluates expressions before calling functions, so the expression <code>log.debug(&quot;some debug info: %s&quot; % some_info)</code> will first evaluate the string to, e.g. <code>&quot;some debug info: roflcopters are active&quot;</code>, then that string will be passed to <code>log.debug()</code>.</p>
"
,
16985066,"<blockquote>
<p>unfortunately, this module needs to be inside the package, and it also
needs to be runnable as a script, sometimes. Any idea how I could
achieve that?</p>
</blockquote>
<p>It's quite common to have a layout like this...</p>
<pre><code>main.py
mypackage/
    __init__.py
    mymodule.py
    myothermodule.py
</code></pre>
<p>...with a <code>mymodule.py</code> like this...</p>
<pre><code>#!/usr/bin/env python3

# Exported function
def as_int(a):
    return int(a)

# Test function for module  
def _test():
    assert as_int('1') == 1

if __name__ == '__main__':
    _test()
</code></pre>
<p>...a <code>myothermodule.py</code> like this...</p>
<pre><code>#!/usr/bin/env python3

from .mymodule import as_int

# Exported function
def add(a, b):
    return as_int(a) + as_int(b)

# Test function for module  
def _test():
    assert add('1', '1') == 2

if __name__ == '__main__':
    _test()
</code></pre>
<p>...and a <code>main.py</code> like this...</p>
<pre><code>#!/usr/bin/env python3

from mypackage.myothermodule import add

def main():
    print(add('1', '1'))

if __name__ == '__main__':
    main()
</code></pre>
<p>...which works fine when you run <code>main.py</code> or <code>mypackage/mymodule.py</code>, but fails with <code>mypackage/myothermodule.py</code>, due to the relative import...</p>
<pre><code>from .mymodule import as_int
</code></pre>
<p>The way you're supposed to run it is by using the -m option and giving the path in the Python module system (rather than in the filesystem)...</p>
<pre><code>python3 -m mypackage.myothermodule
</code></pre>
<p>...but it's somewhat verbose, and doesn't mix well with a shebang line like <code>#!/usr/bin/env python3</code>.</p>
<p>An alternative is to avoid using relative imports, and just use...</p>
<pre><code>from mypackage.mymodule import as_int
</code></pre>
<p>Either way, you'll need to run from the parent of <code>mypackage</code>, or add that directory to <code>PYTHONPATH</code> (either one will ensure that <code>mypackage</code> is in the sys.path <a href=""https://docs.python.org/3/library/sys_path_init.html"" rel=""nofollow noreferrer"">module search path</a>). Or, if you want it to work &quot;out of the box&quot;, you can frob the <code>PYTHONPATH</code> in code first with this...</p>
<pre><code>import sys
import os

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
sys.path.append(os.path.dirname(SCRIPT_DIR))

from mypackage.mymodule import as_int
</code></pre>
<p>It's kind of a pain, but there's a clue as to why in <a href=""http://mail.python.org/pipermail/python-3000/2007-April/006793.html"" rel=""nofollow noreferrer"">an email</a> written by a certain Guido van Rossum...</p>
<blockquote>
<p>I'm -1 on this and on any other proposed twiddlings of the <code>__main__</code>
machinery. The only use case seems to be running scripts that happen
to be living inside a module's directory, which I've always seen as an
antipattern. To make me change my mind you'd have to convince me that
it isn't.</p>
</blockquote>
<p>Whether running scripts inside a package is an antipattern or not is subjective, but personally I find it really useful in a package I have which contains some custom wxPython widgets, so I can run the script for any of the source files to display a <code>wx.Frame</code> containing only that widget for testing purposes.</p>
"
107717,"<p>From <a href=""http://mail.python.org/pipermail/tutor/2003-November/026645.html"" rel=""noreferrer"">Magnus Lycka answer on a mailing list</a>:</p>
<blockquote>
<p>You can skip buffering for a whole
python process using <code>python -u</code>
or by
setting the environment variable
PYTHONUNBUFFERED.</p>
<p>You could also replace sys.stdout with
some other stream like wrapper which
does a flush after every call.</p>
<pre><code>class Unbuffered(object):
   def __init__(self, stream):
       self.stream = stream
   def write(self, data):
       self.stream.write(data)
       self.stream.flush()
   def writelines(self, datas):
       self.stream.writelines(datas)
       self.stream.flush()
   def __getattr__(self, attr):
       return getattr(self.stream, attr)

import sys
sys.stdout = Unbuffered(sys.stdout)
print 'Hello'
</code></pre>
</blockquote>
"
743823,"<p>Given a string <code>sentence</code>, this stores each word in a list called <code>words</code>:</p>
<pre><code>words = sentence.split()
</code></pre>
"
9001529,"<blockquote>
<p><strong>Note:</strong> for Python 3.7+, see <a href=""https://stackoverflow.com/a/47017849"">this answer</a></p>
</blockquote>
<p>Standard Python dictionaries are unordered (until Python 3.7). Even if you sorted the (key,value) pairs, you wouldn't be able to store them in a <code>dict</code> in a way that would preserve the ordering.</p>
<p>The easiest way is to use <a href=""http://docs.python.org/library/collections.html#collections.OrderedDict"" rel=""noreferrer""><code>OrderedDict</code></a>, which remembers the order in which the elements have been inserted:</p>
<pre><code>In [1]: import collections

In [2]: d = {2:3, 1:89, 4:5, 3:0}

In [3]: od = collections.OrderedDict(sorted(d.items()))

In [4]: od
Out[4]: OrderedDict([(1, 89), (2, 3), (3, 0), (4, 5)])
</code></pre>
<p>Never mind the way <code>od</code> is printed out; it'll work as expected:</p>
<pre><code>In [11]: od[1]
Out[11]: 89

In [12]: od[3]
Out[12]: 0

In [13]: for k, v in od.iteritems(): print k, v
   ....: 
1 89
2 3
3 0
4 5
</code></pre>
<h2>Python 3</h2>
<p>For Python 3 users, one needs to use the <code>.items()</code> instead of <code>.iteritems()</code>:</p>
<pre><code>In [13]: for k, v in od.items(): print(k, v)
   ....: 
1 89
2 3
3 0
4 5
</code></pre>
"
68672,"<p>Variables declared inside the class definition, but not inside a method are class or static variables:</p>
<pre><code>&gt;&gt;&gt; class MyClass:
...     i = 3
...
&gt;&gt;&gt; MyClass.i
3 
</code></pre>
<p>As @<a href=""https://stackoverflow.com/questions/68645/static-class-variables-in-python#answer-69067"">millerdev</a> points out, this creates a class-level <code>i</code> variable, but this is distinct from any instance-level <code>i</code> variable, so you could have</p>
<pre><code>&gt;&gt;&gt; m = MyClass()
&gt;&gt;&gt; m.i = 4
&gt;&gt;&gt; MyClass.i, m.i
&gt;&gt;&gt; (3, 4)
</code></pre>
<p>This is different from C++ and Java, but not so different from C#, where a static member can't be accessed using a reference to an instance.</p>
<p>See <a href=""https://docs.python.org/3/tutorial/classes.html#class-objects"" rel=""noreferrer"">what the Python tutorial has to say on the subject of classes and class objects</a>.</p>
<p>@Steve Johnson has already answered regarding <a href=""http://web.archive.org/web/20090214211613/http://pyref.infogami.com/staticmethod"" rel=""noreferrer"">static methods</a>, also documented under <a href=""https://docs.python.org/3/library/functions.html#staticmethod"" rel=""noreferrer"">&quot;Built-in Functions&quot; in the Python Library Reference</a>.</p>
<pre><code>class C:
    @staticmethod
    def f(arg1, arg2, ...): ...
</code></pre>
<p>@beidy recommends <a href=""https://docs.python.org/3/library/functions.html#classmethod"" rel=""noreferrer"">classmethod</a>s over staticmethod, as the method then receives the class type as the first argument.</p>
"
3394898,"<p><a href=""http://docs.python.org/tutorial/controlflow.html#arbitrary-argument-lists"" rel=""noreferrer"">The syntax is the <code>*</code> and <code>**</code></a>.  The names <code>*args</code> and <code>**kwargs</code> are only by convention but there's no hard requirement to use them.</p>

<p>You would use <code>*args</code> when you're not sure how many arguments might be passed to your function, i.e. it allows you pass an arbitrary number of arguments to your function.  For example:</p>

<pre><code>&gt;&gt;&gt; def print_everything(*args):
        for count, thing in enumerate(args):
...         print( '{0}. {1}'.format(count, thing))
...
&gt;&gt;&gt; print_everything('apple', 'banana', 'cabbage')
0. apple
1. banana
2. cabbage
</code></pre>

<p>Similarly, <code>**kwargs</code> allows you to handle named arguments that you have not defined in advance:</p>

<pre><code>&gt;&gt;&gt; def table_things(**kwargs):
...     for name, value in kwargs.items():
...         print( '{0} = {1}'.format(name, value))
...
&gt;&gt;&gt; table_things(apple = 'fruit', cabbage = 'vegetable')
cabbage = vegetable
apple = fruit
</code></pre>

<p>You can use these along with named arguments too.  The explicit arguments get values first and then everything else is passed to <code>*args</code> and <code>**kwargs</code>.  The named arguments come first in the list.  For example:</p>

<pre><code>def table_things(titlestring, **kwargs)
</code></pre>

<p>You can also use both in the same function definition but <code>*args</code> must occur before <code>**kwargs</code>.</p>

<p>You can also use the <code>*</code> and <code>**</code> syntax when calling a function.  For example:</p>

<pre><code>&gt;&gt;&gt; def print_three_things(a, b, c):
...     print( 'a = {0}, b = {1}, c = {2}'.format(a,b,c))
...
&gt;&gt;&gt; mylist = ['aardvark', 'baboon', 'cat']
&gt;&gt;&gt; print_three_things(*mylist)
a = aardvark, b = baboon, c = cat
</code></pre>

<p>As you can see in this case it takes the list (or tuple) of items and unpacks it. By this it matches them to the arguments in the function.  Of course, you could have a <code>*</code> both in the function definition and in the function call.</p>
"
54432584,"<h1><code>apply</code>, the Convenience Function you Never Needed</h1>
<p>We start by addressing the questions in the OP, one by one.</p>
<blockquote>
<h2>&quot;If <code>apply</code> is so bad, then why is it in the API?&quot;</h2>
</blockquote>
<p><a href=""https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply"" rel=""noreferrer""><code>DataFrame.apply</code></a> and <a href=""https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.apply.html"" rel=""noreferrer""><code>Series.apply</code></a> are <em>convenience functions</em> defined on DataFrame and Series object respectively. <code>apply</code> accepts any user defined function that applies a transformation/aggregation on a DataFrame. <code>apply</code> is effectively a silver bullet that does whatever any existing pandas function cannot do.</p>
<p>Some of the things <code>apply</code> can do:</p>
<ul>
<li>Run any user-defined function on a DataFrame or Series</li>
<li>Apply a function either row-wise (<code>axis=1</code>) or column-wise (<code>axis=0</code>) on a DataFrame</li>
<li>Perform index alignment while applying the function</li>
<li>Perform aggregation with user-defined functions (however, we usually prefer <code>agg</code> or <code>transform</code> in these cases)</li>
<li>Perform element-wise transformations</li>
<li>Broadcast aggregated results to original rows (see the <code>result_type</code> argument).</li>
<li>Accept positional/keyword arguments to pass to the user-defined functions.</li>
</ul>
<p>...Among others. For more information, see <a href=""https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html#row-or-column-wise-function-application"" rel=""noreferrer"">Row or Column-wise Function Application</a> in the documentation.</p>
<p>So, with all these features, why is <code>apply</code> bad? It is <strong>because <code>apply</code> is</strong> <strong>slow</strong>. Pandas makes no assumptions about the nature of your function, and so <strong>iteratively applies your function</strong> to each row/column as necessary. Additionally, handling <em>all</em> of the situations above means <code>apply</code> incurs some major overhead at each iteration. Further, <code>apply</code> consumes a lot more memory, which is a challenge for memory bounded applications.</p>
<p>There are very few situations where <code>apply</code> is appropriate to use (more on that below). <strong>If you're not sure whether you should be using <code>apply</code>, you probably shouldn't.</strong></p>
<hr />
<hr />
<p>Let's address the next question.</p>
<blockquote>
<h2>&quot;How and when should I make my code <code>apply</code>-free?&quot;</h2>
</blockquote>
<p>To rephrase, here are some common situations where you will want to <em>get rid</em> of any calls to <code>apply</code>.</p>
<h3><strong>Numeric Data</strong></h3>
<p>If you're working with numeric data, there is likely already a vectorized cython function that does exactly what you're trying to do (if not, please either ask a question on Stack Overflow or open a feature request on GitHub).</p>
<p>Contrast the performance of <code>apply</code> for a simple addition operation.</p>
<pre><code>df = pd.DataFrame({&quot;A&quot;: [9, 4, 2, 1], &quot;B&quot;: [12, 7, 5, 4]})
df

   A   B
0  9  12
1  4   7
2  2   5
3  1   4
</code></pre>
<p>&lt;!- -&gt;</p>
<pre><code>df.apply(np.sum)

A    16
B    28
dtype: int64

df.sum()

A    16
B    28
dtype: int64
</code></pre>
<p>Performance wise, there's no comparison, the cythonized equivalent is much faster. There's no need for a graph, because the difference is obvious even for toy data.</p>
<pre><code>%timeit df.apply(np.sum)
%timeit df.sum()
2.22 ms Â± 41.2 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
471 Âµs Â± 8.16 Âµs per loop (mean Â± std. dev. of 7 runs, 1000 loops each)
</code></pre>
<p>Even if you enable passing raw arrays with the <code>raw</code> argument, it's still twice as slow.</p>
<pre><code>%timeit df.apply(np.sum, raw=True)
840 Âµs Â± 691 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
</code></pre>
<p>Another example:</p>
<pre><code>df.apply(lambda x: x.max() - x.min())

A    8
B    8
dtype: int64

df.max() - df.min()

A    8
B    8
dtype: int64

%timeit df.apply(lambda x: x.max() - x.min())
%timeit df.max() - df.min()

2.43 ms Â± 450 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
1.23 ms Â± 14.7 Âµs per loop (mean Â± std. dev. of 7 runs, 1000 loops each)
</code></pre>
<p>In general, <strong>seek out vectorized alternatives if possible.</strong></p>
<hr />
<h3><strong>String/Regex</strong></h3>
<p>Pandas provides &quot;vectorized&quot; string functions in most situations, but there are rare cases where those functions do not... &quot;apply&quot;, so to speak.</p>
<p>A common problem is to check whether a value in a column is present in another column of the same row.</p>
<pre><code>df = pd.DataFrame({
    'Name': ['mickey', 'donald', 'minnie'],
    'Title': ['wonderland', &quot;welcome to donald's castle&quot;, 'Minnie mouse clubhouse'],
    'Value': [20, 10, 86]})
df

     Name  Value                       Title
0  mickey     20                  wonderland
1  donald     10  welcome to donald's castle
2  minnie     86      Minnie mouse clubhouse
</code></pre>
<p>This should return the row second and third row, since &quot;donald&quot; and &quot;minnie&quot; are present in their respective &quot;Title&quot; columns.</p>
<p>Using apply, this would be done using</p>
<pre><code>df.apply(lambda x: x['Name'].lower() in x['Title'].lower(), axis=1)

0    False
1     True
2     True
dtype: bool
 
df[df.apply(lambda x: x['Name'].lower() in x['Title'].lower(), axis=1)]

     Name                       Title  Value
1  donald  welcome to donald's castle     10
2  minnie      Minnie mouse clubhouse     86
</code></pre>
<p>However, a better solution exists using list comprehensions.</p>
<pre><code>df[[y.lower() in x.lower() for x, y in zip(df['Title'], df['Name'])]]

     Name                       Title  Value
1  donald  welcome to donald's castle     10
2  minnie      Minnie mouse clubhouse     86
</code></pre>
<p>&lt;!- -&gt;</p>
<pre><code>%timeit df[df.apply(lambda x: x['Name'].lower() in x['Title'].lower(), axis=1)]
%timeit df[[y.lower() in x.lower() for x, y in zip(df['Title'], df['Name'])]]

2.85 ms Â± 38.4 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
788 Âµs Â± 16.4 Âµs per loop (mean Â± std. dev. of 7 runs, 1000 loops each)
</code></pre>
<p>The thing to note here is that iterative routines happen to be faster than <code>apply</code>, because of the lower overhead. If you need to handle NaNs and invalid dtypes, you can build on this using a custom function you can then call with arguments inside the list comprehension.</p>
<p>For more information on when list comprehensions should be considered a good option, see my writeup: <a href=""https://stackoverflow.com/questions/54028199/for-loops-with-pandas-when-should-i-care"">Are for-loops in pandas really bad? When should I care?</a>.</p>
<blockquote>
<p><strong>Note</strong><br />
Date and datetime operations also have vectorized versions. So, for example, you should prefer <code>pd.to_datetime(df['date'])</code>, over,
say, <code>df['date'].apply(pd.to_datetime)</code>.</p>
<p>Read more at the
<a href=""https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html"" rel=""noreferrer"">docs</a>.</p>
</blockquote>
<hr />
<h3><strong>A Common Pitfall: Exploding Columns of Lists</strong></h3>
<pre><code>s = pd.Series([[1, 2]] * 3)
s

0    [1, 2]
1    [1, 2]
2    [1, 2]
dtype: object
</code></pre>
<p>People are tempted to use <code>apply(pd.Series)</code>. This is <em>horrible</em> in terms of performance.</p>
<pre><code>s.apply(pd.Series)

   0  1
0  1  2
1  1  2
2  1  2
</code></pre>
<p>A better option is to listify the column and pass it to pd.DataFrame.</p>
<pre><code>pd.DataFrame(s.tolist())

   0  1
0  1  2
1  1  2
2  1  2
</code></pre>
<p>&lt;!- -&gt;</p>
<pre><code>%timeit s.apply(pd.Series)
%timeit pd.DataFrame(s.tolist())

2.65 ms Â± 294 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
816 Âµs Â± 40.5 Âµs per loop (mean Â± std. dev. of 7 runs, 1000 loops each)
</code></pre>
<hr />
<hr />
<p>Lastly,</p>
<blockquote>
<h2>&quot;Are there any situations where <code>apply</code> is good?&quot;</h2>
</blockquote>
<p>Apply is a convenience function, so there <em>are</em> situations where the overhead is negligible enough to forgive. It really depends on how many times the function is called.</p>
<p><strong>Functions that are Vectorized for Series, but not DataFrames</strong><br />
What if you want to apply a string operation on multiple columns? What if you want to convert multiple columns to datetime? These functions are vectorized for Series only, so they must be <em>applied</em> over each column that you want to convert/operate on.</p>
<pre><code>df = pd.DataFrame(
         pd.date_range('2018-12-31','2019-01-31', freq='2D').date.astype(str).reshape(-1, 2), 
         columns=['date1', 'date2'])
df

       date1      date2
0 2018-12-31 2019-01-02
1 2019-01-04 2019-01-06
2 2019-01-08 2019-01-10
3 2019-01-12 2019-01-14
4 2019-01-16 2019-01-18
5 2019-01-20 2019-01-22
6 2019-01-24 2019-01-26
7 2019-01-28 2019-01-30

df.dtypes

date1    object
date2    object
dtype: object
    
</code></pre>
<p>This is an admissible case for <code>apply</code>:</p>
<pre><code>df.apply(pd.to_datetime, errors='coerce').dtypes

date1    datetime64[ns]
date2    datetime64[ns]
dtype: object
</code></pre>
<p>Note that it would also make sense to <code>stack</code>, or just use an explicit loop. All these options are slightly faster than using <code>apply</code>, but the difference is small enough to forgive.</p>
<pre><code>%timeit df.apply(pd.to_datetime, errors='coerce')
%timeit pd.to_datetime(df.stack(), errors='coerce').unstack()
%timeit pd.concat([pd.to_datetime(df[c], errors='coerce') for c in df], axis=1)
%timeit for c in df.columns: df[c] = pd.to_datetime(df[c], errors='coerce')

5.49 ms Â± 247 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
3.94 ms Â± 48.1 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
3.16 ms Â± 216 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
2.41 ms Â± 1.71 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
</code></pre>
<p>You can make a similar case for other operations such as string operations, or conversion to category.</p>
<pre><code>u = df.apply(lambda x: x.str.contains(...))
v = df.apply(lambda x: x.astype(category))
</code></pre>
<p>v/s</p>
<pre><code>u = pd.concat([df[c].str.contains(...) for c in df], axis=1)
v = df.copy()
for c in df:
    v[c] = df[c].astype(category)
</code></pre>
<p>And so on...</p>
<hr />
<h3><strong>Converting Series to <code>str</code>: <code>astype</code> versus <code>apply</code></strong></h3>
<p>This seems like an idiosyncrasy of the API. Using <code>apply</code> to convert integers in a Series to string is comparable (and sometimes faster) than using <code>astype</code>.</p>
<p><a href=""https://i.stack.imgur.com/eSs2r.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/eSs2r.png"" alt=""enter image description here"" /></a>
The graph was plotted using the <a href=""https://github.com/nschloe/perfplot"" rel=""noreferrer""><code>perfplot</code></a> library.</p>
<pre><code>import perfplot

perfplot.show(
    setup=lambda n: pd.Series(np.random.randint(0, n, n)),
    kernels=[
        lambda s: s.astype(str),
        lambda s: s.apply(str)
    ],
    labels=['astype', 'apply'],
    n_range=[2**k for k in range(1, 20)],
    xlabel='N',
    logx=True,
    logy=True,
    equality_check=lambda x, y: (x == y).all())
</code></pre>
<p>With floats, I see the <code>astype</code> is consistently as fast as, or slightly faster than <code>apply</code>. So this has to do with the fact that the data in the test is integer type.</p>
<hr />
<h3><strong><code>GroupBy</code> operations with chained transformations</strong></h3>
<p><code>GroupBy.apply</code> has not been discussed until now, but <code>GroupBy.apply</code> is also an iterative convenience function to handle anything that the existing <code>GroupBy</code> functions do not.</p>
<p>One common requirement is to perform a GroupBy and then two prime operations such as a &quot;lagged cumsum&quot;:</p>
<pre><code>df = pd.DataFrame({&quot;A&quot;: list('aabcccddee'), &quot;B&quot;: [12, 7, 5, 4, 5, 4, 3, 2, 1, 10]})
df

   A   B
0  a  12
1  a   7
2  b   5
3  c   4
4  c   5
5  c   4
6  d   3
7  d   2
8  e   1
9  e  10
</code></pre>
<p>&lt;!- -&gt;</p>
<p>You'd need two successive groupby calls here:</p>
<pre><code>df.groupby('A').B.cumsum().groupby(df.A).shift()
 
0     NaN
1    12.0
2     NaN
3     NaN
4     4.0
5     9.0
6     NaN
7     3.0
8     NaN
9     1.0
Name: B, dtype: float64
</code></pre>
<p>Using <code>apply</code>, you can shorten this to a a single call.</p>
<pre><code>df.groupby('A').B.apply(lambda x: x.cumsum().shift())

0     NaN
1    12.0
2     NaN
3     NaN
4     4.0
5     9.0
6     NaN
7     3.0
8     NaN
9     1.0
Name: B, dtype: float64
</code></pre>
<p>It is very hard to quantify the performance because it depends on the data. But in general, <code>apply</code> is an acceptable solution if the goal is to reduce a <code>groupby</code> call (because <code>groupby</code> is also quite expensive).</p>
<hr />
<hr />
<h2>Other Caveats</h2>
<p>Aside from the caveats mentioned above, it is also worth mentioning that <code>apply</code> operates on the first row (or column) twice. This is done to determine whether the function has any side effects. If not, <code>apply</code> may be able to use a fast-path for evaluating the result, else it falls back to a slow implementation.</p>
<pre><code>df = pd.DataFrame({
    'A': [1, 2],
    'B': ['x', 'y']
})

def func(x):
    print(x['A'])
    return x

df.apply(func, axis=1)

# 1
# 1
# 2
   A  B
0  1  x
1  2  y
</code></pre>
<p>This behaviour is also seen in <code>GroupBy.apply</code> on pandas versions &lt;0.25 (it was fixed for 0.25, <a href=""https://stackoverflow.com/a/56215416/4909087"">see here for more information</a>.)</p>
"
576183,"<p><code>super()</code> lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of <a href=""http://www.artima.com/weblogs/viewpost.jsp?thread=236275"" rel=""noreferrer"">fun stuff</a> can happen. See the <a href=""https://docs.python.org/2/library/functions.html#super"" rel=""noreferrer"">standard docs on super</a> if you haven't already.</p>

<p>Note that <a href=""https://docs.python.org/3/library/functions.html#super"" rel=""noreferrer"">the syntax changed in Python 3.0</a>: you can just say <code>super().__init__()</code> instead of <code>super(ChildB, self).__init__()</code> which IMO is quite a bit nicer. The standard docs also refer to a <a href=""https://rhettinger.wordpress.com/2011/05/26/super-considered-super/"" rel=""noreferrer"">guide to using <code>super()</code></a> which is quite explanatory.</p>
"
1009864,"<p>The canonical solution in the standard library is <code>argparse</code> (<a href=""https://docs.python.org/3/library/argparse.html"" rel=""noreferrer"">docs</a>):</p>

<p>Here is an example:</p>

<pre><code>from argparse import ArgumentParser

parser = ArgumentParser()
parser.add_argument(""-f"", ""--file"", dest=""filename"",
                    help=""write report to FILE"", metavar=""FILE"")
parser.add_argument(""-q"", ""--quiet"",
                    action=""store_false"", dest=""verbose"", default=True,
                    help=""don't print status messages to stdout"")

args = parser.parse_args()
</code></pre>

<p><code>argparse</code> supports (among other things):</p>

<ul>
<li>Multiple options in any order.</li>
<li>Short and long options.</li>
<li>Default values.</li>
<li>Generation of a usage help message.</li>
</ul>
"
10063039,"<p>If <code>a</code> and <code>b</code> are Boolean NumPy arrays, the <code>&amp;</code> operation returns the elementwise-and of them:</p>
<pre><code>a &amp; b
</code></pre>
<p>That returns a Boolean <em>array</em>. To reduce this to a single Boolean <em>value</em>, use either</p>
<pre><code>(a &amp; b).any()
</code></pre>
<p>or</p>
<pre><code>(a &amp; b).all()
</code></pre>
<p>Note: if <code>a</code> and <code>b</code> are <em>non-Boolean</em> arrays, consider <code>(a - b).any()</code> or <code>(a - b).all()</code> instead.</p>
<hr />
<h4>Rationale</h4>
<p>The NumPy developers felt there was no one commonly understood way to evaluate an array in Boolean context: it could mean <code>True</code> if <em>any</em> element is <code>True</code>, or it could mean <code>True</code> if <em>all</em> elements are <code>True</code>, or <code>True</code> if the array has non-zero length, just to name three possibilities.</p>
<p>Since different users might have different needs and different assumptions, the
NumPy developers refused to guess and instead decided to raise a <code>ValueError</code> whenever one tries to evaluate an array in Boolean context. Applying <code>and</code> to two numpy arrays causes the two arrays to be evaluated in Boolean context (by calling <code>__bool__</code> in Python3 or <code>__nonzero__</code> in Python2).</p>
"
22221675,"<p>You can do this using <code>groupby</code> to group on the column of interest and then <code>apply</code> <code>list</code> to every group:</p>

<pre><code>In [1]: df = pd.DataFrame( {'a':['A','A','B','B','B','C'], 'b':[1,2,5,5,4,6]})
        df

Out[1]: 
   a  b
0  A  1
1  A  2
2  B  5
3  B  5
4  B  4
5  C  6

In [2]: df.groupby('a')['b'].apply(list)
Out[2]: 
a
A       [1, 2]
B    [5, 5, 4]
C          [6]
Name: b, dtype: object

In [3]: df1 = df.groupby('a')['b'].apply(list).reset_index(name='new')
        df1
Out[3]: 
   a        new
0  A     [1, 2]
1  B  [5, 5, 4]
2  C        [6]
</code></pre>
"
8548165,"<p>pip is run from the command line, not the Python interpreter. It is a program that <strong>installs</strong> modules, so you can use them from Python. Once you have installed the module, then you can open the Python shell and do <code>import selenium</code>.</p>

<p>The Python shell is not a command line, it is an interactive interpreter. You type Python code into it, not commands.</p>
"
5466478,"<p>You need to double the <code>{{</code> and <code>}}</code>:</p>

<pre><code>&gt;&gt;&gt; x = "" {{ Hello }} {0} ""
&gt;&gt;&gt; print(x.format(42))
' { Hello } 42 '
</code></pre>

<p>Here's the relevant part of the <a href=""https://docs.python.org/library/string.html#formatstrings"" rel=""noreferrer"">Python documentation for format string syntax</a>:</p>

<blockquote>
  <p>Format strings contain âreplacement fieldsâ surrounded by curly braces <code>{}</code>. Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. If you need to include a brace character in the literal text, it can be escaped by doubling: <code>{{</code> and <code>}}</code>.</p>
</blockquote>
"
931095,"<p>Using <a href=""https://stackoverflow.com/questions/509211/understanding-slicing"">slicing</a>:</p>
<pre><code>&gt;&gt;&gt; 'hello world'[::-1]
'dlrow olleh'
</code></pre>
<hr />
<p>Slice notation takes the form <code>[start:stop:step]</code>. In this case, we omit the <code>start</code> and <code>stop</code> positions since we want the whole string. We also use <code>step = -1</code>, which means, &quot;repeatedly step from right to left by 1 character&quot;.</p>
"
4020824,"<p>The correct thing to do is use the 'string-escape' code to decode the string.</p>

<pre><code>&gt;&gt;&gt; myString = ""spam\\neggs""
&gt;&gt;&gt; decoded_string = bytes(myString, ""utf-8"").decode(""unicode_escape"") # python3 
&gt;&gt;&gt; decoded_string = myString.decode('string_escape') # python2
&gt;&gt;&gt; print(decoded_string)
spam
eggs
</code></pre>

<p>Don't use the AST or eval. Using the string codecs is much safer.</p>
"
1466036,"<p>The opening modes are exactly the same as those for the C standard library function <strong><code>fopen()</code></strong>.</p>

<p><a href=""http://www.manpagez.com/man/3/fopen/"" rel=""noreferrer"">The BSD <code>fopen</code> manpage</a> defines them as follows:</p>

<pre class=""lang-none prettyprint-override""><code> The argument mode points to a string beginning with one of the following
 sequences (Additional characters may follow these sequences.):

 ``r''   Open text file for reading.  The stream is positioned at the
         beginning of the file.

 ``r+''  Open for reading and writing.  The stream is positioned at the
         beginning of the file.

 ``w''   Truncate file to zero length or create text file for writing.
         The stream is positioned at the beginning of the file.

 ``w+''  Open for reading and writing.  The file is created if it does not
         exist, otherwise it is truncated.  The stream is positioned at
         the beginning of the file.

 ``a''   Open for writing.  The file is created if it does not exist.  The
         stream is positioned at the end of the file.  Subsequent writes
         to the file will always end up at the then current end of file,
         irrespective of any intervening fseek(3) or similar.

 ``a+''  Open for reading and writing.  The file is created if it does not
         exist.  The stream is positioned at the end of the file.  Subse-
         quent writes to the file will always end up at the then current
         end of file, irrespective of any intervening fseek(3) or similar.
</code></pre>
"
52108199,"<h2><strong>Replacing <code>cdc_</code> string</strong></h2>
<p>You can use <a href=""https://en.wikipedia.org/wiki/Vim_%28text_editor%29"" rel=""nofollow noreferrer"">Vim</a> or <a href=""https://en.wikipedia.org/wiki/Perl"" rel=""nofollow noreferrer"">Perl</a> to replace the <code>cdc_</code> string in <code>chromedriver</code>. <em>See the <a href=""https://stackoverflow.com/a/41220267/6841414"">answer by @Erti-Chris Eelmaa</a> to learn more about that string and how it's a detection point</em>.</p>
<p>Using Vim or Perl prevents you from having to recompile source code or use a hex editor.</p>
<p><strong>Make sure to make a copy of the original <code>chromedriver</code> before attempting to edit it.</strong></p>
<p>Our goal is to alter the <code>cdc_</code> string, which looks something like <code>$cdc_lasutopfhvcZLmcfl</code>.</p>
<p>The methods below were tested on <code>chromedriver version 2.41.578706</code>.</p>
<hr />
<h2><strong>Using Vim</strong></h2>
<pre><code>vim -b /path/to/chromedriver
</code></pre>
<p>After running the line above, you'll probably see a bunch of gibberish. Do the following:</p>
<ol>
<li>Replace all instances of <code>cdc_</code> with <code>dog_</code> by typing <code>:%s/cdc_/dog_/g</code>.
<ul>
<li><code>dog_</code> is just an example. You can choose anything as long as it has the same amount of characters as the search string (e.g., <code>cdc_</code>), otherwise the <code>chromedriver</code> will fail.</li>
</ul>
</li>
<li>To save the changes and quit, type <code>:wq!</code> and press <code>return</code>.
<ul>
<li>If you need to quit without saving changes, type <code>:q!</code> and press <code>return</code>.</li>
</ul>
</li>
</ol>
<p>The <code>-b</code> option tells vim upfront to open the file as a binary, so it won't mess with things like (missing) line endings (especially at the end of the file).</p>
<hr />
<h2><strong>Using Perl</strong></h2>
<p>The line below replaces all <code>cdc_</code> occurrences with <code>dog_</code>. Credit to <a href=""https://stackoverflow.com/questions/33225947/can-a-website-detect-when-you-are-using-selenium-with-chromedriver/52108199?noredirect=1#comment84056917_41220267"">Vic Seedoubleyew</a>:</p>
<pre><code>perl -pi -e 's/cdc_/dog_/g' /path/to/chromedriver
</code></pre>
<p>Make sure that the replacement string (e.g., <code>dog_</code>) has the same number of characters as the search string (e.g., <code>cdc_</code>), otherwise the <code>chromedriver</code> will fail.</p>
<hr />
<h2><em><strong>Wrapping Up</strong></em></h2>
<p>To verify that all occurrences of <code>cdc_</code> were replaced:</p>
<pre><code>grep &quot;cdc_&quot; /path/to/chromedriver
</code></pre>
<p>If no output was returned, the replacement was successful.</p>
<p>Go to the altered <code>chromedriver</code> and double click on it. A terminal window should open up. If you don't see <code>killed</code> in the output, you've successfully altered the driver.</p>
<p>Make sure that the name of the altered <code>chromedriver</code> binary is <code>chromedriver</code>, and that the original binary is either moved from its original location or renamed.</p>
<hr />
<h2><em><strong>My Experience With This Method</strong></em></h2>
<p>I was previously being detected on a website while trying to log in, but after replacing <code>cdc_</code> with an equal sized string, I was able to log in. Like others have said though, if you've already been detected, you might get blocked for a plethora of other reasons even after using this method. So you may have to try accessing the site that was detecting you using a VPN, different network, etc.</p>
"
20250996,"<p>You can use <a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.replace.html"" rel=""noreferrer""><code>.replace</code></a>.  For example:</p>

<pre><code>&gt;&gt;&gt; df = pd.DataFrame({'col2': {0: 'a', 1: 2, 2: np.nan}, 'col1': {0: 'w', 1: 1, 2: 2}})
&gt;&gt;&gt; di = {1: ""A"", 2: ""B""}
&gt;&gt;&gt; df
  col1 col2
0    w    a
1    1    2
2    2  NaN
&gt;&gt;&gt; df.replace({""col1"": di})
  col1 col2
0    w    a
1    A    2
2    B  NaN
</code></pre>

<p>or directly on the <a href=""https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.replace.html"" rel=""noreferrer""><code>Series</code></a>, i.e. <code>df[""col1""].replace(di, inplace=True)</code>.</p>
"
494273,"<p>You may use the <a href=""http://docs.python.org/library/signal.html"" rel=""noreferrer"">signal</a> package if you are running on UNIX:</p>
<pre><code>In [1]: import signal

# Register an handler for the timeout
In [2]: def handler(signum, frame):
   ...:     print(&quot;Forever is over!&quot;)
   ...:     raise Exception(&quot;end of time&quot;)
   ...: 

# This function *may* run for an indetermined time...
In [3]: def loop_forever():
   ...:     import time
   ...:     while 1:
   ...:         print(&quot;sec&quot;)
   ...:         time.sleep(1)
   ...:         
   ...:         

# Register the signal function handler
In [4]: signal.signal(signal.SIGALRM, handler)
Out[4]: 0

# Define a timeout for your function
In [5]: signal.alarm(10)
Out[5]: 0

In [6]: try:
   ...:     loop_forever()
   ...: except Exception, exc: 
   ...:     print(exc)
   ....: 
sec
sec
sec
sec
sec
sec
sec
sec
Forever is over!
end of time

# Cancel the timer if the function returned before timeout
# (ok, mine won't but yours maybe will :)
In [7]: signal.alarm(0)
Out[7]: 0
</code></pre>
<p>10 seconds after the call <code>signal.alarm(10)</code>, the handler is called. This raises an exception that you can intercept from the regular Python code.</p>
<p>This module doesn't play well with threads (but then, who does?)</p>
<p><strong>Note that</strong> since we raise an exception when timeout happens, it may end up caught and ignored inside the function, for example of one such function:</p>
<pre><code>def loop_forever():
    while 1:
        print('sec')
        try:
            time.sleep(10)
        except:
            continue
</code></pre>
"
33533514,"<p><strong>TL;DR</strong>: As of today (2019), in Python 3.7+ you can turn this feature on using a &quot;future&quot; statement, <code>from __future__ import annotations</code>.</p>
<p>(The behaviour enabled by <code>from __future__ import annotations</code> <em>might</em> become the default in future versions of Python, and <a href=""https://www.python.org/dev/peps/pep-0563/"" rel=""noreferrer"">was going</a> to be made the default in Python 3.10. However, the change in 3.10 <a href=""https://mail.python.org/archives/list/python-dev@python.org/thread/CLVXXPQ2T2LQ5MP2Y53VVQFCXYWQJHKZ/"" rel=""noreferrer"">was reverted</a> at the last minute, and now may not happen at all.)</p>
<p>In Python 3.6 or below, you should use a string.</p>
<hr />
<p>I guess you got this exception:</p>
<pre><code>NameError: name 'Position' is not defined
</code></pre>
<p>This is because <code>Position</code> must be defined before you can use it in an annotation, unless you are using Python with <a href=""https://www.python.org/dev/peps/pep-0563/"" rel=""noreferrer"">PEP 563</a> changes enabled.</p>
<h2>Python 3.7+: <code>from __future__ import annotations</code></h2>
<p>Python 3.7 introduces <a href=""https://www.python.org/dev/peps/pep-0563/"" rel=""noreferrer"">PEP 563: postponed evaluation of annotations</a>. A module that uses the future statement <code>from __future__ import annotations</code> will store annotations as strings automatically:</p>
<pre><code>from __future__ import annotations

class Position:
    def __add__(self, other: Position) -&gt; Position:
        ...
</code></pre>
<p>This had been scheduled to become the default in Python 3.10, but this change has now been postponed. Since Python still is a dynamically typed language so no type-checking is done at runtime, typing annotations should have no performance impact, right? Wrong! Before Python 3.7, the typing module used to be <a href=""https://www.python.org/dev/peps/pep-0560/#performance"" rel=""noreferrer"">one of the slowest python modules in core</a> so <strong>for code that involves importing the <code>typing</code> module, you will see an <a href=""https://docs.python.org/3.7/whatsnew/3.7.html#pep-560-core-support-for-typing-module-and-generic-types"" rel=""noreferrer"">up to 7 times increase in performance</a> when you upgrade to 3.7.</strong></p>
<h2>Python &lt;3.7: use a string</h2>
<p><a href=""https://www.python.org/dev/peps/pep-0484/#forward-references"" rel=""noreferrer"">According to PEP 484</a>, you should use a string instead of the class itself:</p>
<pre><code>class Position:
    ...
    def __add__(self, other: 'Position') -&gt; 'Position':
       ...
</code></pre>
<p>If you use the Django framework, this may be familiar, as Django models also use strings for forward references (foreign key definitions where the foreign model is <code>self</code> or is not declared yet). This should work with Pycharm and other tools.</p>
<h2>Sources</h2>
<p>The relevant parts of PEP 484 and PEP 563, to spare you the trip:</p>
<blockquote>
<h1><a href=""https://www.python.org/dev/peps/pep-0484/#forward-references"" rel=""noreferrer"">Forward references</a></h1>
<p>When a type hint contains names that have not been defined yet, that definition may be expressed as a string literal, to be resolved later.</p>
<p>A situation where this occurs commonly is the definition of a container class, where the class being defined occurs in the signature of some of the methods. For example, the following code (the start of a simple binary tree implementation) does not work:</p>
<pre><code>class Tree:
    def __init__(self, left: Tree, right: Tree):
        self.left = left
        self.right = right
</code></pre>
<p>To address this, we write:</p>
<pre><code>class Tree:
    def __init__(self, left: 'Tree', right: 'Tree'):
        self.left = left
        self.right = right
</code></pre>
<p>The string literal should contain a valid Python expression (i.e., compile(lit, '', 'eval') should be a valid code object) and it should evaluate without errors once the module has been fully loaded. The local and global namespace in which it is evaluated should be the same namespaces in which default arguments to the same function would be evaluated.</p>
</blockquote>
<p>and PEP 563:</p>
<blockquote>
<h1><a href=""https://www.python.org/dev/peps/pep-0563/#implementation"" rel=""noreferrer"">Implementation</a></h1>
<p>In Python 3.10, function and variable annotations will no longer be evaluated at definition time. Instead, a string form will be preserved in the respectiveÂ <code>__annotations__</code>Â dictionary. Static type checkers will see no difference in behavior, whereas tools using annotations at runtime will have to perform postponed evaluation.</p>
<p>...</p>
<h2><a href=""https://www.python.org/dev/peps/pep-0563/#enabling-the-future-behavior-in-python-3-7"" rel=""noreferrer"">Enabling the future behavior in Python 3.7</a></h2>
<p>The functionality described above can be enabled starting from Python 3.7 using the following special import:</p>
<pre><code>from __future__ import annotations
</code></pre>
</blockquote>
<h2>Things that you may be tempted to do instead</h2>
<h3>A. Define a dummy <code>Position</code></h3>
<p>Before the class definition, place a dummy definition:</p>
<pre><code>class Position(object):
    pass


class Position(object):
    ...
</code></pre>
<p>This will get rid of the <code>NameError</code> and may even look OK:</p>
<pre><code>&gt;&gt;&gt; Position.__add__.__annotations__
{'other': __main__.Position, 'return': __main__.Position}
</code></pre>
<p>But is it?</p>
<pre><code>&gt;&gt;&gt; for k, v in Position.__add__.__annotations__.items():
...     print(k, 'is Position:', v is Position)                                                                                                                                                                                                                  
return is Position: False
other is Position: False
</code></pre>
<h3>B. Monkey-patch in order to add the annotations:</h3>
<p>You may want to try some Python metaprogramming magic and write a decorator
to monkey-patch the class definition in order to add annotations:</p>
<pre><code>class Position:
    ...
    def __add__(self, other):
        return self.__class__(self.x + other.x, self.y + other.y)
</code></pre>
<p>The decorator should be responsible for the equivalent of this:</p>
<pre><code>Position.__add__.__annotations__['return'] = Position
Position.__add__.__annotations__['other'] = Position
</code></pre>
<p>At least it seems right:</p>
<pre><code>&gt;&gt;&gt; for k, v in Position.__add__.__annotations__.items():
...     print(k, 'is Position:', v is Position)                                                                                                                                                                                                                  
return is Position: True
other is Position: True
</code></pre>
<p>Probably too much trouble.</p>
"
606199,"<p><a href=""https://docs.python.org/3/library/stdtypes.html#bytes.decode"" rel=""noreferrer"">Decode the <code>bytes</code> object</a> to produce a string:</p>
<pre><code>&gt;&gt;&gt; b&quot;abcde&quot;.decode(&quot;utf-8&quot;) 
'abcde'
</code></pre>
<p>The above example <em>assumes</em> that the <code>bytes</code> object is in UTF-8, because it is a common encoding. However, you should use the encoding your data is actually in!</p>
"
189685,"<p>My first instinct would be to refactor the nested loop into a function and use <code>return</code> to break out. </p>
"
2068548,"<p><strong>Warning:</strong> <code>timeit</code> results may vary due to differences in hardware or
version of Python.  </p>

<p>Below is a script which compares a number of implementations: 
<UL>
<LI>ambi_sieve_plain,
<LI><a href=""https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188"">rwh_primes</a>, 
<LI><a href=""https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188"">rwh_primes1</a>, 
<LI><a href=""https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188"">rwh_primes2</a>, 
<LI><a href=""https://web.archive.org/web/20080324064651/http://krenzel.info/?p=83"" rel=""noreferrer"">sieveOfAtkin</a>, 
<LI><a href=""http://groups.google.com/group/comp.lang.python/msg/f1f10ced88c68c2d"" rel=""noreferrer"">sieveOfEratosthenes</a>, 
<LI><a href=""https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/2073279#2073279"">sundaram3</a>,
<LI><a href=""http://zerovolt.com/?p=88"" rel=""noreferrer"">sieve_wheel_30</a>,
<LI><a href=""http://tommih.blogspot.com/2009/04/fast-prime-number-generator.html"" rel=""noreferrer"">ambi_sieve</a> (requires numpy)
<LI><a href=""https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188"">primesfrom3to</a> (requires numpy)
<LI><a href=""https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188"">primesfrom2to</a> (requires numpy)
</UL></p>

<p>Many thanks to <a href=""https://stackoverflow.com/users/92092/stephan"">stephan</a> for bringing sieve_wheel_30 to my attention.
Credit goes to <a href=""https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188"">Robert William Hanks</a> for primesfrom2to, primesfrom3to, rwh_primes, rwh_primes1, and rwh_primes2.</p>

<p>Of the plain Python methods tested, <strong>with psyco</strong>, for n=1000000,
<strong>rwh_primes1</strong> was the fastest tested.</p>

<pre><code>+---------------------+-------+
| Method              | ms    |
+---------------------+-------+
| rwh_primes1         | 43.0  |
| sieveOfAtkin        | 46.4  |
| rwh_primes          | 57.4  |
| sieve_wheel_30      | 63.0  |
| rwh_primes2         | 67.8  |    
| sieveOfEratosthenes | 147.0 |
| ambi_sieve_plain    | 152.0 |
| sundaram3           | 194.0 |
+---------------------+-------+
</code></pre>

<p>Of the plain Python methods tested, <strong>without psyco</strong>, for n=1000000,
<strong>rwh_primes2</strong> was the fastest.</p>

<pre><code>+---------------------+-------+
| Method              | ms    |
+---------------------+-------+
| rwh_primes2         | 68.1  |
| rwh_primes1         | 93.7  |
| rwh_primes          | 94.6  |
| sieve_wheel_30      | 97.4  |
| sieveOfEratosthenes | 178.0 |
| ambi_sieve_plain    | 286.0 |
| sieveOfAtkin        | 314.0 |
| sundaram3           | 416.0 |
+---------------------+-------+
</code></pre>

<p>Of all the methods tested, <em>allowing numpy</em>, for n=1000000,
<strong>primesfrom2to</strong> was the fastest tested.</p>

<pre><code>+---------------------+-------+
| Method              | ms    |
+---------------------+-------+
| primesfrom2to       | 15.9  |
| primesfrom3to       | 18.4  |
| ambi_sieve          | 29.3  |
+---------------------+-------+
</code></pre>

<p>Timings were measured using the command:</p>

<pre><code>python -mtimeit -s""import primes"" ""primes.{method}(1000000)""
</code></pre>

<p>with <code>{method}</code> replaced by each of the method names.</p>

<p>primes.py:</p>

<pre><code>#!/usr/bin/env python
import psyco; psyco.full()
from math import sqrt, ceil
import numpy as np

def rwh_primes(n):
    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188
    """""" Returns  a list of primes &lt; n """"""
    sieve = [True] * n
    for i in xrange(3,int(n**0.5)+1,2):
        if sieve[i]:
            sieve[i*i::2*i]=[False]*((n-i*i-1)/(2*i)+1)
    return [2] + [i for i in xrange(3,n,2) if sieve[i]]

def rwh_primes1(n):
    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188
    """""" Returns  a list of primes &lt; n """"""
    sieve = [True] * (n/2)
    for i in xrange(3,int(n**0.5)+1,2):
        if sieve[i/2]:
            sieve[i*i/2::i] = [False] * ((n-i*i-1)/(2*i)+1)
    return [2] + [2*i+1 for i in xrange(1,n/2) if sieve[i]]

def rwh_primes2(n):
    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188
    """""" Input n&gt;=6, Returns a list of primes, 2 &lt;= p &lt; n """"""
    correction = (n%6&gt;1)
    n = {0:n,1:n-1,2:n+4,3:n+3,4:n+2,5:n+1}[n%6]
    sieve = [True] * (n/3)
    sieve[0] = False
    for i in xrange(int(n**0.5)/3+1):
      if sieve[i]:
        k=3*i+1|1
        sieve[      ((k*k)/3)      ::2*k]=[False]*((n/6-(k*k)/6-1)/k+1)
        sieve[(k*k+4*k-2*k*(i&amp;1))/3::2*k]=[False]*((n/6-(k*k+4*k-2*k*(i&amp;1))/6-1)/k+1)
    return [2,3] + [3*i+1|1 for i in xrange(1,n/3-correction) if sieve[i]]

def sieve_wheel_30(N):
    # http://zerovolt.com/?p=88
    ''' Returns a list of primes &lt;= N using wheel criterion 2*3*5 = 30

Copyright 2009 by zerovolt.com
This code is free for non-commercial purposes, in which case you can just leave this comment as a credit for my work.
If you need this code for commercial purposes, please contact me by sending an email to: info [at] zerovolt [dot] com.'''
    __smallp = ( 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,
    61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139,
    149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227,
    229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311,
    313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401,
    409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491,
    499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,
    601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683,
    691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,
    809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,
    907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997)

    wheel = (2, 3, 5)
    const = 30
    if N &lt; 2:
        return []
    if N &lt;= const:
        pos = 0
        while __smallp[pos] &lt;= N:
            pos += 1
        return list(__smallp[:pos])
    # make the offsets list
    offsets = (7, 11, 13, 17, 19, 23, 29, 1)
    # prepare the list
    p = [2, 3, 5]
    dim = 2 + N // const
    tk1  = [True] * dim
    tk7  = [True] * dim
    tk11 = [True] * dim
    tk13 = [True] * dim
    tk17 = [True] * dim
    tk19 = [True] * dim
    tk23 = [True] * dim
    tk29 = [True] * dim
    tk1[0] = False
    # help dictionary d
    # d[a , b] = c  ==&gt; if I want to find the smallest useful multiple of (30*pos)+a
    # on tkc, then I need the index given by the product of [(30*pos)+a][(30*pos)+b]
    # in general. If b &lt; a, I need [(30*pos)+a][(30*(pos+1))+b]
    d = {}
    for x in offsets:
        for y in offsets:
            res = (x*y) % const
            if res in offsets:
                d[(x, res)] = y
    # another help dictionary: gives tkx calling tmptk[x]
    tmptk = {1:tk1, 7:tk7, 11:tk11, 13:tk13, 17:tk17, 19:tk19, 23:tk23, 29:tk29}
    pos, prime, lastadded, stop = 0, 0, 0, int(ceil(sqrt(N)))
    # inner functions definition
    def del_mult(tk, start, step):
        for k in xrange(start, len(tk), step):
            tk[k] = False
    # end of inner functions definition
    cpos = const * pos
    while prime &lt; stop:
        # 30k + 7
        if tk7[pos]:
            prime = cpos + 7
            p.append(prime)
            lastadded = 7
            for off in offsets:
                tmp = d[(7, off)]
                start = (pos + prime) if off == 7 else (prime * (const * (pos + 1 if tmp &lt; 7 else 0) + tmp) )//const
                del_mult(tmptk[off], start, prime)
        # 30k + 11
        if tk11[pos]:
            prime = cpos + 11
            p.append(prime)
            lastadded = 11
            for off in offsets:
                tmp = d[(11, off)]
                start = (pos + prime) if off == 11 else (prime * (const * (pos + 1 if tmp &lt; 11 else 0) + tmp) )//const
                del_mult(tmptk[off], start, prime)
        # 30k + 13
        if tk13[pos]:
            prime = cpos + 13
            p.append(prime)
            lastadded = 13
            for off in offsets:
                tmp = d[(13, off)]
                start = (pos + prime) if off == 13 else (prime * (const * (pos + 1 if tmp &lt; 13 else 0) + tmp) )//const
                del_mult(tmptk[off], start, prime)
        # 30k + 17
        if tk17[pos]:
            prime = cpos + 17
            p.append(prime)
            lastadded = 17
            for off in offsets:
                tmp = d[(17, off)]
                start = (pos + prime) if off == 17 else (prime * (const * (pos + 1 if tmp &lt; 17 else 0) + tmp) )//const
                del_mult(tmptk[off], start, prime)
        # 30k + 19
        if tk19[pos]:
            prime = cpos + 19
            p.append(prime)
            lastadded = 19
            for off in offsets:
                tmp = d[(19, off)]
                start = (pos + prime) if off == 19 else (prime * (const * (pos + 1 if tmp &lt; 19 else 0) + tmp) )//const
                del_mult(tmptk[off], start, prime)
        # 30k + 23
        if tk23[pos]:
            prime = cpos + 23
            p.append(prime)
            lastadded = 23
            for off in offsets:
                tmp = d[(23, off)]
                start = (pos + prime) if off == 23 else (prime * (const * (pos + 1 if tmp &lt; 23 else 0) + tmp) )//const
                del_mult(tmptk[off], start, prime)
        # 30k + 29
        if tk29[pos]:
            prime = cpos + 29
            p.append(prime)
            lastadded = 29
            for off in offsets:
                tmp = d[(29, off)]
                start = (pos + prime) if off == 29 else (prime * (const * (pos + 1 if tmp &lt; 29 else 0) + tmp) )//const
                del_mult(tmptk[off], start, prime)
        # now we go back to top tk1, so we need to increase pos by 1
        pos += 1
        cpos = const * pos
        # 30k + 1
        if tk1[pos]:
            prime = cpos + 1
            p.append(prime)
            lastadded = 1
            for off in offsets:
                tmp = d[(1, off)]
                start = (pos + prime) if off == 1 else (prime * (const * pos + tmp) )//const
                del_mult(tmptk[off], start, prime)
    # time to add remaining primes
    # if lastadded == 1, remove last element and start adding them from tk1
    # this way we don't need an ""if"" within the last while
    if lastadded == 1:
        p.pop()
    # now complete for every other possible prime
    while pos &lt; len(tk1):
        cpos = const * pos
        if tk1[pos]: p.append(cpos + 1)
        if tk7[pos]: p.append(cpos + 7)
        if tk11[pos]: p.append(cpos + 11)
        if tk13[pos]: p.append(cpos + 13)
        if tk17[pos]: p.append(cpos + 17)
        if tk19[pos]: p.append(cpos + 19)
        if tk23[pos]: p.append(cpos + 23)
        if tk29[pos]: p.append(cpos + 29)
        pos += 1
    # remove exceeding if present
    pos = len(p) - 1
    while p[pos] &gt; N:
        pos -= 1
    if pos &lt; len(p) - 1:
        del p[pos+1:]
    # return p list
    return p

def sieveOfEratosthenes(n):
    """"""sieveOfEratosthenes(n): return the list of the primes &lt; n.""""""
    # Code from: &lt;dickinsm@gmail.com&gt;, Nov 30 2006
    # http://groups.google.com/group/comp.lang.python/msg/f1f10ced88c68c2d
    if n &lt;= 2:
        return []
    sieve = range(3, n, 2)
    top = len(sieve)
    for si in sieve:
        if si:
            bottom = (si*si - 3) // 2
            if bottom &gt;= top:
                break
            sieve[bottom::si] = [0] * -((bottom - top) // si)
    return [2] + [el for el in sieve if el]

def sieveOfAtkin(end):
    """"""sieveOfAtkin(end): return a list of all the prime numbers &lt;end
    using the Sieve of Atkin.""""""
    # Code by Steve Krenzel, &lt;Sgk284@gmail.com&gt;, improved
    # Code: https://web.archive.org/web/20080324064651/http://krenzel.info/?p=83
    # Info: http://en.wikipedia.org/wiki/Sieve_of_Atkin
    assert end &gt; 0
    lng = ((end-1) // 2)
    sieve = [False] * (lng + 1)

    x_max, x2, xd = int(sqrt((end-1)/4.0)), 0, 4
    for xd in xrange(4, 8*x_max + 2, 8):
        x2 += xd
        y_max = int(sqrt(end-x2))
        n, n_diff = x2 + y_max*y_max, (y_max &lt;&lt; 1) - 1
        if not (n &amp; 1):
            n -= n_diff
            n_diff -= 2
        for d in xrange((n_diff - 1) &lt;&lt; 1, -1, -8):
            m = n % 12
            if m == 1 or m == 5:
                m = n &gt;&gt; 1
                sieve[m] = not sieve[m]
            n -= d

    x_max, x2, xd = int(sqrt((end-1) / 3.0)), 0, 3
    for xd in xrange(3, 6 * x_max + 2, 6):
        x2 += xd
        y_max = int(sqrt(end-x2))
        n, n_diff = x2 + y_max*y_max, (y_max &lt;&lt; 1) - 1
        if not(n &amp; 1):
            n -= n_diff
            n_diff -= 2
        for d in xrange((n_diff - 1) &lt;&lt; 1, -1, -8):
            if n % 12 == 7:
                m = n &gt;&gt; 1
                sieve[m] = not sieve[m]
            n -= d

    x_max, y_min, x2, xd = int((2 + sqrt(4-8*(1-end)))/4), -1, 0, 3
    for x in xrange(1, x_max + 1):
        x2 += xd
        xd += 6
        if x2 &gt;= end: y_min = (((int(ceil(sqrt(x2 - end))) - 1) &lt;&lt; 1) - 2) &lt;&lt; 1
        n, n_diff = ((x*x + x) &lt;&lt; 1) - 1, (((x-1) &lt;&lt; 1) - 2) &lt;&lt; 1
        for d in xrange(n_diff, y_min, -8):
            if n % 12 == 11:
                m = n &gt;&gt; 1
                sieve[m] = not sieve[m]
            n += d

    primes = [2, 3]
    if end &lt;= 3:
        return primes[:max(0,end-2)]

    for n in xrange(5 &gt;&gt; 1, (int(sqrt(end))+1) &gt;&gt; 1):
        if sieve[n]:
            primes.append((n &lt;&lt; 1) + 1)
            aux = (n &lt;&lt; 1) + 1
            aux *= aux
            for k in xrange(aux, end, 2 * aux):
                sieve[k &gt;&gt; 1] = False

    s  = int(sqrt(end)) + 1
    if s  % 2 == 0:
        s += 1
    primes.extend([i for i in xrange(s, end, 2) if sieve[i &gt;&gt; 1]])

    return primes

def ambi_sieve_plain(n):
    s = range(3, n, 2)
    for m in xrange(3, int(n**0.5)+1, 2): 
        if s[(m-3)/2]: 
            for t in xrange((m*m-3)/2,(n&gt;&gt;1)-1,m):
                s[t]=0
    return [2]+[t for t in s if t&gt;0]

def sundaram3(max_n):
    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/2073279#2073279
    numbers = range(3, max_n+1, 2)
    half = (max_n)//2
    initial = 4

    for step in xrange(3, max_n+1, 2):
        for i in xrange(initial, half, step):
            numbers[i-1] = 0
        initial += 2*(step+1)

        if initial &gt; half:
            return [2] + filter(None, numbers)

################################################################################
# Using Numpy:
def ambi_sieve(n):
    # http://tommih.blogspot.com/2009/04/fast-prime-number-generator.html
    s = np.arange(3, n, 2)
    for m in xrange(3, int(n ** 0.5)+1, 2): 
        if s[(m-3)/2]: 
            s[(m*m-3)/2::m]=0
    return np.r_[2, s[s&gt;0]]

def primesfrom3to(n):
    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188
    """""" Returns a array of primes, p &lt; n """"""
    assert n&gt;=2
    sieve = np.ones(n/2, dtype=np.bool)
    for i in xrange(3,int(n**0.5)+1,2):
        if sieve[i/2]:
            sieve[i*i/2::i] = False
    return np.r_[2, 2*np.nonzero(sieve)[0][1::]+1]    

def primesfrom2to(n):
    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188
    """""" Input n&gt;=6, Returns a array of primes, 2 &lt;= p &lt; n """"""
    sieve = np.ones(n/3 + (n%6==2), dtype=np.bool)
    sieve[0] = False
    for i in xrange(int(n**0.5)/3+1):
        if sieve[i]:
            k=3*i+1|1
            sieve[      ((k*k)/3)      ::2*k] = False
            sieve[(k*k+4*k-2*k*(i&amp;1))/3::2*k] = False
    return np.r_[2,3,((3*np.nonzero(sieve)[0]+1)|1)]

if __name__=='__main__':
    import itertools
    import sys

    def test(f1,f2,num):
        print('Testing {f1} and {f2} return same results'.format(
            f1=f1.func_name,
            f2=f2.func_name))
        if not all([a==b for a,b in itertools.izip_longest(f1(num),f2(num))]):
            sys.exit(""Error: %s(%s) != %s(%s)""%(f1.func_name,num,f2.func_name,num))

    n=1000000
    test(sieveOfAtkin,sieveOfEratosthenes,n)
    test(sieveOfAtkin,ambi_sieve,n)
    test(sieveOfAtkin,ambi_sieve_plain,n) 
    test(sieveOfAtkin,sundaram3,n)
    test(sieveOfAtkin,sieve_wheel_30,n)
    test(sieveOfAtkin,primesfrom3to,n)
    test(sieveOfAtkin,primesfrom2to,n)
    test(sieveOfAtkin,rwh_primes,n)
    test(sieveOfAtkin,rwh_primes1,n)         
    test(sieveOfAtkin,rwh_primes2,n)
</code></pre>

<p>Running the script tests that all implementations give the same result.</p>
"
988251,"<p>You can use the built-in <a href=""https://docs.python.org/library/ast.html#ast.literal_eval"" rel=""noreferrer""><code>ast.literal_eval</code></a>:</p>
<pre><code>&gt;&gt;&gt; import ast
&gt;&gt;&gt; ast.literal_eval(&quot;{'muffin' : 'lolz', 'foo' : 'kitty'}&quot;)
{'muffin': 'lolz', 'foo': 'kitty'}
</code></pre>
<p>This is safer than using <code>eval</code>.  As its own docs say:</p>
<pre>
>>> help(ast.literal_eval)
Help on function literal_eval in module ast:

literal_eval(node_or_string)
    Safely evaluate an expression node or a string containing a Python
    expression.  The string or node provided may only consist of the following
    Python literal structures: strings, numbers, tuples, lists, dicts, booleans,
    and None.
</pre>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; eval(&quot;shutil.rmtree('mongo')&quot;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;/opt/Python-2.6.1/lib/python2.6/shutil.py&quot;, line 208, in rmtree
    onerror(os.listdir, path, sys.exc_info())
  File &quot;/opt/Python-2.6.1/lib/python2.6/shutil.py&quot;, line 206, in rmtree
    names = os.listdir(path)
OSError: [Errno 2] No such file or directory: 'mongo'
&gt;&gt;&gt; ast.literal_eval(&quot;shutil.rmtree('mongo')&quot;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;/opt/Python-2.6.1/lib/python2.6/ast.py&quot;, line 68, in literal_eval
    return _convert(node_or_string)
  File &quot;/opt/Python-2.6.1/lib/python2.6/ast.py&quot;, line 67, in _convert
    raise ValueError('malformed string')
ValueError: malformed string
</code></pre>
"
,
2612615,"<p>There are built-in functions called <a href=""https://docs.python.org/3/library/functions.html#getattr"" rel=""noreferrer""><code>getattr</code></a> and <a href=""https://docs.python.org/3/library/functions.html#setattr"" rel=""noreferrer""><code>setattr</code></a></p>

<pre><code>getattr(object, attrname)
setattr(object, attrname, value)
</code></pre>

<p>In this case </p>

<pre><code>x = getattr(t, 'attr1')
setattr(t, 'attr1', 21)
</code></pre>
"
31728991,"<p>There are several ways to do it. The <code>subplots</code> method creates the figure along with the subplots that are then stored in the <code>ax</code> array. For example:</p>

<pre><code>import matplotlib.pyplot as plt

x = range(10)
y = range(10)

fig, ax = plt.subplots(nrows=2, ncols=2)

for row in ax:
    for col in row:
        col.plot(x, y)

plt.show()
</code></pre>

<p><a href=""https://i.stack.imgur.com/2JxAs.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/2JxAs.png"" alt=""enter image description here""></a></p>

<p>However, something like this will also work, it's not so ""clean"" though since you are creating a figure with subplots and then add on top of them:</p>

<pre><code>fig = plt.figure()

plt.subplot(2, 2, 1)
plt.plot(x, y)

plt.subplot(2, 2, 2)
plt.plot(x, y)

plt.subplot(2, 2, 3)
plt.plot(x, y)

plt.subplot(2, 2, 4)
plt.plot(x, y)

plt.show()
</code></pre>

<p><a href=""https://i.stack.imgur.com/0EiUD.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/0EiUD.png"" alt=""enter image description here""></a></p>
"
,
5753614,"<p>It is very anti-Pythonic to do so, and any seasoned Pythonista will give you hell over it. The intermediate list is thrown away after it is created, and it could potentially be very, very large, and therefore expensive to create.</p>
"
1912483,"<p>I suggest <a href=""http://docs.python.org/library/xml.etree.elementtree.html"" rel=""noreferrer""><code>ElementTree</code></a>.  There are other compatible implementations of the same API, such as <a href=""https://lxml.de/parsing.html"" rel=""noreferrer""><code>lxml</code></a>, and <code>cElementTree</code> in the Python standard library itself; but, in this context, what they chiefly add is even more speed -- the ease of programming part depends on the API, which <code>ElementTree</code> defines.</p>
<p>First build an Element instance <code>root</code> from the XML, e.g. with the <a href=""http://docs.python.org/library/xml.etree.elementtree.html#xml.etree.ElementTree.XML"" rel=""noreferrer"">XML</a> function, or by parsing a file with something like:</p>
<pre class=""lang-py prettyprint-override""><code>import xml.etree.ElementTree as ET
root = ET.parse('thefile.xml').getroot()
</code></pre>
<p>Or any of the many other ways shown at <a href=""http://docs.python.org/library/xml.etree.elementtree.html"" rel=""noreferrer""><code>ElementTree</code></a>. Then do something like:</p>
<pre class=""lang-py prettyprint-override""><code>for type_tag in root.findall('bar/type'):
    value = type_tag.get('foobar')
    print(value)
</code></pre>
<p>Output:</p>
<pre><code>1
2
</code></pre>
"
13913933,"<p><em>Class scope and list, set or dictionary comprehensions, as well as generator expressions do not mix.</em></p>
<h2>The why; or, the official word on this</h2>
<p>In Python 3, list comprehensions were given a proper scope (local namespace) of their own, to prevent their local variables bleeding over into the surrounding scope (see <a href=""https://stackoverflow.com/q/4198906"">List comprehension rebinds names even after scope of comprehension. Is this right?</a>). That's great when using such a list comprehension in a module or in a function, but in classes, scoping is a little, uhm, <em>strange</em>.</p>
<p>This is documented in <a href=""http://www.python.org/dev/peps/pep-0227/"" rel=""noreferrer"">pep 227</a>:</p>
<blockquote>
<p>Names in class scope are not accessible.  Names are resolved in
the innermost enclosing function scope.  If a class definition
occurs in a chain of nested scopes, the resolution process skips
class definitions.</p>
</blockquote>
<p>and in the <a href=""http://docs.python.org/3/reference/compound_stmts.html#class-definitions"" rel=""noreferrer""><code>class</code> compound statement documentation</a>:</p>
<blockquote>
<p>The classâs suite is then executed in a new execution frame (see section <a href=""http://docs.python.org/3/reference/executionmodel.html#naming"" rel=""noreferrer""><em>Naming and binding</em></a>), using a newly created local namespace and the original global namespace. (Usually, the suite contains only function definitions.) When the classâs suite finishes execution, <strong>its execution frame is discarded but its local namespace is saved</strong>. <a href=""http://docs.python.org/3/reference/compound_stmts.html#id8"" rel=""noreferrer"">[4]</a> A class object is then created using the inheritance list for the base classes and the saved local namespace for the attribute dictionary.</p>
</blockquote>
<p>Emphasis mine; the execution frame is the temporary scope.</p>
<p>Because the scope is repurposed as the attributes on a class object, allowing it to be used as a nonlocal scope as well leads to undefined behaviour; what would happen if a class method referred to <code>x</code> as a nested scope variable, then manipulates <code>Foo.x</code> as well, for example? More importantly, what would that mean for subclasses of <code>Foo</code>? Python <em>has</em> to treat a class scope differently as it is very different from a function scope.</p>
<p>Last, but definitely not least, the linked <a href=""http://docs.python.org/3/reference/executionmodel.html#naming"" rel=""noreferrer"">Naming and binding</a> section in the Execution model documentation mentions class scopes explicitly:</p>
<blockquote>
<p>The scope of names defined in a class block is limited to the class block; it does not extend to the code blocks of methods â this includes comprehensions and generator expressions since they are implemented using a function scope. This means that the following will fail:</p>
<pre><code>class A:
     a = 42
     b = list(a + i for i in range(10))
</code></pre>
</blockquote>
<p>So, to summarize: you cannot access the class scope from functions, list comprehensions or generator expressions enclosed in that scope; they act as if that scope does not exist. In Python 2, list comprehensions were implemented using a shortcut, but in Python 3 they got their own function scope (as they should have had all along) and thus your example breaks. Other comprehension types have their own scope regardless of Python version, so a similar example with a set or dict comprehension would break in Python 2.</p>
<pre><code># Same error, in Python 2 or 3
y = {x: x for i in range(1)}
</code></pre>
<h2>The (small) exception; or, why one part <em>may</em> still work</h2>
<p>There's one part of a comprehension or generator expression that executes in the surrounding scope, regardless of Python version. That would be the expression for the outermost iterable. In your example, it's the <code>range(1)</code>:</p>
<pre><code>y = [x for i in range(1)]
#               ^^^^^^^^
</code></pre>
<p>Thus, using <code>x</code> in that expression would not throw an error:</p>
<pre><code># Runs fine
y = [i for i in range(x)]
</code></pre>
<p>This only applies to the outermost iterable; if a comprehension has multiple <code>for</code> clauses, the iterables for inner <code>for</code> clauses are evaluated in the comprehension's scope:</p>
<pre><code># NameError
y = [i for i in range(1) for j in range(x)]
#      ^^^^^^^^^^^^^^^^^ -----------------
#      outer loop        inner, nested loop
</code></pre>
<p>This design decision was made in order to throw an error at genexp creation time instead of iteration time when creating the outermost iterable of a generator expression throws an error, or when the outermost iterable turns out not to be iterable. Comprehensions share this behavior for consistency.</p>
<h2>Looking under the hood; or, way more detail than you ever wanted</h2>
<p>You can see this all in action using the <a href=""http://docs.python.org/3/library/dis.html"" rel=""noreferrer""><code>dis</code> module</a>. I'm using Python 3.3 in the following examples, because it adds <a href=""http://docs.python.org/3/whatsnew/3.3.html#pep-3155-qualified-name-for-classes-and-functions"" rel=""noreferrer"">qualified names</a> that neatly identify the code objects we want to inspect. The bytecode produced is otherwise functionally identical to Python 3.2.</p>
<p>To <em>create</em> a class, Python essentially takes the whole suite that makes up the class body (so everything indented one level deeper than the <code>class &lt;name&gt;:</code> line), and executes that as if it were a function:</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; def foo():
...     class Foo:
...         x = 5
...         y = [x for i in range(1)]
...     return Foo
... 
&gt;&gt;&gt; dis.dis(foo)
  2           0 LOAD_BUILD_CLASS     
              1 LOAD_CONST               1 (&lt;code object Foo at 0x10a436030, file &quot;&lt;stdin&gt;&quot;, line 2&gt;) 
              4 LOAD_CONST               2 ('Foo') 
              7 MAKE_FUNCTION            0 
             10 LOAD_CONST               2 ('Foo') 
             13 CALL_FUNCTION            2 (2 positional, 0 keyword pair) 
             16 STORE_FAST               0 (Foo) 

  5          19 LOAD_FAST                0 (Foo) 
             22 RETURN_VALUE         
</code></pre>
<p>The first <code>LOAD_CONST</code> there loads a code object for the <code>Foo</code> class body, then makes that into a function, and calls it. The <em>result</em> of that call is then used to create the namespace of the class, its <code>__dict__</code>. So far so good.</p>
<p>The thing to note here is that the bytecode contains a nested code object; in Python, class definitions, functions, comprehensions and generators all are represented as code objects that contain not only bytecode, but also structures that represent local variables, constants, variables taken from globals, and variables taken from the nested scope. The compiled bytecode refers to those structures and the python interpreter knows how to access those given the bytecodes presented.</p>
<p>The important thing to remember here is that Python creates these structures at compile time; the <code>class</code> suite is a code object (<code>&lt;code object Foo at 0x10a436030, file &quot;&lt;stdin&gt;&quot;, line 2&gt;</code>) that is already compiled.</p>
<p>Let's inspect that code object that creates the class body itself; code objects have a <code>co_consts</code> structure:</p>
<pre><code>&gt;&gt;&gt; foo.__code__.co_consts
(None, &lt;code object Foo at 0x10a436030, file &quot;&lt;stdin&gt;&quot;, line 2&gt;, 'Foo')
&gt;&gt;&gt; dis.dis(foo.__code__.co_consts[1])
  2           0 LOAD_FAST                0 (__locals__) 
              3 STORE_LOCALS         
              4 LOAD_NAME                0 (__name__) 
              7 STORE_NAME               1 (__module__) 
             10 LOAD_CONST               0 ('foo.&lt;locals&gt;.Foo') 
             13 STORE_NAME               2 (__qualname__) 

  3          16 LOAD_CONST               1 (5) 
             19 STORE_NAME               3 (x) 

  4          22 LOAD_CONST               2 (&lt;code object &lt;listcomp&gt; at 0x10a385420, file &quot;&lt;stdin&gt;&quot;, line 4&gt;) 
             25 LOAD_CONST               3 ('foo.&lt;locals&gt;.Foo.&lt;listcomp&gt;') 
             28 MAKE_FUNCTION            0 
             31 LOAD_NAME                4 (range) 
             34 LOAD_CONST               4 (1) 
             37 CALL_FUNCTION            1 (1 positional, 0 keyword pair) 
             40 GET_ITER             
             41 CALL_FUNCTION            1 (1 positional, 0 keyword pair) 
             44 STORE_NAME               5 (y) 
             47 LOAD_CONST               5 (None) 
             50 RETURN_VALUE         
</code></pre>
<p>The above bytecode creates the class body. The function is executed and the resulting <code>locals()</code> namespace, containing <code>x</code> and <code>y</code> is used to create the class (except that it doesn't work because <code>x</code> isn't defined as a global). Note that after storing <code>5</code> in <code>x</code>, it loads another code object; that's the list comprehension; it is wrapped in a function object just like the class body was; the created function takes a positional argument, the <code>range(1)</code> iterable to use for its looping code, cast to an iterator. As shown in the bytecode, <code>range(1)</code> is evaluated in the class scope.</p>
<p>From this you can see that the only difference between a code object for a function or a generator, and a code object for a comprehension is that the latter is executed <em>immediately</em> when the parent code object is executed; the bytecode simply creates a function on the fly and executes it in a few small steps.</p>
<p>Python 2.x uses inline bytecode there instead, here is output from Python 2.7:</p>
<pre><code>  2           0 LOAD_NAME                0 (__name__)
              3 STORE_NAME               1 (__module__)

  3           6 LOAD_CONST               0 (5)
              9 STORE_NAME               2 (x)

  4          12 BUILD_LIST               0
             15 LOAD_NAME                3 (range)
             18 LOAD_CONST               1 (1)
             21 CALL_FUNCTION            1
             24 GET_ITER            
        &gt;&gt;   25 FOR_ITER                12 (to 40)
             28 STORE_NAME               4 (i)
             31 LOAD_NAME                2 (x)
             34 LIST_APPEND              2
             37 JUMP_ABSOLUTE           25
        &gt;&gt;   40 STORE_NAME               5 (y)
             43 LOAD_LOCALS         
             44 RETURN_VALUE        
</code></pre>
<p>No code object is loaded, instead a <code>FOR_ITER</code> loop is run inline. So in Python 3.x, the list generator was given a proper code object of its own, which means it has its own scope.</p>
<p>However, the comprehension was compiled together with the rest of the python source code when the module or script was first loaded by the interpreter, and the compiler does <em>not</em> consider a class suite a valid scope. Any referenced variables in a list comprehension must look in the scope <em>surrounding</em> the class definition, recursively. If the variable wasn't found by the compiler, it marks it as a global. Disassembly of the list comprehension code object shows that <code>x</code> is indeed loaded as a global:</p>
<pre><code>&gt;&gt;&gt; foo.__code__.co_consts[1].co_consts
('foo.&lt;locals&gt;.Foo', 5, &lt;code object &lt;listcomp&gt; at 0x10a385420, file &quot;&lt;stdin&gt;&quot;, line 4&gt;, 'foo.&lt;locals&gt;.Foo.&lt;listcomp&gt;', 1, None)
&gt;&gt;&gt; dis.dis(foo.__code__.co_consts[1].co_consts[2])
  4           0 BUILD_LIST               0 
              3 LOAD_FAST                0 (.0) 
        &gt;&gt;    6 FOR_ITER                12 (to 21) 
              9 STORE_FAST               1 (i) 
             12 LOAD_GLOBAL              0 (x) 
             15 LIST_APPEND              2 
             18 JUMP_ABSOLUTE            6 
        &gt;&gt;   21 RETURN_VALUE         
</code></pre>
<p>This chunk of bytecode loads the first argument passed in (the <code>range(1)</code> iterator), and just like the Python 2.x version uses <code>FOR_ITER</code> to loop over it and create its output.</p>
<p>Had we defined <code>x</code> in the <code>foo</code> function instead, <code>x</code> would be a cell variable (cells refer to nested scopes):</p>
<pre><code>&gt;&gt;&gt; def foo():
...     x = 2
...     class Foo:
...         x = 5
...         y = [x for i in range(1)]
...     return Foo
... 
&gt;&gt;&gt; dis.dis(foo.__code__.co_consts[2].co_consts[2])
  5           0 BUILD_LIST               0 
              3 LOAD_FAST                0 (.0) 
        &gt;&gt;    6 FOR_ITER                12 (to 21) 
              9 STORE_FAST               1 (i) 
             12 LOAD_DEREF               0 (x) 
             15 LIST_APPEND              2 
             18 JUMP_ABSOLUTE            6 
        &gt;&gt;   21 RETURN_VALUE         
</code></pre>
<p>The <code>LOAD_DEREF</code> will indirectly load <code>x</code> from the code object cell objects:</p>
<pre><code>&gt;&gt;&gt; foo.__code__.co_cellvars               # foo function `x`
('x',)
&gt;&gt;&gt; foo.__code__.co_consts[2].co_cellvars  # Foo class, no cell variables
()
&gt;&gt;&gt; foo.__code__.co_consts[2].co_consts[2].co_freevars  # Refers to `x` in foo
('x',)
&gt;&gt;&gt; foo().y
[2]
</code></pre>
<p>The actual referencing looks the value up from the current frame data structures, which were initialized from a function object's <code>.__closure__</code> attribute. Since the function created for the comprehension code object is discarded again, we do not get to inspect that function's closure. To see a closure in action, we'd have to inspect a nested function instead:</p>
<pre><code>&gt;&gt;&gt; def spam(x):
...     def eggs():
...         return x
...     return eggs
... 
&gt;&gt;&gt; spam(1).__code__.co_freevars
('x',)
&gt;&gt;&gt; spam(1)()
1
&gt;&gt;&gt; spam(1).__closure__
&gt;&gt;&gt; spam(1).__closure__[0].cell_contents
1
&gt;&gt;&gt; spam(5).__closure__[0].cell_contents
5
</code></pre>
<p>So, to summarize:</p>
<ul>
<li>List comprehensions get their own code objects in Python 3, and there is no difference between code objects for functions, generators or comprehensions; comprehension code objects are wrapped in a temporary function object and called immediately.</li>
<li>Code objects are created at compile time, and any non-local variables are marked as either global or as free variables, based on the nested scopes of the code. The class body is <em>not</em> considered a scope for looking up those variables.</li>
<li>When executing the code, Python has only to look into the globals, or the closure of the currently executing object. Since the compiler didn't include the class body as a scope, the temporary function namespace is not considered.</li>
</ul>
<h2>A workaround; or, what to do about it</h2>
<p>If you were to create an explicit scope for the <code>x</code> variable, like in a function, you <em>can</em> use class-scope variables for a list comprehension:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     x = 5
...     def y(x):
...         return [x for i in range(1)]
...     y = y(x)
... 
&gt;&gt;&gt; Foo.y
[5]
</code></pre>
<p>The 'temporary' <code>y</code> function can be called directly; we replace it when we do with its return value. Its scope <em>is</em> considered when resolving <code>x</code>:</p>
<pre><code>&gt;&gt;&gt; foo.__code__.co_consts[1].co_consts[2]
&lt;code object y at 0x10a5df5d0, file &quot;&lt;stdin&gt;&quot;, line 4&gt;
&gt;&gt;&gt; foo.__code__.co_consts[1].co_consts[2].co_cellvars
('x',)
</code></pre>
<p>Of course, people reading your code will scratch their heads over this a little; you may want to put a big fat comment in there explaining why you are doing this.</p>
<p>The best work-around is to just use <code>__init__</code> to create an instance variable instead:</p>
<pre><code>def __init__(self):
    self.y = [self.x for i in range(1)]
</code></pre>
<p>and avoid all the head-scratching, and questions to explain yourself. For your own concrete example, I would not even store the <code>namedtuple</code> on the class; either use the output directly (don't store the generated class at all), or use a global:</p>
<pre><code>from collections import namedtuple
State = namedtuple('State', ['name', 'capital'])

class StateDatabase:
    db = [State(*args) for args in [
       ('Alabama', 'Montgomery'),
       ('Alaska', 'Juneau'),
       # ...
    ]]
</code></pre>
"
58178276,"<p>The resource (image, font, sound, etc.) file path has to be relative to the current working directory. The working directory is possibly different from the directory of the python file.<br />
It is not enough to put the files in the same directory or sub directory. You also need to set the working directory. Alternatively, you can create an absolute file path.</p>
<hr />
<p>The name and path of the file can be get by <a href=""https://docs.python.org/3/reference/import.html#import-related-module-attributes"" rel=""nofollow noreferrer""><code>__file__</code></a>. The current working directory can be get by <a href=""https://docs.python.org/3/library/os.html"" rel=""nofollow noreferrer""><code>os.getcwd()</code></a> and can be changed by <a href=""https://docs.python.org/3/library/os.html"" rel=""nofollow noreferrer""><code>os.chdir(path)</code></a>:</p>
<pre class=""lang-py prettyprint-override""><code>import os

os.chdir(os.path.dirname(os.path.abspath(__file__)))
</code></pre>
<p>An alternative solution is to find the absolute path.
If the file is in an subfolder of the python file (or even in the same folder), then you can get the directory of the file and join (<a href=""https://docs.python.org/3/library/os.path.html"" rel=""nofollow noreferrer""><code>os.path.join()</code></a>) the relative filepath. e.g.:</p>
<pre class=""lang-py prettyprint-override""><code>import pygame
import os

# get the directory of this file
sourceFileDir = os.path.dirname(os.path.abspath(__file__))

# [...]

# join the filepath and the filename
filePath = os.path.join(sourceFileDir, 'test_bg.jpg')
# filePath = os.path.join(sourceFileDir, '_pycache_/test_bg.jpg')

surface = pygame.image.load(filePath)
</code></pre>
<hr />
<p>The same can be achieved with the <a href=""https://docs.python.org/3/library/pathlib.html"" rel=""nofollow noreferrer""><code>pathlib</code></a> module.
Change the working directory</p>
<pre class=""lang-py prettyprint-override""><code>import os, pathlib

os.chdir(pathlib.Path(__file__).resolve().parent)
</code></pre>
<p>or create an absolute filepath:</p>
<pre class=""lang-py prettyprint-override""><code>import pathlib

# [...]

filePath = pathlib.Path(__file__).resolve().parent / 'test_bg.jpg'
surface = pygame.image.load(filePath)
</code></pre>
"
9942822,"<p>Read the Python <a href=""https://docs.python.org/2.7/howto/unicode.html"" rel=""noreferrer"">Unicode HOWTO</a>. This error is the <a href=""https://docs.python.org/2.7/howto/unicode.html#the-unicode-type"" rel=""noreferrer"">very first example</a>.</p>
<p>Do not use <code>str()</code> to convert from unicode to encoded text / bytes.</p>
<p>Instead, use <a href=""http://docs.python.org/library/stdtypes.html#str.encode"" rel=""noreferrer""><code>.encode()</code></a> to encode the string:</p>
<pre><code>p.agent_info = u' '.join((agent_contact, agent_telno)).encode('utf-8').strip()
</code></pre>
<p>or work entirely in unicode.</p>
"
,
23709194,"<p><strong>You need to add the path of your pip installation to your PATH system variable</strong>. By default, pip is installed to <code>C:\Python34\Scripts\pip</code> (pip now comes bundled with new versions of python), so the path ""C:\Python34\Scripts"" needs to be added to your PATH variable.</p>

<p>To check if it is already in your PATH variable, type <code>echo %PATH%</code> at the CMD prompt</p>

<p><strong>To add the path of your pip installation to your PATH variable</strong>, you can use the Control Panel or the <code>setx</code> command. For example:</p>

<pre><code>setx PATH ""%PATH%;C:\Python34\Scripts""
</code></pre>

<hr>

<p><strong>Note</strong>:
According to the <a href=""https://technet.microsoft.com/en-us/library/cc755104%28v=ws.11%29.aspx"">official documentation</a>, ""[v]ariables set with setx variables are available in future command windows only, not in the current command window"". In particular, <em>you will need to start a new cmd.exe instance</em> after entering the above command in order to utilize the new environment variable. </p>

<p>Thanks to Scott Bartell for pointing this out.</p>
"
152596,"<p>Use <a href=""https://docs.python.org/library/functions.html#isinstance"" rel=""noreferrer""><code>isinstance</code></a> to check if <code>o</code> is an instance of <code>str</code> or any subclass of <code>str</code>:</p>
<pre><code>if isinstance(o, str):
</code></pre>
<p>To check if the type of <code>o</code> is exactly <code>str</code>, <em>excluding subclasses of <code>str</code></em>:</p>
<pre><code>if type(o) is str:
</code></pre>
<p>See <a href=""http://docs.python.org/library/functions.html"" rel=""noreferrer"">Built-in Functions</a> in the Python Library Reference for relevant information.</p>
<hr />
<h4>Checking for strings in Python 2</h4>
<p>For Python 2, this is a better way to check if <code>o</code> is a string:</p>
<pre><code>if isinstance(o, basestring):
</code></pre>
<p>because this will also catch Unicode strings. <a href=""https://docs.python.org/2/library/functions.html#unicode"" rel=""noreferrer""><code>unicode</code></a> is not a subclass of <code>str</code>; both <code>str</code> and <code>unicode</code> are subclasses of <a href=""https://docs.python.org/2/library/functions.html#basestring"" rel=""noreferrer""><code>basestring</code></a>. In Python 3, <code>basestring</code> no longer exists since there's <a href=""https://docs.python.org/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit"" rel=""noreferrer"">a strict separation</a> of strings (<a href=""https://docs.python.org/3/library/functions.html#func-str"" rel=""noreferrer""><code>str</code></a>) and binary data (<a href=""https://docs.python.org/3/library/functions.html#func-bytes"" rel=""noreferrer""><code>bytes</code></a>).</p>
<p>Alternatively, <code>isinstance</code> accepts a tuple of classes. This will return <code>True</code> if <code>o</code> is an instance of any subclass of any of <code>(str, unicode)</code>:</p>
<pre><code>if isinstance(o, (str, unicode)):
</code></pre>
"
3092341,"<h2>Overview</h2>
<p>You can only associate scrollbars with a few widgets, and the root widget and <code>Frame</code> aren't part of that group of widgets.</p>
<p>There are at least a couple of ways to do this. If you need a simple vertical or horizontal group of widgets, you can use a text widget and the <code>window_create</code> method to add widgets. This method is simple, but doesn't allow for a complex layout of the widgets.</p>
<p>A more common general-purpose solution is to create a canvas widget and associate the scrollbars with that widget. Then, into that canvas embed the frame that contains your label widgets. Determine the width/height of the frame and feed that into the canvas <code>scrollregion</code> option so that the scrollregion exactly matches the size of the frame.</p>
<p>Why put the widgets in a frame rather than directly in the canvas? A scrollbar attached to a canvas can only scroll items created with one of the <code>create_</code> methods. You cannot scroll items added to a canvas with <code>pack</code>, <code>place</code>, or <code>grid</code>. By using a frame, you can use those methods inside the frame, and then call <code>create_window</code> once for the frame.</p>
<p>Drawing the text items directly on the canvas isn't very hard, so you might want to reconsider that approach if the frame-embedded-in-a-canvas solution seems too complex. Since you're creating a grid, the coordinates of each text item is going to be very easy to compute, especially if each row is the same height (which it probably is if you're using a single font).</p>
<p>For drawing directly on the canvas, just figure out the line height of the font you're using (and there are commands for that). Then, each y coordinate is <code>row*(lineheight+spacing)</code>. The x coordinate will be a fixed number based on the widest item in each column. If you give everything a tag for the column it is in, you can adjust the x coordinate and width of all items in a column with a single command.</p>
<h2>Object-oriented solution</h2>
<p>Here's an example of the frame-embedded-in-canvas solution, using an object-oriented approach:</p>
<pre><code>import tkinter as tk

class Example(tk.Frame):
    def __init__(self, parent):

        tk.Frame.__init__(self, parent)
        self.canvas = tk.Canvas(self, borderwidth=0, background=&quot;#ffffff&quot;)
        self.frame = tk.Frame(self.canvas, background=&quot;#ffffff&quot;)
        self.vsb = tk.Scrollbar(self, orient=&quot;vertical&quot;, command=self.canvas.yview)
        self.canvas.configure(yscrollcommand=self.vsb.set)

        self.vsb.pack(side=&quot;right&quot;, fill=&quot;y&quot;)
        self.canvas.pack(side=&quot;left&quot;, fill=&quot;both&quot;, expand=True)
        self.canvas.create_window((4,4), window=self.frame, anchor=&quot;nw&quot;,
                                  tags=&quot;self.frame&quot;)

        self.frame.bind(&quot;&lt;Configure&gt;&quot;, self.onFrameConfigure)

        self.populate()

    def populate(self):
        '''Put in some fake data'''
        for row in range(100):
            tk.Label(self.frame, text=&quot;%s&quot; % row, width=3, borderwidth=&quot;1&quot;,
                     relief=&quot;solid&quot;).grid(row=row, column=0)
            t=&quot;this is the second column for row %s&quot; %row
            tk.Label(self.frame, text=t).grid(row=row, column=1)

    def onFrameConfigure(self, event):
        '''Reset the scroll region to encompass the inner frame'''
        self.canvas.configure(scrollregion=self.canvas.bbox(&quot;all&quot;))

if __name__ == &quot;__main__&quot;:
    root=tk.Tk()
    example = Example(root)
    example.pack(side=&quot;top&quot;, fill=&quot;both&quot;, expand=True)
    root.mainloop()
</code></pre>
<h2>Procedural solution</h2>
<p>Here is a solution that doesn't use a class:</p>
<pre><code>import tkinter as tk

def populate(frame):
    '''Put in some fake data'''
    for row in range(100):
        tk.Label(frame, text=&quot;%s&quot; % row, width=3, borderwidth=&quot;1&quot;, 
                 relief=&quot;solid&quot;).grid(row=row, column=0)
        t=&quot;this is the second column for row %s&quot; %row
        tk.Label(frame, text=t).grid(row=row, column=1)

def onFrameConfigure(canvas):
    '''Reset the scroll region to encompass the inner frame'''
    canvas.configure(scrollregion=canvas.bbox(&quot;all&quot;))

root = tk.Tk()
canvas = tk.Canvas(root, borderwidth=0, background=&quot;#ffffff&quot;)
frame = tk.Frame(canvas, background=&quot;#ffffff&quot;)
vsb = tk.Scrollbar(root, orient=&quot;vertical&quot;, command=canvas.yview)
canvas.configure(yscrollcommand=vsb.set)

vsb.pack(side=&quot;right&quot;, fill=&quot;y&quot;)
canvas.pack(side=&quot;left&quot;, fill=&quot;both&quot;, expand=True)
canvas.create_window((4,4), window=frame, anchor=&quot;nw&quot;)

frame.bind(&quot;&lt;Configure&gt;&quot;, lambda event, canvas=canvas: onFrameConfigure(canvas))

populate(frame)

root.mainloop()
</code></pre>
"
1267892,"<p>In Python 2, division of two ints produces an int. In Python 3, it produces a float. We can get the new behaviour by importing from <code>__future__</code>.</p>

<pre><code>&gt;&gt;&gt; from __future__ import division
&gt;&gt;&gt; a = 4
&gt;&gt;&gt; b = 6
&gt;&gt;&gt; c = a / b
&gt;&gt;&gt; c
0.66666666666666663
</code></pre>
"
6473724,"<p>Python 3:</p>
<pre class=""lang-py prettyprint-override""><code># short circuits at shortest nested list if table is jagged:
list(map(list, zip(*l)))

# discards no data if jagged and fills short nested lists with None
list(map(list, itertools.zip_longest(*l, fillvalue=None)))
</code></pre>
<p>Python 2:</p>
<pre class=""lang-py prettyprint-override""><code>map(list, zip(*l))
</code></pre>
<pre><code>[[1, 4, 7], [2, 5, 8], [3, 6, 9]]
</code></pre>
<p>Explanation:</p>
<p>There are two things we need to know to understand what's going on:</p>
<ol>
<li>The signature of <a href=""https://docs.python.org/library/functions.html#zip"" rel=""noreferrer"">zip</a>: <code>zip(*iterables)</code> This means <code>zip</code> expects an arbitrary number of arguments each of which must be iterable. E.g. <code>zip([1, 2], [3, 4], [5, 6])</code>.</li>
<li><a href=""https://docs.python.org/tutorial/controlflow.html#unpacking-argument-lists"" rel=""noreferrer"">Unpacked argument lists</a>: Given a sequence of arguments <code>args</code>, <code>f(*args)</code> will call <code>f</code> such that each element in <code>args</code> is a separate positional argument of <code>f</code>.</li>
<li><code>itertools.zip_longest</code> does not discard any data if the number of elements of the nested lists are not the same (homogenous), and instead fills in the shorter nested lists <em>then</em> zips them up.</li>
</ol>
<p>Coming back to the input from the question <code>l = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</code>, <code>zip(*l)</code> would be equivalent to <code>zip([1, 2, 3], [4, 5, 6], [7, 8, 9])</code>. The rest is just making sure the result is a list of lists instead of a list of tuples.</p>
"
3277407,"<p>This is detailed with a reasonable amount of detail by Guido himself in his blog post <a href=""http://python-history.blogspot.com/2010/06/method-resolution-order.html"" rel=""noreferrer"">Method Resolution Order</a> (including two earlier attempts).</p>
<p>In your example, <code>Third()</code> will call <code>First.__init__</code>. Python looks for each attribute in the class's parents as they are listed left to right. In this case, we are looking for <code>__init__</code>. So, if you define</p>
<pre><code>class Third(First, Second):
    ...
</code></pre>
<p>Python will start by looking at <code>First</code>, and, if <code>First</code> doesn't have the attribute, then it will look at <code>Second</code>.</p>
<p>This situation becomes more complex when inheritance starts crossing paths (for example if <code>First</code> inherited from <code>Second</code>). Read the link above for more details, but, in a nutshell, Python will try to maintain the order in which each class appears on the inheritance list, starting with the child class itself.</p>
<p>So, for instance, if you had:</p>
<pre><code>class First(object):
    def __init__(self):
        print &quot;first&quot;

class Second(First):
    def __init__(self):
        print &quot;second&quot;

class Third(First):
    def __init__(self):
        print &quot;third&quot;

class Fourth(Second, Third):
    def __init__(self):
        super(Fourth, self).__init__()
        print &quot;that's it&quot;
</code></pre>
<p>the MRO would be <code>[Fourth, Second, Third, First].</code></p>
<p>By the way: if Python cannot find a coherent method resolution order, it'll raise an exception, instead of falling back to behavior which might surprise the user.</p>
<p>Example of an ambiguous MRO:</p>
<pre><code>class First(object):
    def __init__(self):
        print &quot;first&quot;
        
class Second(First):
    def __init__(self):
        print &quot;second&quot;

class Third(First, Second):
    def __init__(self):
        print &quot;third&quot;
</code></pre>
<p>Should <code>Third</code>'s MRO be <code>[First, Second]</code> or <code>[Second, First]</code>? There's no obvious expectation, and Python will raise an error:</p>
<pre><code>TypeError: Error when calling the metaclass bases
    Cannot create a consistent method resolution order (MRO) for bases Second, First
</code></pre>
<p>Why do the examples above lack <code>super()</code> calls? The point of the examples is to show how the MRO is constructed. They are <strong>not</strong> intended to print <code>&quot;first\nsecond\third&quot;</code> or whatever. You can â and should, of course, play around with the example, add <code>super()</code> calls, see what happens, and gain a deeper understanding of Python's inheritance model. But my goal here is to keep it simple and show how the MRO is built. And it is built as I explained:</p>
<pre><code>&gt;&gt;&gt; Fourth.__mro__
(&lt;class '__main__.Fourth'&gt;,
 &lt;class '__main__.Second'&gt;, &lt;class '__main__.Third'&gt;,
 &lt;class '__main__.First'&gt;,
 &lt;type 'object'&gt;)
</code></pre>
"
4693385,"<p>The keyword <code>global</code> is only useful to change or create global variables in a local context, although creating global variables is seldom considered a good solution.</p>

<pre><code>def bob():
    me = ""locally defined""    # Defined only in local context
    print(me)

bob()
print(me)     # Asking for a global variable
</code></pre>

<p>The above will give you:</p>

<pre><code>locally defined
Traceback (most recent call last):
  File ""file.py"", line 9, in &lt;module&gt;
    print(me)
NameError: name 'me' is not defined
</code></pre>

<p>While if you use the <code>global</code> statement, the variable will become available ""outside"" the scope of the function, effectively becoming a global variable.</p>

<pre><code>def bob():
    global me
    me = ""locally defined""   # Defined locally but declared as global
    print(me)

bob()
print(me)     # Asking for a global variable
</code></pre>

<p>So the above code will give you:</p>

<pre><code>locally defined
locally defined
</code></pre>

<p>In addition, due to the nature of python, you could also use <code>global</code> to declare functions, classes or other objects in a local context. Although I would advise against it since it causes nightmares if something goes wrong or needs debugging.</p>
"
23435320,"<p>use <code>cumcount()</code>, see docs <a href=""http://pandas.pydata.org/pandas-docs/stable/groupby.html#enumerate-group-items"">here</a></p>

<pre><code>In [4]: df.groupby(['c1', 'c2']).cumcount()
Out[4]: 
0     0
1     1
2     0
3     1
4     0
5     1
6     2
7     0
8     0
9     0
10    1
11    2
dtype: int64
</code></pre>

<p>If you want orderings starting at 1</p>

<pre><code>In [5]: df.groupby(['c1', 'c2']).cumcount()+1
Out[5]: 
0     1
1     2
2     1
3     2
4     1
5     2
6     3
7     1
8     1
9     1
10    2
11    3
dtype: int64
</code></pre>
"
68961797,"<p><strong>Note for pandas versions &lt; 0.20.0</strong>: I will be using <code>df.melt(...)</code> for my examples, but you will need to use <code>pd.melt(df, ...)</code> instead.</p>
<h3>Documentation references:</h3>
<p>Most of the solutions here would be used with <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.melt.html"" rel=""nofollow noreferrer""><code>melt</code></a>, so to know the method <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.melt.html"" rel=""nofollow noreferrer""><code>melt</code></a>, see <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.melt.html"" rel=""nofollow noreferrer"">the documentation explanation</a>.</p>
<blockquote>
<p>Unpivot a DataFrame from wide to long format, optionally leaving
identifiers set.</p>
<p>This function is useful to massage a DataFrame into a format where one
or more columns are identifier variables <em>(id_vars)</em>, while all other
columns, considered measured variables <em>(value_vars)</em>, are âunpivotedâ
to the row axis, leaving just two non-identifier columns, âvariableâ
and âvalueâ.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><p><strong>id_vars</strong> : <em>tuple, list, or ndarray, optional</em></p>
<p>Column(s) to use as identifier variables.</p>
</li>
<li><p><strong>value_vars</strong> : <em>tuple, list, or ndarray, optional</em></p>
<p>Column(s) to unpivot. If not specified, uses all columns that are not set as id_vars.</p>
</li>
<li><p><strong>var_name</strong> : <em>scalar</em></p>
<p>Name to use for the âvariableâ column. If None it uses frame.columns.name or âvariableâ.</p>
</li>
<li><p><strong>value_name</strong> : <em>scalar, default âvalueâ</em></p>
<p>Name to use for the âvalueâ column.</p>
</li>
<li><p><strong>col_level</strong> : <em>int or str, optional</em></p>
<p>If columns are a MultiIndex then use this level to melt.</p>
</li>
<li><p><strong>ignore_index</strong> : <em>bool, default True</em></p>
<p>If True, original index is ignored. If False, the original index is retained. Index labels will be repeated
as necessary.</p>
<p><em>New in version 1.1.0.</em></p>
</li>
</ul>
</blockquote>
<h3>Logic to melting:</h3>
<p>Melting merges multiple columns and converts the dataframe from wide to long, for the solution to Problem 1 (see below), the steps are:</p>
<ol>
<li><p>First we got the original dataframe.</p>
</li>
<li><p>Then the melt firstly merges the <code>Math</code> and <code>English</code> columns and makes the dataframe replicated (longer).</p>
</li>
<li><p>Then finally it adds the column <code>Subject</code> which is the subject of the <code>Grades</code> columns value, respectively:</p>
<p><a href=""https://i.stack.imgur.com/sBEGh.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/sBEGh.png"" alt="""" /></a></p>
</li>
</ol>
<p>This is the simple logic to what the <code>melt</code> function does.</p>
<h3>Solutions:</h3>
<p>I will solve my own questions.</p>
<h4>Problem 1:</h4>
<p>Problem 1 could be solve using <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.melt.html"" rel=""nofollow noreferrer""><code>pd.DataFrame.melt</code></a> with the following code:</p>
<pre><code>print(df.melt(id_vars=['Name', 'Age'], var_name='Subject', value_name='Grades'))
</code></pre>
<p>This code passes the <code>id_vars</code> argument to <code>['Name', 'Age']</code>, then automatically the <code>value_vars</code> would be set to the other columns (<code>['Math', 'English']</code>), which is transposed into that format.</p>
<p>You could also solve Problem 1 using <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.stack.html"" rel=""nofollow noreferrer""><code>stack</code></a> like the below:</p>
<pre><code>print(
    df.set_index([&quot;Name&quot;, &quot;Age&quot;])
    .stack()
    .reset_index(name=&quot;Grade&quot;)
    .rename(columns={&quot;level_2&quot;: &quot;Subject&quot;})
    .sort_values(&quot;Subject&quot;)
    .reset_index(drop=True)
)
</code></pre>
<p>This code sets the <code>Name</code> and <code>Age</code> columns as the index and stacks the rest of the columns <code>Math</code> and <code>English</code>, and resets the index and assigns <code>Grade</code> as the column name, then renames the other column <code>level_2</code> to <code>Subject</code> and then sorts by the <code>Subject</code> column, then finally resets the index again.</p>
<p>Both of these solutions output:</p>
<pre class=""lang-none prettyprint-override""><code>    Name  Age  Subject Grade
0    Bob   13  English     C
1   John   16  English     B
2    Foo   16  English     B
3    Bar   15  English    A+
4   Alex   17  English     F
5    Tom   12  English     A
6    Bob   13     Math    A+
7   John   16     Math     B
8    Foo   16     Math     A
9    Bar   15     Math     F
10  Alex   17     Math     D
11   Tom   12     Math     C
</code></pre>
<h4>Problem 2:</h4>
<p>This is similar to my first question, but this one I only one to filter in the <code>Math</code> columns, this time the <code>value_vars</code> argument can come into use, like the below:</p>
<pre><code>print(
    df.melt(
        id_vars=[&quot;Name&quot;, &quot;Age&quot;],
        value_vars=&quot;Math&quot;,
        var_name=&quot;Subject&quot;,
        value_name=&quot;Grades&quot;,
    )
)
</code></pre>
<p>Or we can also use <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.stack.html"" rel=""nofollow noreferrer""><code>stack</code></a> with column specification:</p>
<pre><code>print(
    df.set_index([&quot;Name&quot;, &quot;Age&quot;])[[&quot;Math&quot;]]
    .stack()
    .reset_index(name=&quot;Grade&quot;)
    .rename(columns={&quot;level_2&quot;: &quot;Subject&quot;})
    .sort_values(&quot;Subject&quot;)
    .reset_index(drop=True)
)
</code></pre>
<p>Both of these solutions give:</p>
<pre class=""lang-none prettyprint-override""><code>   Name  Age Subject Grade
0   Bob   13    Math    A+
1  John   16    Math     B
2   Foo   16    Math     A
3   Bar   15    Math     F
4  Alex   15    Math     D
5   Tom   13    Math     C
</code></pre>
<h2>Problem 3:</h2>
<p>Problem 3 could be solved with <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.melt.html"" rel=""nofollow noreferrer""><code>melt</code></a> and <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html"" rel=""nofollow noreferrer""><code>groupby</code></a>, using the <code>agg</code> function with <code>', '.join</code>, like the below:</p>
<pre><code>print(
    df.melt(id_vars=[&quot;Name&quot;, &quot;Age&quot;])
    .groupby(&quot;value&quot;, as_index=False)
    .agg(&quot;, &quot;.join)
)
</code></pre>
<p>It melts the dataframe then groups by the grades and aggregates them and joins them by a comma.</p>
<p><a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.stack.html"" rel=""nofollow noreferrer""><code>stack</code></a> could be also used to solve this problem, with <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.stack.html"" rel=""nofollow noreferrer""><code>stack</code></a> and <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html"" rel=""nofollow noreferrer""><code>groupby</code></a> like the below:</p>
<pre><code>print(
    df.set_index([&quot;Name&quot;, &quot;Age&quot;])
    .stack()
    .reset_index()
    .rename(columns={&quot;level_2&quot;: &quot;Subjects&quot;, 0: &quot;Grade&quot;})
    .groupby(&quot;Grade&quot;, as_index=False)
    .agg(&quot;, &quot;.join)
)
</code></pre>
<p>This <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.stack.html"" rel=""nofollow noreferrer""><code>stack</code></a> function just transposes the dataframe in a way that is equivalent to <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.melt.html"" rel=""nofollow noreferrer""><code>melt</code></a>, then resets the index, renames the columns and groups and aggregates.</p>
<p>Both solutions output:</p>
<pre class=""lang-none prettyprint-override""><code>  Grade             Name                Subjects
0     A         Foo, Tom           Math, English
1    A+         Bob, Bar           Math, English
2     B  John, John, Foo  Math, English, English
3     C         Bob, Tom           English, Math
4     D             Alex                    Math
5     F        Bar, Alex           Math, English
</code></pre>
<h4>Problem 4:</h4>
<p>We first melt the dataframe for the input data:</p>
<pre><code>df = df.melt(id_vars=['Name', 'Age'], var_name='Subject', value_name='Grades')
</code></pre>
<hr />
<hr />
<p>Then now we can start solving this Problem 4.</p>
<p>Problem 4 could be solved with <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.pivot_table.html"" rel=""nofollow noreferrer""><code>pivot_table</code></a>, we would have to specify to the <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.pivot_table.html"" rel=""nofollow noreferrer""><code>pivot_table</code></a> arguments, <code>values</code>, <code>index</code>, <code>columns</code> and also <code>aggfunc</code>.</p>
<p>We could solve it with the below code:</p>
<pre><code>print(
    df.pivot_table(&quot;Grades&quot;, [&quot;Name&quot;, &quot;Age&quot;], &quot;Subject&quot;, aggfunc=&quot;first&quot;)
    .reset_index()
    .rename_axis(columns=None)
)
</code></pre>
<p>Output:</p>
<pre class=""lang-none prettyprint-override""><code>   Name  Age English Math
0  Alex   15       F    D
1   Bar   15      A+    F
2   Bob   13       C   A+
3   Foo   16       B    A
4  John   16       B    B
5   Tom   13       A    C
</code></pre>
<p>The melted dataframe is converted back to the exact same format as the original dataframe.</p>
<p>We first pivot the melted dataframe and then reset the index and remove the column axis name.</p>
<h4>Problem 5:</h4>
<p>Problem 5 could be solved with <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.melt.html"" rel=""nofollow noreferrer""><code>melt</code></a> and <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html"" rel=""nofollow noreferrer""><code>groupby</code></a> like the following:</p>
<pre><code>print(
    df.melt(id_vars=[&quot;Name&quot;, &quot;Age&quot;], var_name=&quot;Subject&quot;, value_name=&quot;Grades&quot;)
    .groupby(&quot;Name&quot;, as_index=False)
    .agg(&quot;, &quot;.join)
)
</code></pre>
<p>That melts and groups by <code>Name</code>.</p>
<p>Or you could <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.stack.html"" rel=""nofollow noreferrer""><code>stack</code></a>:</p>
<pre><code>print(
    df.set_index([&quot;Name&quot;, &quot;Age&quot;])
    .stack()
    .reset_index()
    .groupby(&quot;Name&quot;, as_index=False)
    .agg(&quot;, &quot;.join)
    .rename({&quot;level_2&quot;: &quot;Subjects&quot;, 0: &quot;Grades&quot;}, axis=1)
)
</code></pre>
<p>Both codes output:</p>
<pre class=""lang-none prettyprint-override""><code>   Name       Subjects Grades
0  Alex  Math, English   D, F
1   Bar  Math, English  F, A+
2   Bob  Math, English  A+, C
3   Foo  Math, English   A, B
4  John  Math, English   B, B
5   Tom  Math, English   C, A
</code></pre>
<h4>Problem 6:</h4>
<p>Problem 6 could be solved with <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.melt.html"" rel=""nofollow noreferrer""><code>melt</code></a> and no column needed to be specified, just specify the expected column names:</p>
<pre><code>print(df.melt(var_name='Column', value_name='Value'))
</code></pre>
<p>That melts the whole dataframe.</p>
<p>Or you could <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.stack.html"" rel=""nofollow noreferrer""><code>stack</code></a>:</p>
<pre><code>print(
    df.stack()
    .reset_index(level=1)
    .sort_values(&quot;level_1&quot;)
    .reset_index(drop=True)
    .set_axis([&quot;Column&quot;, &quot;Value&quot;], axis=1)
)
</code></pre>
<p>Both codes output:</p>
<pre class=""lang-none prettyprint-override""><code>     Column Value
0       Age    16
1       Age    15
2       Age    15
3       Age    16
4       Age    13
5       Age    13
6   English    A+
7   English     B
8   English     B
9   English     A
10  English     F
11  English     C
12     Math     C
13     Math    A+
14     Math     D
15     Math     B
16     Math     F
17     Math     A
18     Name  Alex
19     Name   Bar
20     Name   Tom
21     Name   Foo
22     Name  John
23     Name   Bob
</code></pre>
<h2>Conclusion:</h2>
<p><a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.melt.html"" rel=""nofollow noreferrer""><code>melt</code></a> is a really handy function, and often it's required. Once you meet these types of problems, don't forget to try <a href=""https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.melt.html"" rel=""nofollow noreferrer""><code>melt</code></a>. It may well solve your problem.</p>
"
65264742,"<p>Your application works well. However, you haven't implemented an application loop:</p>
<pre class=""lang-py prettyprint-override""><code>import pygame
from pygame.locals import *

pygame.init()

win = pygame.display.set_mode((400,400))
pygame.display.set_caption(&quot;My first game&quot;)
clock = pygame.time.Clock()

run = True
while run:

    # handle events
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False

    # update game objects
    # [...]

    # clear display
    win.fill((0, 0, 0))

    # draw game objects
    # [...]

    # update display
    pygame.display.flip()

    # limit frames per second
    clock.tick(60) 

pygame.quit()
</code></pre>
<p>The typical PyGame application loop has to:</p>
<ul>
<li>handle the events by calling either <a href=""https://www.pygame.org/docs/ref/event.html#pygame.event.pump"" rel=""nofollow noreferrer""><code>pygame.event.pump()</code></a> or <a href=""https://www.pygame.org/docs/ref/event.html#pygame.event.get"" rel=""nofollow noreferrer""><code>pygame.event.get()</code></a>.</li>
<li>update the game states and positions of objects dependent on the input events and time (respectively frames)</li>
<li>clear the entire display or draw the background</li>
<li>draw the entire scene (<code>blit</code> all the objects)</li>
<li>update the display by calling either <a href=""https://www.pygame.org/docs/ref/display.html#pygame.display.update"" rel=""nofollow noreferrer""><code>pygame.display.update()</code></a> or <a href=""https://www.pygame.org/docs/ref/display.html#pygame.display.flip"" rel=""nofollow noreferrer""><code>pygame.display.flip()</code></a></li>
<li>limit frames per second to limit CPU usage with <a href=""https://www.pygame.org/docs/ref/time.html#pygame.time.Clock"" rel=""nofollow noreferrer""><code>pygame.time.Clock.tick</code></a></li>
</ul>
<p><kbd><a href=""https://repl.it/@Rabbid76/PyGame-MinimalApplicationLoop#main.py"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5jD0C.png"" alt="""" /> repl.it/@Rabbid76/PyGame-MinimalApplicationLoop</a></kbd> See also <a href=""https://github.com/Rabbid76/PyGameExamplesAndAnswers/blob/master/documentation/pygame/pygame_event_and_application_loop.md"" rel=""nofollow noreferrer"">Event and application loop</a></p>
"
,
354130,"<blockquote>
  <p>Which, not only is ugly and slow</p>
</blockquote>

<p>I'd dispute both.</p>

<p>A regex or other string parsing method would be uglier and slower.  </p>

<p>I'm not sure that anything much could be faster than the above.  It calls the function and returns.  Try/Catch doesn't introduce much overhead because the most common exception is caught without an extensive search of stack frames.</p>

<p>The issue is that any numeric conversion function has two kinds of results</p>

<ul>
<li>A number, if the number is valid</li>
<li>A status code (e.g., via errno) or exception to show that no valid number could be parsed.</li>
</ul>

<p>C (as an example) hacks around this a number of ways.  Python lays it out clearly and explicitly.</p>

<p>I think your code for doing this is perfect.</p>
"
4289557,"<p>If you only want to extract only positive integers, try the following:</p>
<pre><code>&gt;&gt;&gt; txt = &quot;h3110 23 cat 444.4 rabbit 11 2 dog&quot;
&gt;&gt;&gt; [int(s) for s in txt.split() if s.isdigit()]
[23, 11, 2]
</code></pre>
<p>I would argue that this is better than the regex example because you don't need another module and it's more readable because you don't need to parse (and learn) the <a href=""https://docs.python.org/3/library/re.html#regular-expression-syntax"" rel=""noreferrer"">regex mini-language</a>.</p>
<p>This will not recognize floats, negative integers, or integers in hexadecimal format.  If you can't accept these limitations, <a href=""https://stackoverflow.com/questions/4289331/python-extract-numbers-of-a-string/4289415#4289415"">jmnas's answer below</a> will do the trick.</p>
"
,
230774,"<p>In Python 3, <a href=""https://docs.python.org/library/functions.html#print"" rel=""noreferrer""><code>print</code></a> can take an optional <code>flush</code> argument:</p>
<pre><code>print(&quot;Hello, World!&quot;, flush=True)
</code></pre>
<p>In Python 2, after calling <code>print</code>, do:</p>
<pre><code>import sys
sys.stdout.flush()
</code></pre>
<p>By default, <a href=""https://docs.python.org/2/reference/simple_stmts.html#the-print-statement"" rel=""noreferrer""><code>print</code></a> prints to <a href=""https://docs.python.org/2/library/sys.html#sys.stdout"" rel=""noreferrer""><code>sys.stdout</code></a> (see the documentation for more about <a href=""https://docs.python.org/2/library/stdtypes.html#file-objects"" rel=""noreferrer"">file objects</a>).</p>
"
4896288,"<p><a href=""https://stackoverflow.com/questions/375427/non-blocking-read-on-a-stream-in-python/4025909#4025909""><code>fcntl</code></a>, <a href=""https://stackoverflow.com/questions/375427/non-blocking-read-on-a-stream-in-python/375511#375511""><code>select</code></a>, <a href=""https://stackoverflow.com/questions/375427/non-blocking-read-on-a-stream-in-python/437888#437888""><code>asyncproc</code></a> won't help in this case.</p>

<p>A reliable way to read a stream without blocking regardless of operating system is to use <a href=""https://docs.python.org/3/library/queue.html#queue.Queue.get_nowait"" rel=""noreferrer""><code>Queue.get_nowait()</code></a>:</p>

<pre><code>import sys
from subprocess import PIPE, Popen
from threading  import Thread

try:
    from queue import Queue, Empty
except ImportError:
    from Queue import Queue, Empty  # python 2.x

ON_POSIX = 'posix' in sys.builtin_module_names

def enqueue_output(out, queue):
    for line in iter(out.readline, b''):
        queue.put(line)
    out.close()

p = Popen(['myprogram.exe'], stdout=PIPE, bufsize=1, close_fds=ON_POSIX)
q = Queue()
t = Thread(target=enqueue_output, args=(p.stdout, q))
t.daemon = True # thread dies with the program
t.start()

# ... do other things here

# read line without blocking
try:  line = q.get_nowait() # or q.get(timeout=.1)
except Empty:
    print('no output yet')
else: # got line
    # ... do something with line
</code></pre>
"
510364,"<p>Here's a link to the ActiveState Recipes site that says how you can read a single character in Windows, Linux and OSX:</p>
<p>Â Â Â Â <a href=""https://code.activestate.com/recipes/134892/"" rel=""noreferrer"">getch()-like unbuffered character reading from stdin on both Windows and Unix</a></p>
<pre><code>class _Getch:
    &quot;&quot;&quot;Gets a single character from standard input.  Does not echo to the
screen.&quot;&quot;&quot;
    def __init__(self):
        try:
            self.impl = _GetchWindows()
        except ImportError:
            self.impl = _GetchUnix()

    def __call__(self): return self.impl()


class _GetchUnix:
    def __init__(self):
        import tty, sys

    def __call__(self):
        import sys, tty, termios
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch


class _GetchWindows:
    def __init__(self):
        import msvcrt

    def __call__(self):
        import msvcrt
        return msvcrt.getch()


getch = _Getch()
</code></pre>
"
3437070,"<p>Use the <a href=""https://docs.python.org/reference/expressions.html#membership-test-details"" rel=""noreferrer""><code>in</code> operator</a>:</p>
<pre><code>if &quot;blah&quot; not in somestring: 
    continue
</code></pre>
"
5458807,"<p>You can use <a href=""http://www.py2exe.org/"" rel=""noreferrer"">py2exe</a> as already answered and use <a href=""http://cython.org/"" rel=""noreferrer"">Cython</a> to convert your key <code>.py</code> files in <code>.pyc</code>, C compiled files, like <code>.dll</code> in Windows and <code>.so</code> on Linux.</p>
<p>It is much harder to revert than common <code>.pyo</code> and <code>.pyc</code> files (and also gain in performance!).</p>
"
1247490,"<p><em>map</em> may be microscopically faster in some cases (when you're <em>not</em> making a lambda for the purpose, but using the same function in map and a <a href=""https://en.wikipedia.org/wiki/List_comprehension#Python"" rel=""noreferrer"">list comprehension</a>). List comprehensions may be faster in other cases and most (not all) Pythonistas consider them more direct and clearer.</p>
<p>An example of the tiny speed advantage of <em>map</em> when using exactly the same function:</p>
<pre class=""lang-none prettyprint-override""><code>$ python -m timeit -s'xs=range(10)' 'map(hex, xs)'
100000 loops, best of 3: 4.86 usec per loop

$ python -m timeit -s'xs=range(10)' '[hex(x) for x in xs]'
100000 loops, best of 3: 5.58 usec per loop
</code></pre>
<p>An example of how performance comparison gets completely reversed when map needs a lambda:</p>
<pre class=""lang-none prettyprint-override""><code>$ python -m timeit -s'xs=range(10)' 'map(lambda x: x+2, xs)'
100000 loops, best of 3: 4.24 usec per loop

$ python -m timeit -s'xs=range(10)' '[x+2 for x in xs]'
100000 loops, best of 3: 2.32 usec per loop
</code></pre>
"
35491399,"<p>You can use the <code>DataFrame</code> constructor with <code>lists</code> created by <a href=""https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.to_list.html"" rel=""noreferrer""><code>to_list</code></a>:</p>
<pre><code>import pandas as pd

d1 = {'teams': [['SF', 'NYG'],['SF', 'NYG'],['SF', 'NYG'],
                ['SF', 'NYG'],['SF', 'NYG'],['SF', 'NYG'],['SF', 'NYG']]}
df2 = pd.DataFrame(d1)
print (df2)
       teams
0  [SF, NYG]
1  [SF, NYG]
2  [SF, NYG]
3  [SF, NYG]
4  [SF, NYG]
5  [SF, NYG]
6  [SF, NYG]
</code></pre>
<hr />
<pre><code>df2[['team1','team2']] = pd.DataFrame(df2.teams.tolist(), index= df2.index)
print (df2)
       teams team1 team2
0  [SF, NYG]    SF   NYG
1  [SF, NYG]    SF   NYG
2  [SF, NYG]    SF   NYG
3  [SF, NYG]    SF   NYG
4  [SF, NYG]    SF   NYG
5  [SF, NYG]    SF   NYG
6  [SF, NYG]    SF   NYG
</code></pre>
<p>And for a new <code>DataFrame</code>:</p>
<pre><code>df3 = pd.DataFrame(df2['teams'].to_list(), columns=['team1','team2'])
print (df3)
  team1 team2
0    SF   NYG
1    SF   NYG
2    SF   NYG
3    SF   NYG
4    SF   NYG
5    SF   NYG
6    SF   NYG
</code></pre>
<p>A solution with <code>apply(pd.Series)</code> is very slow:</p>
<pre><code>#7k rows
df2 = pd.concat([df2]*1000).reset_index(drop=True)

In [121]: %timeit df2['teams'].apply(pd.Series)
1.79 s Â± 52.5 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)

In [122]: %timeit pd.DataFrame(df2['teams'].to_list(), columns=['team1','team2'])
1.63 ms Â± 54.3 Âµs per loop (mean Â± std. dev. of 7 runs, 1000 loops each)
</code></pre>
"
11566296,"<p>The <code>form</code> tag needs some attributes set:</p>
<ol>
<li><code>action</code>: The URL that the form data is sent to on submit. Generate it with <code>url_for</code>. It can be omitted if the same URL handles showing the form and processing the data.</li>
<li><code>method=&quot;post&quot;</code>: Submits the data as form data with the POST method. If not given, or explicitly set to <code>get</code>, the data is submitted in the query string (<code>request.args</code>) with the GET method instead.</li>
<li><code>enctype=&quot;multipart/form-data&quot;</code>: When the form contains file inputs, it must have this encoding set, otherwise the files will not be uploaded and Flask won't see them.</li>
</ol>
<p>The <code>input</code> tag needs a <code>name</code> parameter.</p>
<p>Add a view to handle the submitted data, which is in <code>request.form</code> under the same key as the input's <code>name</code>. Any file inputs will be in <code>request.files</code>.</p>
<pre><code>@app.route('/handle_data', methods=['POST'])
def handle_data():
    projectpath = request.form['projectFilepath']
    # your code
    # return a response
</code></pre>
<p>Set the form's <code>action</code> to that view's URL using <code>url_for</code>:</p>
<pre class=""lang-html prettyprint-override""><code>&lt;form action=&quot;{{ url_for('handle_data') }}&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;projectFilepath&quot;&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre>
"
24085681,"<p>What you are seeing is the <em>representation</em> of <code>my_string</code> created by its <a href=""https://docs.python.org/3/reference/datamodel.html#object.__repr__"" rel=""noreferrer""><code>__repr__()</code></a> method. If you print it, you can see that you've actually got single backslashes, just as you intended:</p>

<pre><code>&gt;&gt;&gt; print(my_string)
why\does\it\happen?
</code></pre>

<p>The string below has <em>three</em> characters in it, not four:</p>

<pre><code>&gt;&gt;&gt; 'a\\b'
'a\\b'
&gt;&gt;&gt; len('a\\b')
3
</code></pre>

<p>You can get the standard representation of a string (or any other object) with the <a href=""https://docs.python.org/3/library/functions.html#repr"" rel=""noreferrer""><code>repr()</code></a> built-in function:</p>

<pre><code>&gt;&gt;&gt; print(repr(my_string))
'why\\does\\it\\happen?'
</code></pre>

<p>Python represents backslashes in strings as <code>\\</code> because the backslash is an escape character - for instance, <code>\n</code> represents a newline, and <code>\t</code> represents a tab.</p>

<p>This can sometimes get you into trouble:</p>

<pre><code>&gt;&gt;&gt; print(""this\text\is\not\what\it\seems"")
this    ext\is
ot\what\it\seems
</code></pre>

<p>Because of this, there needs to be a way to tell Python you <em>really</em> want the two characters <code>\n</code> rather than a newline, and you do that by escaping the backslash itself, with another one:</p>

<pre><code>&gt;&gt;&gt; print(""this\\text\is\what\you\\need"")
this\text\is\what\you\need
</code></pre>

<p>When Python returns the representation of a string, it plays safe, escaping all backslashes (even if they wouldn't otherwise be part of an escape sequence), and that's what you're seeing. However, the string itself contains only single backslashes.</p>

<p><em>More information about Python's string literals can be found at: <a href=""https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals"" rel=""noreferrer"">String and Bytes literals</a> in the Python documentation.</em></p>
"
1534343,"<p><strong>NOTE:</strong> For <strong>Python 3.3+</strong>, see The Aelfinn's <a href=""https://stackoverflow.com/a/39713544/1450294"">answer</a> below.</p>
<hr />
<p>Use the <code>--python</code> (or short <code>-p</code>) option when creating a virtualenv instance to specify the Python executable you want to use, e.g.:</p>
<pre><code>virtualenv --python=&quot;/usr/bin/python2.6&quot; &quot;/path/to/new/virtualenv/&quot;
</code></pre>
"
7027113,"<p>While this is possible, you should not use the Flask dev server in production. The Flask dev server is not designed to be particularly secure, stable, or efficient. See the docs on <a href=""https://flask.palletsprojects.com/deploying/index.html"" rel=""noreferrer"">deploying</a> for correct solutions.</p>
<hr />
<p>The <code>--host</code> option to <code>flask run</code>, or the <code>host</code> parameter to <code>app.run()</code>, controls what address the development server listens to. By default it runs on <code>localhost</code>, change it to <code>flask run --host=0.0.0.0</code> (or <code>app.run(host=&quot;0.0.0.0&quot;)</code>) to run on all your machine's IP addresses.</p>
<p><code>0.0.0.0</code> is a special value that you can't use in the browser directly, you'll need to navigate to the actual IP address of the machine on the network. You may also need to adjust your firewall to allow external access to the port.</p>
<p>The Flask <a href=""https://flask.palletsprojects.com/quickstart/#a-minimal-application"" rel=""noreferrer"">quickstart docs</a> explain this in the &quot;Externally Visible Server&quot; section:</p>
<blockquote>
<p>If you run the server you will notice that the server is only
accessible from your own computer, not from any other in the network.
This is the default because in debugging mode a user of the
application can execute arbitrary Python code on your computer.</p>
<p>If you have the debugger disabled or trust the users on your network,
you can make the server publicly available simply by adding
<code>--host=0.0.0.0</code> to the command line:</p>
<pre class=""lang-none prettyprint-override""><code>$ flask run --host=0.0.0.0
</code></pre>
<p>This tells your operating system to listen on all public IPs.</p>
</blockquote>
"
176921,"<pre class=""lang-py prettyprint-override""><code>&gt;&gt;&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;].index(&quot;bar&quot;)
1
</code></pre>
<p>See <a href=""https://docs.python.org/tutorial/datastructures.html#more-on-lists"" rel=""noreferrer"">the documentation</a> for the built-in <code>.index()</code> method of the list:</p>
<blockquote>
<pre><code>list.index(x[, start[, end]])
</code></pre>
<p>Return zero-based index in the list of the first item whose value is equal to <em>x</em>. Raises a <a href=""https://docs.python.org/library/exceptions.html#ValueError"" rel=""noreferrer""><code>ValueError</code></a> if there is no such item.</p>
<p>The optional arguments <em>start</em> and <em>end</em> are interpreted as in the <a href=""https://docs.python.org/tutorial/introduction.html#lists"" rel=""noreferrer"">slice notation</a> and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument.</p>
</blockquote>
<h2>Caveats</h2>
<h3>Linear time-complexity in list length</h3>
<p>An <code>index</code> call checks every element of the list in order, until it finds a match. If the list is long, and if there is no guarantee that the value will be near the beginning, this can slow down the code.</p>
<p>This problem can only be completely avoided by using a different data structure. However, if the element is known to be within a certain part of the list, the <code>start</code> and <code>end</code> parameters can be used to narrow the search.</p>
<p>For example:</p>
<pre><code>&gt;&gt;&gt; import timeit
&gt;&gt;&gt; timeit.timeit('l.index(999_999)', setup='l = list(range(0, 1_000_000))', number=1000)
9.356267921015387
&gt;&gt;&gt; timeit.timeit('l.index(999_999, 999_990, 1_000_000)', setup='l = list(range(0, 1_000_000))', number=1000)
0.0004404920036904514
</code></pre>
<p>The second call is orders of magnitude faster, because it only has to search through 10 elements, rather than all 1 million.</p>
<h3>Only the index of the <em>first match</em> is returned</h3>
<p>A call to <code>index</code> searches through the list in order until it finds a match, and <em>stops there.</em> If there could be more than one occurrence of the value, and all indices are needed, <code>index</code> cannot solve the problem:</p>
<pre><code>&gt;&gt;&gt; [1, 1].index(1) # the `1` index is not found.
0
</code></pre>
<p>Instead, use a <a href=""/questions/34835951/"">list comprehension or generator expression to do the search</a>, with <a href=""/questions/522563/""><code>enumerate</code> to get indices</a>:</p>
<pre><code>&gt;&gt;&gt; # A list comprehension gives a list of indices directly:
&gt;&gt;&gt; [i for i, e in enumerate([1, 2, 1]) if e == 1]
[0, 2]
&gt;&gt;&gt; # A generator comprehension gives us an iterable object...
&gt;&gt;&gt; g = (i for i, e in enumerate([1, 2, 1]) if e == 1)
&gt;&gt;&gt; # which can be used in a `for` loop, or manually iterated with `next`:
&gt;&gt;&gt; next(g)
0
&gt;&gt;&gt; next(g)
2
</code></pre>
<p>The list comprehension and generator expression techniques still work if there is only one match, and are more generalizable.</p>
<h3>Raises an exception if there is no match</h3>
<p>As noted in the documentation above, using <code>.index</code> will raise an exception if the searched-for value is not in the list:</p>
<pre><code>&gt;&gt;&gt; [1, 1].index(2)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ValueError: 2 is not in list
</code></pre>
<p>If this is a concern, either <a href=""https://stackoverflow.com/questions/12934190"">explicitly check first</a> using <code>item in my_list</code>, or handle the exception with <code>try</code>/<code>except</code> as appropriate.</p>
<p>The explicit check is simple and readable, but it must iterate the list a second time. See <a href=""https://stackoverflow.com/questions/11360858"">What is the EAFP principle in Python?</a> for more guidance on this choice.</p>
"
4700674,"<ul>
<li>You can make the legend text smaller by specifying <code>set_size</code> of <code>FontProperties</code>.</li>
<li>Resources:
<ul>
<li><a href=""https://matplotlib.org/tutorials/intermediate/legend_guide.html#legend-guide"" rel=""noreferrer"">Legend guide</a></li>
<li><a href=""https://matplotlib.org/api/legend_api.html"" rel=""noreferrer""><code>matplotlib.legend</code></a></li>
<li><a href=""https://matplotlib.org/api/_as_gen/matplotlib.pyplot.legend.html#matplotlib.pyplot.legend"" rel=""noreferrer""><code>matplotlib.pyplot.legend</code></a></li>
<li><a href=""https://matplotlib.org/3.3.1/api/font_manager_api.html"" rel=""noreferrer""><code>matplotlib.font_manager</code></a>
<ul>
<li><a href=""https://matplotlib.org/3.3.1/api/font_manager_api.html#matplotlib.font_manager.FontProperties.set_size"" rel=""noreferrer""><code>set_size(self, size)</code></a></li>
<li>Valid font size are <em>xx-small</em>, <em>x-small</em>, <em>small</em>, <em>medium</em>, <em>large</em>, <em>x-large</em>, <em>xx-large</em>, <em>larger</em>, <em>smaller</em>, and <em>None</em>.</li>
</ul>
</li>
<li><a href=""https://realpython.com/python-matplotlib-guide/"" rel=""noreferrer"">Real Python: Python Plotting With Matplotlib (Guide)</a></li>
</ul>
</li>
</ul>
<pre class=""lang-py prettyprint-override""><code>import matplotlib.pyplot as plt
from matplotlib.font_manager import FontProperties

fontP = FontProperties()
fontP.set_size('xx-small')

p1, = plt.plot([1, 2, 3], label='Line 1')
p2, = plt.plot([3, 2, 1], label='Line 2')
plt.legend(handles=[p1, p2], title='title', bbox_to_anchor=(1.05, 1), loc='upper left', prop=fontP)
</code></pre>
<p><a href=""https://i.stack.imgur.com/OMgiC.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/OMgiC.png"" alt=""Enter image description here"" /></a></p>
<ul>
<li><code>fontsize='xx-small'</code> also works, without importing <code>FontProperties</code>.</li>
</ul>
<pre class=""lang-py prettyprint-override""><code>plt.legend(handles=[p1, p2], title='title', bbox_to_anchor=(1.05, 1), loc='upper left', fontsize='xx-small')
</code></pre>
"
2921893,"<p>A single star <code>*</code> unpacks a sequence or collection into positional arguments. Suppose we have</p>
<pre><code>def add(a, b):
    return a + b

values = (1, 2)
</code></pre>
<p>Using the <code>*</code> unpacking operator, we can write <code>s = add(*values)</code>, which will be equivalent to writing <code>s = add(1, 2)</code>.</p>
<p>The double star <code>**</code> does the same thing for a dictionary, providing values for named arguments:</p>
<pre><code>values = { 'a': 1, 'b': 2 }
s = add(**values) # equivalent to add(a=1, b=2)
</code></pre>
<p>Both operators can be used for the same function call. For example, given:</p>
<pre><code>def sum(a, b, c, d):
    return a + b + c + d

values1 = (1, 2)
values2 = { 'c': 10, 'd': 15 }
</code></pre>
<p>then <code>s = add(*values1, **values2)</code> is equivalent to <code>s = sum(1, 2, c=10, d=15)</code>.</p>
<p>See also the <a href=""https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists"" rel=""noreferrer"">relevant section</a> of the tutorial in the Python documentation.</p>
<hr />
<p>Similarly, <code>*</code> and <code>**</code> can be used for parameters. Using <code>*</code> allows a function to accept any number of positional arguments, which will be collected into a single parameter:</p>
<pre><code>def add(*values):
    s = 0
    for v in values:
        s = s + v
    return s
</code></pre>
<p>Now when the function is called like <code>s = add(1, 2, 3, 4, 5)</code>, <code>values</code> will be the tuple <code>(1, 2, 3, 4, 5)</code> (which, of course, produces the result <code>15</code>).</p>
<p>Similarly, a parameter marked with <code>**</code> will receive a <code>dict</code>:</p>
<pre><code>def get_a(**values):
    return values['a']

s = get_a(a=1, b=2)      # returns 1
</code></pre>
<p>this allows for specifying a large number of optional parameters without having to declare them.</p>
<p>Again, both can be combined:</p>
<pre><code>def add(*values, **options):
    s = 0
    for i in values:
        s = s + i
    if &quot;neg&quot; in options:
        if options[&quot;neg&quot;]:
            s = -s
    return s
        
s = add(1, 2, 3, 4, 5)            # returns 15
s = add(1, 2, 3, 4, 5, neg=True)  # returns -15
s = add(1, 2, 3, 4, 5, neg=False) # returns 15
</code></pre>
"
6921225,"<p>This can be done using a <code>lambda</code>, like so:</p>
<pre><code>button = Tk.Button(master=frame, text='press', command= lambda: action(someNumber))
</code></pre>
<p>This is a simple way to bind the argument without an explicit wrapper method or modifying the original <code>action</code>.</p>
"
3052827,"<pre><code>def foo():
    x = 'hello world'
    return x  # return 'hello world' would do, too

foo()
print(x)   # NameError - x is not defined outside the function

y = foo()
print(y)   # this works

x = foo()
print(x)   # this also works, and it's a completely different x than that inside
           # foo()

z = bar(x) # of course, now you can use x as you want

z = bar(foo()) # but you don't have to
</code></pre>
"
6269785,"<p>To quote <a href=""https://docs.python.org/2/reference/lexical_analysis.html#string-literals"" rel=""noreferrer"">the Python 2.x documentation</a>:</p>

<blockquote>
  <p>A prefix of 'b' or 'B' is ignored in
  Python 2; it indicates that the
  literal should become a bytes literal
  in Python 3 (e.g. when code is
  automatically converted with 2to3). A
  'u' or 'b' prefix may be followed by
  an 'r' prefix.</p>
</blockquote>

<p>The <a href=""https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals"" rel=""noreferrer"">Python 3 documentation</a> states:</p>

<blockquote>
  <p>Bytes literals are always prefixed with 'b' or 'B'; they produce an instance of the bytes type instead of the str type. They may only contain ASCII characters; bytes with a numeric value of 128 or greater must be expressed with escapes.</p>
</blockquote>
"
